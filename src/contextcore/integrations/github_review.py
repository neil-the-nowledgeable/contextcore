"""
Risk-Based PR Review Guidance module for ContextCore.
__all__ = ['ReviewPriority', 'ReviewFocus', 'ReviewGuidance', 'PRReviewAnalyzer']


This module provides GitHub PR review analysis that generates review guidance,
checklists, and required reviewer suggestions based on ProjectContext risks.
"""

from enum import Enum
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
import fnmatch

__all__ = ['ReviewPriority', 'ReviewFocus', 'ReviewGuidance', 'PRReviewAnalyzer']


class ReviewPriority(Enum):
    """Priority levels for PR reviews."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

    def ordinal(self) -> int:
        """Return numeric value for priority comparison."""
        return {
            ReviewPriority.CRITICAL: 4,
            ReviewPriority.HIGH: 3,
            ReviewPriority.MEDIUM: 2,
            ReviewPriority.LOW: 1
        }[self]


@dataclass(frozen=True)
class ReviewFocus:
    """Represents a specific area requiring focused review attention."""
    area: str  # Risk area name
    reason: str  # Why this area needs review
    priority: ReviewPriority  # Priority level
    checklist: List[str]  # Specific items to check
    required_reviewers: List[str]  # Required reviewer teams


@dataclass(frozen=True)
class ReviewGuidance:
    """Complete review guidance for a PR."""
    pr_number: str  # PR identifier
    project_id: str  # Project identifier
    focus_areas: List[ReviewFocus]  # Areas requiring review focus
    overall_priority: ReviewPriority  # Highest priority across all areas
    auto_checklist: List[str]  # General checklist items
    warnings: List[str]  # Critical warnings

    def to_markdown(self) -> str:
        """Generate markdown-formatted review guidance."""
        # Priority badge mapping with correct emoji
        badge_mapping = {
            ReviewPriority.CRITICAL: 'ðŸš¨',
            ReviewPriority.HIGH: 'âš ï¸',
            ReviewPriority.MEDIUM: 'ðŸ“‹',
            ReviewPriority.LOW: 'â„¹ï¸'
        }
        priority_badge = badge_mapping[self.overall_priority]
        
        md = f"# {priority_badge} PR Review Guidance - {self.overall_priority.value.capitalize()} Priority\n\n"
        md += f"**PR**: #{self.pr_number} | **Project**: {self.project_id}\n\n"

        # Add warnings section for critical/high priority items
        if self.warnings:
            md += "## âš ï¸ Warnings\n"
            for warning in self.warnings:
                md += f"- {warning}\n"
            md += "\n"

        # Add focus areas with detailed checklists
        if self.focus_areas:
            md += "## ðŸ“‹ Focus Areas\n\n"
            for focus in self.focus_areas:
                focus_badge = badge_mapping[focus.priority]
                md += f"### {focus_badge} {focus.area} Review\n"
                md += f"**Priority**: {focus.priority.value.capitalize()}\n\n"
                md += f"**Reason**: {focus.reason}\n\n"
                
                if focus.required_reviewers:
                    md += f"**Required Reviewers**: " + ', '.join(f"@{reviewer}" for reviewer in focus.required_reviewers) + "\n\n"
                
                md += "**Checklist**:\n"
                for item in focus.checklist:
                    md += f"- [ ] {item}\n"
                md += "\n"

        # Add general checklist if available
        if self.auto_checklist:
            md += "## ðŸ” General Checklist\n"
            for item in self.auto_checklist:
                md += f"- [ ] {item}\n"
            md += "\n"

        md += "---\n*Generated by ContextCore*"
        return md


class PRReviewAnalyzer:
    """Analyzes PRs and generates risk-based review guidance."""
    
    # Comprehensive risk checklists covering all security and compliance requirements
    RISK_CHECKLISTS: Dict[str, List[str]] = {
        "security": [
            "No hardcoded credentials or API keys in code",
            "Input validation implemented for all user data",
            "SQL injection prevention measures in place",
            "XSS protection implemented for web inputs",
            "Authentication checks properly implemented",
            "No sensitive data logged or exposed"
        ],
        "compliance": [
            "Audit logging implemented for data changes",
            "Data retention policies followed",
            "PII handling procedures compliance verified",
            "Change documentation updated per requirements"
        ],
        "data-integrity": [
            "Database transactions properly handled",
            "Idempotency checks implemented where needed",
            "Data validation rules enforced",
            "Backup impact assessment completed"
        ],
        "availability": [
            "Graceful degradation patterns implemented",
            "Circuit breakers configured appropriately",
            "Timeout handling implemented",
            "Health check endpoints updated"
        ],
        "financial": [
            "Cost impact analysis completed",
            "Rate limiting implemented where appropriate",
            "Billing accuracy verification performed"
        ]
    }

    # Reviewer team mappings for different risk types
    RISK_REVIEWERS: Dict[str, List[str]] = {
        "security": ["security-team"],
        "compliance": ["compliance-team", "legal-team"],
        "data-integrity": ["data-team", "backend-team"],
        "availability": ["sre-team", "operations-team"],
        "financial": ["finance-team", "billing-team"]
    }

    def analyze(self, pr_number: str, changed_files: List[str], project_context_spec: Dict[str, Any]) -> ReviewGuidance:
        """
        Analyze a PR and generate comprehensive review guidance.
        
        Args:
            pr_number: Pull request identifier
            changed_files: List of files modified in the PR
            project_context_spec: Project context specification with risks and business info
            
        Returns:
            ReviewGuidance object with all analysis results
        """
        project_id = self._get_project_id(project_context_spec)
        focus_areas = []
        overall_priority = ReviewPriority.LOW
        warnings = []

        # Analyze project risks from context spec
        risks = project_context_spec.get('risks', [])
        business_info = project_context_spec.get('business', {})
        
        # Process each risk in the project context
        for risk in risks:
            risk_type = risk.get('type', '').lower()
            risk_priority_str = risk.get('priority', 'P4')
            risk_scope = risk.get('scope', '')
            risk_description = risk.get('description', '')
            
            # Check if any changed files match the risk scope pattern
            if risk_scope and self._match_files(changed_files, risk_scope):
                priority = self._priority_from_string(risk_priority_str)
                
                # Create focus area for this risk
                if risk_type in self.RISK_CHECKLISTS:
                    focus_areas.append(
                        ReviewFocus(
                            area=risk_type.capitalize().replace('-', ' '),
                            reason=f"Changes affect {risk_scope}: {risk_description}",
                            priority=priority,
                            checklist=self.RISK_CHECKLISTS[risk_type].copy(),
                            required_reviewers=self.RISK_REVIEWERS.get(risk_type, [])
                        )
                    )
                    
                    # Update overall priority if this risk is higher
                    if priority.ordinal() > overall_priority.ordinal():
                        overall_priority = priority

        # Add business criticality warnings
        criticality = business_info.get('criticality', '').lower()
        if criticality in ['critical', 'high'] and overall_priority in [ReviewPriority.CRITICAL, ReviewPriority.HIGH]:
            warnings.append(f"This change affects a {criticality} criticality business service")

        # Generate general checklist based on file types
        auto_checklist = self._generate_general_checklist(changed_files)

        return ReviewGuidance(
            pr_number=pr_number,
            project_id=project_id,
            focus_areas=focus_areas,
            overall_priority=overall_priority,
            auto_checklist=auto_checklist,
            warnings=warnings
        )

    def _get_project_id(self, spec: Dict[str, Any]) -> str:
        """Extract project ID from specification."""
        return spec.get('project_id', spec.get('name', 'unknown-project'))

    def _match_files(self, files: List[str], pattern: str) -> List[str]:
        """Match files against a pattern using fnmatch."""
        return [f for f in files if fnmatch.fnmatch(f, pattern)]

    def _priority_from_string(self, priority_str: str) -> ReviewPriority:
        """Convert priority string (P1-P4) to ReviewPriority enum."""
        mapping = {
            "P1": ReviewPriority.CRITICAL,
            "P2": ReviewPriority.HIGH,
            "P3": ReviewPriority.MEDIUM,
            "P4": ReviewPriority.LOW
        }
        return mapping.get(priority_str.upper(), ReviewPriority.MEDIUM)

    def _generate_general_checklist(self, files: List[str]) -> List[str]:
        """Generate general checklist items based on changed files."""
        checklist = []
        
        # Python files
        if self._match_files(files, '*.py'):
            checklist.extend([
                "Code follows PEP 8 style guidelines",
                "Unit tests added/updated for new functionality",
                "Docstrings updated for public methods"
            ])
        
        # JavaScript/TypeScript files
        if self._match_files(files, '*.js') or self._match_files(files, '*.ts'):
            checklist.extend([
                "ESLint rules followed",
                "Frontend tests updated where applicable"
            ])
        
        # Configuration files
        if self._match_files(files, '*.yaml') or self._match_files(files, '*.yml') or self._match_files(files, '*.json'):
            checklist.append("Configuration changes reviewed and validated")
        
        # Database migrations
        if self._match_files(files, '*migration*') or self._match_files(files, '*schema*'):
            checklist.extend([
                "Database migration is reversible",
                "Migration tested on staging environment"
            ])
        
        # Always include basic checks
        checklist.extend([
            "PR description clearly explains the changes",
            "Breaking changes documented and communicated"
        ])
        
        return checklist
