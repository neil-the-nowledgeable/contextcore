"""
Risk-Based PR Review Guidance module for ContextCore.

This module provides GitHub PR review analysis that generates review guidance,
checklists, and required reviewer suggestions based on ProjectContext risks.

Prime Contractor Pattern: Spec by Claude, drafts by GPT-4o-mini, integration by Claude.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
import fnmatch

__all__ = ['ReviewPriority', 'ReviewFocus', 'ReviewGuidance', 'PRReviewAnalyzer']


class ReviewPriority(Enum):
    """Priority levels for PR reviews."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

    @property
    def ordinal(self) -> int:
        """Return numeric value for priority comparison (higher = more urgent)."""
        return {
            ReviewPriority.CRITICAL: 4,
            ReviewPriority.HIGH: 3,
            ReviewPriority.MEDIUM: 2,
            ReviewPriority.LOW: 1
        }[self]


@dataclass
class ReviewFocus:
    """Represents a specific area requiring focused review attention."""
    area: str  # Risk area name
    reason: str  # Why this area needs review
    priority: ReviewPriority  # Priority level
    checklist: List[str] = field(default_factory=list)  # Specific items to check
    required_reviewers: List[str] = field(default_factory=list)  # Required reviewer teams


@dataclass
class ReviewGuidance:
    """Complete review guidance for a PR."""
    pr_number: int  # PR number
    project_id: str  # Project identifier
    focus_areas: List[ReviewFocus] = field(default_factory=list)  # Areas requiring review
    overall_priority: ReviewPriority = ReviewPriority.LOW  # Highest priority
    auto_checklist: List[str] = field(default_factory=list)  # General checklist items
    warnings: List[str] = field(default_factory=list)  # Critical warnings

    def to_markdown(self) -> str:
        """Generate markdown-formatted review guidance."""
        # Priority badge mapping
        badge_mapping = {
            ReviewPriority.CRITICAL: '\U0001f6a8',  # Red siren
            ReviewPriority.HIGH: '\u26a0\ufe0f',    # Warning sign
            ReviewPriority.MEDIUM: '\U0001f4cb',   # Clipboard
            ReviewPriority.LOW: '\u2139\ufe0f'     # Info
        }
        priority_badge = badge_mapping[self.overall_priority]

        lines = []
        lines.append(f"## {priority_badge} ContextCore Review Guidance\n")
        lines.append(f"**Project**: {self.project_id}")
        lines.append(f"**PR**: #{self.pr_number}")
        lines.append(f"**Review Priority**: {self.overall_priority.value.upper()}\n")

        # Warnings section
        if self.warnings:
            lines.append("### \u26a0\ufe0f Warnings\n")
            for warning in self.warnings:
                lines.append(f"- {warning}")
            lines.append("")

        # Focus areas
        if self.focus_areas:
            lines.append("### Focus Areas\n")
            for focus in self.focus_areas:
                focus_badge = badge_mapping[focus.priority]
                lines.append(f"#### {focus_badge} {focus.area} ({focus.priority.value})")
                lines.append(f"> {focus.reason}\n")

                if focus.checklist:
                    lines.append("**Checklist:**")
                    for item in focus.checklist:
                        lines.append(f"- [ ] {item}")
                    lines.append("")

                if focus.required_reviewers:
                    reviewers = ", ".join(f"@{r}" for r in focus.required_reviewers)
                    lines.append(f"**Required reviewers**: {reviewers}\n")

        # Auto-generated checklist
        if self.auto_checklist:
            lines.append("### General Checklist\n")
            for item in self.auto_checklist:
                lines.append(f"- [ ] {item}")
            lines.append("")

        lines.append("---")
        lines.append("_Generated by ContextCore from ProjectContext risk analysis_")

        return "\n".join(lines)


class PRReviewAnalyzer:
    """Analyze PRs against ProjectContext for review guidance."""

    # Map risk types to review focus areas
    RISK_CHECKLISTS: Dict[str, List[str]] = {
        "security": [
            "No hardcoded credentials or secrets",
            "Input validation on all user-provided data",
            "SQL/NoSQL injection prevention verified",
            "XSS prevention in any HTML output",
            "Authentication/authorization checks in place",
            "Sensitive data not logged",
        ],
        "compliance": [
            "Audit logging for compliance-relevant operations",
            "Data retention policies followed",
            "PII handling follows data protection requirements",
            "Change is documented for audit trail",
        ],
        "data-integrity": [
            "Database transactions used appropriately",
            "Idempotency implemented for mutations",
            "Data validation at system boundaries",
            "Backup/recovery impact considered",
        ],
        "availability": [
            "Graceful degradation implemented",
            "Circuit breakers for external dependencies",
            "Timeout configuration appropriate",
            "Health check endpoints updated if needed",
        ],
        "financial": [
            "Cost impact of change assessed",
            "Rate limiting in place for expensive operations",
            "Billing/metering accuracy verified",
        ],
    }

    # Risk type to reviewer team mapping
    RISK_REVIEWERS: Dict[str, List[str]] = {
        "security": ["security-team"],
        "compliance": ["compliance-team", "legal"],
        "data-integrity": ["data-team", "dba"],
        "financial": ["finance-eng"],
    }

    def analyze(
        self,
        pr_number: int,
        changed_files: List[str],
        project_context_spec: Dict[str, Any],
    ) -> ReviewGuidance:
        """
        Analyze PR against ProjectContext risks.

        Args:
            pr_number: Pull request number
            changed_files: List of files changed in the PR
            project_context_spec: ProjectContext specification dictionary

        Returns:
            ReviewGuidance with focus areas, checklists, and warnings
        """
        project_id = self._get_project_id(project_context_spec)
        risks = project_context_spec.get("risks", [])
        business = project_context_spec.get("business", {})

        guidance = ReviewGuidance(
            pr_number=pr_number,
            project_id=project_id,
        )

        # Check each risk against changed files
        for risk in risks:
            risk_type = risk.get("type", "").lower()
            risk_scope = risk.get("scope", "")  # Optional path pattern
            risk_priority = risk.get("priority", "P3")

            # Check if any changed file matches risk scope
            if risk_scope:
                matching_files = self._match_files(changed_files, risk_scope)
                if not matching_files:
                    continue  # Risk doesn't apply to this PR
            else:
                matching_files = changed_files  # Risk applies to all changes

            # Create focus area for this risk
            checklist = self.RISK_CHECKLISTS.get(risk_type, []).copy()

            # Add risk-specific mitigation to checklist
            if risk.get("mitigation"):
                checklist.append(f"Mitigation verified: {risk['mitigation']}")

            # Add controls verification
            for control in risk.get("controls", []):
                checklist.append(f"Control in place: {control}")

            focus = ReviewFocus(
                area=risk_type.replace("-", " ").title(),
                reason=risk.get("description", f"Risk area: {risk_type}"),
                priority=self._priority_from_string(risk_priority),
                checklist=checklist,
                required_reviewers=self.RISK_REVIEWERS.get(risk_type, []).copy(),
            )

            guidance.focus_areas.append(focus)

        # Determine overall priority
        if guidance.focus_areas:
            guidance.overall_priority = max(
                guidance.focus_areas,
                key=lambda f: f.priority.ordinal
            ).priority

        # Add warnings for high-criticality services
        criticality = business.get("criticality", "").lower()
        if criticality in ["critical", "high"]:
            guidance.warnings.append(
                f"This is a {criticality} criticality service. "
                "Extra scrutiny required."
            )

        # Add general checklist items based on change scope
        guidance.auto_checklist = self._generate_general_checklist(changed_files)

        return guidance

    def _get_project_id(self, spec: Dict[str, Any]) -> str:
        """Extract project ID from specification."""
        project = spec.get("project", {})
        if isinstance(project, dict):
            return project.get("id", "unknown")
        return str(project) if project else "unknown"

    def _match_files(self, files: List[str], pattern: str) -> List[str]:
        """Match files against glob-like pattern."""
        return [f for f in files if fnmatch.fnmatch(f, pattern)]

    def _priority_from_string(self, priority_str: str) -> ReviewPriority:
        """Convert P1-P4 priority string to ReviewPriority enum."""
        mapping = {
            "P1": ReviewPriority.CRITICAL,
            "P2": ReviewPriority.HIGH,
            "P3": ReviewPriority.MEDIUM,
            "P4": ReviewPriority.LOW,
        }
        return mapping.get(priority_str.upper(), ReviewPriority.MEDIUM)

    def _generate_general_checklist(self, files: List[str]) -> List[str]:
        """Generate general checklist based on files changed."""
        checklist = []

        # Check for test files
        has_tests = any("test" in f.lower() for f in files)
        if not has_tests:
            checklist.append("Tests added/updated for changes")

        # Check for config changes
        config_files = [f for f in files if any(
            f.endswith(ext) for ext in [".yaml", ".yml", ".json", ".toml", ".env"]
        )]
        if config_files:
            checklist.append("Configuration changes reviewed for security")
            checklist.append("Environment-specific values not hardcoded")

        # Check for API changes
        api_files = [f for f in files if "api" in f.lower() or "handler" in f.lower()]
        if api_files:
            checklist.append("API changes are backwards compatible (or versioned)")
            checklist.append("API documentation updated")

        # Check for database changes
        db_files = [f for f in files if any(
            term in f.lower() for term in ["migration", "schema", "model", "db"]
        )]
        if db_files:
            checklist.append("Database migration is reversible")
            checklist.append("Migration tested on production-like data")

        return checklist
