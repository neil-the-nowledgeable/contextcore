"""
Central type definitions for ContextCore.

This module is the SINGLE SOURCE OF TRUTH for all status, priority, and type enums
used throughout ContextCore. All other modules should import from here to prevent
naming drift and ensure consistency.

Usage:
    from contextcore.contracts.types import TaskStatus, Priority, InsightType
"""

from __future__ import annotations

from enum import Enum


class TaskStatus(str, Enum):
    """
    Task lifecycle statuses.

    These statuses apply to tasks tracked via TaskTracker and are used
    consistently across spans, logs, and metrics.
    """

    BACKLOG = "backlog"
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    IN_REVIEW = "in_review"
    BLOCKED = "blocked"
    DONE = "done"
    CANCELLED = "cancelled"

    @classmethod
    def active_statuses(cls) -> list["TaskStatus"]:
        """Return statuses that indicate active work."""
        return [cls.TODO, cls.IN_PROGRESS, cls.IN_REVIEW, cls.BLOCKED]

    @classmethod
    def terminal_statuses(cls) -> list["TaskStatus"]:
        """Return statuses that indicate work is finished."""
        return [cls.DONE, cls.CANCELLED]


class HandoffStatus(str, Enum):
    """
    Agent handoff lifecycle statuses.

    Used for agent-to-agent task delegation tracking.
    """

    PENDING = "pending"
    ACCEPTED = "accepted"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"

    @classmethod
    def active_statuses(cls) -> list["HandoffStatus"]:
        """Return statuses that indicate handoff is in progress."""
        return [cls.PENDING, cls.ACCEPTED, cls.IN_PROGRESS]

    @classmethod
    def terminal_statuses(cls) -> list["HandoffStatus"]:
        """Return statuses that indicate handoff is finished."""
        return [cls.COMPLETED, cls.FAILED, cls.TIMEOUT]


class SessionStatus(str, Enum):
    """
    Agent session lifecycle statuses.

    Used for tracking agent session state.
    """

    ACTIVE = "active"
    COMPLETED = "completed"
    ABANDONED = "abandoned"


class Priority(str, Enum):
    """
    Priority levels for tasks, handoffs, and questions.

    This is the canonical priority system used throughout ContextCore.
    Note: AlertPriority (P1-P4) is a separate system for alert severity.
    """

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

    @classmethod
    def from_alert_priority(cls, alert_priority: str) -> "Priority":
        """Convert AlertPriority (P1-P4) to Priority."""
        mapping = {
            "P1": cls.CRITICAL,
            "P2": cls.HIGH,
            "P3": cls.MEDIUM,
            "P4": cls.LOW,
        }
        return mapping.get(alert_priority, cls.MEDIUM)

    def to_alert_priority(self) -> str:
        """Convert to AlertPriority (P1-P4)."""
        mapping = {
            Priority.CRITICAL: "P1",
            Priority.HIGH: "P2",
            Priority.MEDIUM: "P3",
            Priority.LOW: "P4",
        }
        return mapping[self]


class AlertPriority(str, Enum):
    """
    Alert priority levels (P1-P4 system).

    Used for alert severity classification. Maps to Priority enum.
    """

    P1 = "P1"
    P2 = "P2"
    P3 = "P3"
    P4 = "P4"


class TaskType(str, Enum):
    """Task hierarchy types."""

    EPIC = "epic"
    STORY = "story"
    TASK = "task"
    SUBTASK = "subtask"
    BUG = "bug"
    SPIKE = "spike"
    INCIDENT = "incident"


class AgentType(str, Enum):
    """
    Agent type classification.

    Used to categorize agents by their primary function.
    """

    CODE_ASSISTANT = "code_assistant"
    ORCHESTRATOR = "orchestrator"
    SPECIALIST = "specialist"
    AUTOMATION = "automation"


class InsightType(str, Enum):
    """
    Agent insight types.

    Categorizes the type of insight generated by an agent.

    Naming Convention:
        - Enum members and values use SINGULAR form (decision, not decisions)
        - Use singular form in attributes: insight_type="decision"
        - Use plural form for collections: List[InsightType], "recent_decisions"
        - Query methods may use plural in names: query_decisions(), list_blockers()

    Examples:
        # Correct - singular for attribute values
        insight = InsightData(insight_type=InsightType.DECISION.value, ...)

        # Correct - plural for collections
        decisions: List[InsightData] = querier.query(insight_type="decision")

        # Wrong - don't use plural in attribute values
        # insight_type="decisions"  # DON'T DO THIS
    """

    DECISION = "decision"
    RECOMMENDATION = "recommendation"
    BLOCKER = "blocker"
    DISCOVERY = "discovery"


class ConstraintSeverity(str, Enum):
    """Severity levels for agent constraints."""

    BLOCKING = "blocking"
    WARNING = "warning"
    ADVISORY = "advisory"


class QuestionStatus(str, Enum):
    """Status of questions for agents to answer."""

    OPEN = "open"
    ANSWERED = "answered"
    DEFERRED = "deferred"


class Criticality(str, Enum):
    """Business criticality levels."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class BusinessValue(str, Enum):
    """Business value classifications."""

    REVENUE_PRIMARY = "revenue-primary"
    REVENUE_SECONDARY = "revenue-secondary"
    COST_REDUCTION = "cost-reduction"
    COMPLIANCE = "compliance"
    ENABLER = "enabler"
    INTERNAL = "internal"


class RiskType(str, Enum):
    """Risk category types."""

    SECURITY = "security"
    COMPLIANCE = "compliance"
    DATA_INTEGRITY = "data-integrity"
    AVAILABILITY = "availability"
    FINANCIAL = "financial"
    REPUTATIONAL = "reputational"


class DashboardPlacement(str, Enum):
    """Dashboard visibility levels."""

    FEATURED = "featured"
    STANDARD = "standard"
    ARCHIVED = "archived"


class LogLevel(str, Enum):
    """Log levels."""

    DEBUG = "debug"
    INFO = "info"
    WARN = "warn"
    ERROR = "error"


class PropagationStatus(str, Enum):
    """Context propagation status at a workflow boundary."""

    PROPAGATED = "propagated"
    DEFAULTED = "defaulted"
    PARTIAL = "partial"
    FAILED = "failed"


class ChainStatus(str, Enum):
    """End-to-end propagation chain status."""

    INTACT = "intact"  # All waypoints + destination present, verification passes
    DEGRADED = "degraded"  # Source present but destination has default value
    BROKEN = "broken"  # Source absent or verification fails


class CompatibilityLevel(str, Enum):
    """Schema compatibility check level."""

    STRUCTURAL = "structural"
    SEMANTIC = "semantic"
    BEHAVIORAL = "behavioral"


class EnforcementMode(str, Enum):
    """Runtime boundary enforcement mode for Layer 4.

    Controls how the RuntimeBoundaryGuard handles validation failures.
    """

    STRICT = "strict"
    """Blocking failures raise an exception and halt the phase."""

    PERMISSIVE = "permissive"
    """Blocking failures are logged but the phase continues."""

    AUDIT = "audit"
    """Everything is logged and emitted via OTel, but nothing blocks."""


class EvaluationPolicy(str, Enum):
    """Policy for evaluation-gated fields (REQ_CONCERN_13)."""

    SCORE_THRESHOLD = "score_threshold"
    """Field must receive a numeric score >= threshold to propagate."""

    HUMAN_OR_MODEL = "human_or_model"
    """Any evaluator (human or model) must stamp approval."""

    HUMAN_REQUIRED = "human_required"
    """Only human evaluation satisfies the gate."""

    ANY_EVALUATOR = "any_evaluator"
    """Any stamp of any kind satisfies the gate."""


# ---------------------------------------------------------------------------
# Layer 3: Semantic Convention types
# ---------------------------------------------------------------------------


class RequirementLevel(str, Enum):
    """Requirement level for semantic conventions (Layer 3)."""

    REQUIRED = "required"
    """Attribute must be present."""

    RECOMMENDED = "recommended"
    """Attribute should be present but absence is tolerated."""

    OPT_IN = "opt_in"
    """Attribute is entirely optional."""


# ---------------------------------------------------------------------------
# Layer 5: Capability Propagation types
# ---------------------------------------------------------------------------


class CapabilityChainStatus(str, Enum):
    """End-to-end capability propagation status (Layer 5)."""

    INTACT = "intact"
    """Capability propagated without change."""

    ATTENUATED = "attenuated"
    """Capability was narrowed (valid attenuation)."""

    ESCALATION_BLOCKED = "escalation_blocked"
    """Attempted capability escalation was blocked."""

    BROKEN = "broken"
    """Capability missing or chain verification fails."""


# ---------------------------------------------------------------------------
# Layer 6: SLO Budget types
# ---------------------------------------------------------------------------


class BudgetType(str, Enum):
    """Budget metric type (Layer 6)."""

    LATENCY_MS = "latency_ms"
    COST_DOLLARS = "cost_dollars"
    TOKEN_COUNT = "token_count"
    ERROR_RATE = "error_rate"
    CUSTOM = "custom"


class OverflowPolicy(str, Enum):
    """Policy when a budget allocation is exceeded (Layer 6)."""

    WARN = "warn"
    """Log a warning but continue execution."""

    BLOCK = "block"
    """Halt execution if budget is exceeded."""

    REDISTRIBUTE = "redistribute"
    """Redistribute remaining budget from under-budget phases."""


class BudgetHealth(str, Enum):
    """Budget health status at a boundary check (Layer 6)."""

    WITHIN_BUDGET = "within_budget"
    OVER_ALLOCATION = "over_allocation"
    BUDGET_EXHAUSTED = "budget_exhausted"


# ---------------------------------------------------------------------------
# Layer 7: Data Lineage types
# ---------------------------------------------------------------------------


class TransformOp(str, Enum):
    """Transformation operation type (Layer 7)."""

    PASSTHROUGH = "passthrough"
    """Value forwarded without change."""

    CLASSIFY = "classify"
    """Value classified into a category."""

    TRANSFORM = "transform"
    """Value transformed (different output)."""

    DERIVE = "derive"
    """New value derived from one or more inputs."""

    AGGREGATE = "aggregate"
    """Multiple values aggregated into one."""

    FILTER = "filter"
    """Value filtered (subset selection)."""


class LineageStatus(str, Enum):
    """Data lineage chain verification status (Layer 7)."""

    VERIFIED = "verified"
    """Lineage chain matches declared spec."""

    MUTATION_DETECTED = "mutation_detected"
    """Unexpected hash change in a passthrough stage."""

    CHAIN_BROKEN = "chain_broken"
    """Missing transformation record in the chain."""

    INCOMPLETE = "incomplete"
    """Lineage exists but doesn't cover all declared stages."""


# Convenience lists for validation
TASK_STATUS_VALUES = [s.value for s in TaskStatus]
PRIORITY_VALUES = [p.value for p in Priority]
TASK_TYPE_VALUES = [t.value for t in TaskType]
AGENT_TYPE_VALUES = [a.value for a in AgentType]
INSIGHT_TYPE_VALUES = [i.value for i in InsightType]
HANDOFF_STATUS_VALUES = [h.value for h in HandoffStatus]
SESSION_STATUS_VALUES = [s.value for s in SessionStatus]
PROPAGATION_STATUS_VALUES = [s.value for s in PropagationStatus]
CHAIN_STATUS_VALUES = [s.value for s in ChainStatus]
COMPATIBILITY_LEVEL_VALUES = [c.value for c in CompatibilityLevel]
ENFORCEMENT_MODE_VALUES = [e.value for e in EnforcementMode]
EVALUATION_POLICY_VALUES = [e.value for e in EvaluationPolicy]
REQUIREMENT_LEVEL_VALUES = [r.value for r in RequirementLevel]
CAPABILITY_CHAIN_STATUS_VALUES = [c.value for c in CapabilityChainStatus]
BUDGET_TYPE_VALUES = [b.value for b in BudgetType]
OVERFLOW_POLICY_VALUES = [o.value for o in OverflowPolicy]
BUDGET_HEALTH_VALUES = [b.value for b in BudgetHealth]
TRANSFORM_OP_VALUES = [t.value for t in TransformOp]
LINEAGE_STATUS_VALUES = [l.value for l in LineageStatus]
