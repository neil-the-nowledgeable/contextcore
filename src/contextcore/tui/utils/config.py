"""Configuration management utilities for ContextCore TUI."""

from __future__ import annotations

import asyncio
import os
import socket
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import aiohttp

__all__ = ["ConfigItem", "ConfigManager", "CONFIG_SCHEMA"]


@dataclass
class ConfigItem:
    """Configuration item definition."""
    name: str
    default: str
    description: str
    is_password: bool = False
    choices: Optional[List[str]] = None


CONFIG_SCHEMA: Dict[str, List[ConfigItem]] = {
    "Endpoints": [
        ConfigItem(
            "OTEL_EXPORTER_OTLP_ENDPOINT",
            "localhost:4317",
            "OTLP gRPC endpoint for traces and metrics"
        ),
        ConfigItem(
            "GRAFANA_URL",
            "http://localhost:3000",
            "Grafana dashboard base URL"
        ),
        ConfigItem(
            "TEMPO_URL",
            "http://localhost:3200",
            "Tempo tracing backend URL"
        ),
        ConfigItem(
            "MIMIR_URL",
            "http://localhost:9009",
            "Mimir metrics backend URL"
        ),
        ConfigItem(
            "LOKI_URL",
            "http://localhost:3100",
            "Loki logging backend URL"
        ),
    ],
    "Credentials": [
        ConfigItem(
            "GRAFANA_USER",
            "admin",
            "Grafana username for authentication"
        ),
        ConfigItem(
            "GRAFANA_PASSWORD",
            "admin",
            "Grafana password for authentication",
            is_password=True
        ),
    ],
    "OTel Settings": [
        ConfigItem(
            "CONTEXTCORE_EMIT_MODE",
            "dual",
            "OpenTelemetry emission mode",
            choices=["dual", "legacy", "otel"]
        ),
    ],
}


class ConfigManager:
    """Manages configuration loading and saving."""

    def __init__(self, env_file: Optional[Path] = None) -> None:
        self.env_file = env_file or Path(".env")

    async def load_config(self) -> Dict[str, str]:
        """Load configuration from environment and .env file."""
        config = {}

        # Start with defaults
        for section in CONFIG_SCHEMA.values():
            for item in section:
                config[item.name] = item.default

        # Override with environment variables
        for key in config.keys():
            if key in os.environ:
                config[key] = os.environ[key]

        # Override with .env file if available
        if self.env_file.exists():
            try:
                env_vars = self._parse_env_file(self.env_file)
                config.update(env_vars)
            except Exception:
                pass

        return config

    def _parse_env_file(self, path: Path) -> Dict[str, str]:
        """Parse a .env file and return key-value pairs."""
        env_vars = {}
        try:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip()
                        # Remove quotes if present
                        if (value.startswith('"') and value.endswith('"')) or \
                           (value.startswith("'") and value.endswith("'")):
                            value = value[1:-1]
                        env_vars[key] = value
        except Exception:
            pass
        return env_vars

    async def save_config(self, config: Dict[str, str]) -> bool:
        """Save configuration to .env file."""
        try:
            # Ensure parent directory exists
            self.env_file.parent.mkdir(parents=True, exist_ok=True)

            # Write configuration
            with open(self.env_file, 'w', encoding='utf-8') as f:
                f.write("# ContextCore Configuration\n")
                f.write("# Generated by ContextCore TUI\n\n")

                # Write by sections for better organization
                for section_name, items in CONFIG_SCHEMA.items():
                    f.write(f"# {section_name}\n")
                    for item in items:
                        value = config.get(item.name, item.default)
                        # Escape values with spaces or special characters
                        if ' ' in value or any(c in value for c in '="\''):
                            value = f'"{value}"'
                        f.write(f"{item.name}={value}\n")
                    f.write("\n")

            return True

        except Exception as e:
            print(f"Error saving config: {e}")
            return False

    async def test_endpoint(self, name: str, url: str) -> Tuple[bool, Optional[int], Optional[str]]:
        """Test endpoint connectivity.

        Returns:
            Tuple of (success, response_time_ms, error_message)
        """
        start_time = time.time()

        try:
            # Handle OTLP gRPC endpoint (TCP check)
            if "OTLP" in name:
                return await self._test_tcp_endpoint(url)

            # Handle HTTP endpoints
            return await self._test_http_endpoint(url)

        except Exception as e:
            return False, None, str(e)

    async def _test_http_endpoint(self, url: str) -> Tuple[bool, Optional[int], Optional[str]]:
        """Test HTTP endpoint."""
        start_time = time.time()

        # Try common health endpoints
        health_paths = ["/api/health", "/health", "/ready", "/-/healthy", ""]

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=2.0)
            ) as session:
                for path in health_paths:
                    check_url = url.rstrip('/') + path
                    try:
                        async with session.get(check_url) as response:
                            response_time_ms = int((time.time() - start_time) * 1000)
                            if response.status < 400:
                                return True, response_time_ms, None
                    except (aiohttp.ClientError, asyncio.TimeoutError):
                        continue

                return False, None, "All health endpoints failed"

        except asyncio.TimeoutError:
            return False, None, "Connection timeout"
        except aiohttp.ClientConnectorError:
            return False, None, "Connection refused"
        except Exception as e:
            return False, None, str(e)

    async def _test_tcp_endpoint(self, endpoint: str) -> Tuple[bool, Optional[int], Optional[str]]:
        """Test TCP endpoint."""
        start_time = time.time()

        try:
            # Parse host:port
            if ':' in endpoint:
                host, port_str = endpoint.rsplit(':', 1)
                port = int(port_str)
            else:
                host = endpoint
                port = 4317

            # Remove protocol if present
            host = host.replace('http://', '').replace('https://', '')

            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=2.0
            )
            response_time_ms = int((time.time() - start_time) * 1000)

            writer.close()
            await writer.wait_closed()

            return True, response_time_ms, None

        except asyncio.TimeoutError:
            return False, None, "Connection timeout"
        except ConnectionRefusedError:
            return False, None, "Connection refused"
        except Exception as e:
            return False, None, str(e)
