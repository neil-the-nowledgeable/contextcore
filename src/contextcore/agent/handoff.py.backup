"""
Handoff management for ContextCore agent-to-agent communication.

This module provides status tracking and state management for agent handoffs,
with support for A2A-aligned states and transition validation.
"""

from __future__ import annotations
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Set

__all__ = [
    'HandoffStatus',
    'StateTransition',
    'Handoff',
    'VALID_TRANSITIONS',
    'validate_transition',
    'HandoffManager',
    'HandoffReceiver',
    'HandoffStorage',
    'HandoffResult',
]


class HandoffStatus(str, Enum):
    """Enumeration of possible handoff states with helper methods."""
    
    # Existing states (preserved for backward compatibility)
    PENDING = "pending"
    ACCEPTED = "accepted"
    IN_PROGRESS = "in_progress" 
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    
    # New A2A-aligned states
    INPUT_REQUIRED = "input_required"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    
    def is_terminal(self) -> bool:
        """Check if this status represents a terminal state.
        
        Terminal states cannot transition to any other state and
        represent the end of a handoff lifecycle.
        
        Returns:
            bool: True if status is terminal (COMPLETED, FAILED, TIMEOUT, CANCELLED, REJECTED)
        """
        return self in _TERMINAL_STATES
    
    def is_active(self) -> bool:
        """Check if this status represents an active state.
        
        Active states indicate the handoff is still being processed
        and may transition to other states.
        
        Returns:
            bool: True if status is active (PENDING, ACCEPTED, IN_PROGRESS, INPUT_REQUIRED)
        """
        return self in _ACTIVE_STATES
    
    def can_accept_messages(self) -> bool:
        """Check if handoff in this status can accept new messages.
        
        Generally, terminal states cannot accept messages while
        active states can.
        
        Returns:
            bool: True if handoff can accept messages
        """
        return not self.is_terminal()


# Pre-computed sets for O(1) lookup performance
_TERMINAL_STATES: Set[HandoffStatus] = frozenset({
    HandoffStatus.COMPLETED,
    HandoffStatus.FAILED, 
    HandoffStatus.TIMEOUT,
    HandoffStatus.CANCELLED,
    HandoffStatus.REJECTED
})

_ACTIVE_STATES: Set[HandoffStatus] = frozenset({
    HandoffStatus.PENDING,
    HandoffStatus.ACCEPTED,
    HandoffStatus.IN_PROGRESS,
    HandoffStatus.INPUT_REQUIRED
})


@dataclass
class StateTransition:
    """Records a state transition with metadata for audit trail."""
    
    from_status: HandoffStatus
    to_status: HandoffStatus
    timestamp: datetime
    reason: Optional[str] = None
    triggered_by: Optional[str] = None  # agent_id that triggered the transition
    
    def __post_init__(self) -> None:
        """Ensure timestamp is set if not provided."""
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


# Valid state transitions mapping - defines the allowed handoff state machine
VALID_TRANSITIONS: Dict[HandoffStatus, Set[HandoffStatus]] = {
    HandoffStatus.PENDING: frozenset({
        HandoffStatus.ACCEPTED,
        HandoffStatus.REJECTED, 
        HandoffStatus.CANCELLED
    }),
    HandoffStatus.ACCEPTED: frozenset({
        HandoffStatus.IN_PROGRESS,
        HandoffStatus.CANCELLED
    }),
    HandoffStatus.IN_PROGRESS: frozenset({
        HandoffStatus.INPUT_REQUIRED,
        HandoffStatus.COMPLETED,
        HandoffStatus.FAILED,
        HandoffStatus.CANCELLED
    }),
    HandoffStatus.INPUT_REQUIRED: frozenset({
        HandoffStatus.IN_PROGRESS,
        HandoffStatus.COMPLETED,
        HandoffStatus.FAILED,
        HandoffStatus.CANCELLED
    })
    # Terminal states have no valid transitions (not included in mapping)
}


def validate_transition(from_status: HandoffStatus, to_status: HandoffStatus) -> bool:
    """Validate whether a state transition is allowed.
    
    Args:
        from_status: Current handoff status
        to_status: Desired target status
        
    Returns:
        bool: True if transition is valid according to state machine rules
        
    Examples:
        >>> validate_transition(HandoffStatus.PENDING, HandoffStatus.ACCEPTED)
        True
        >>> validate_transition(HandoffStatus.COMPLETED, HandoffStatus.IN_PROGRESS) 
        False
    """
    # Self-transitions are not allowed
    if from_status == to_status:
        return False
        
    # Check if transition is in valid transitions mapping
    valid_targets = VALID_TRANSITIONS.get(from_status, frozenset())
    return to_status in valid_targets


@dataclass 
class Handoff:
    """Represents a handoff between agents with transition history.
    
    Maintains backward compatibility while adding transition tracking
    for audit and debugging purposes.
    """
    
    id: str
    source_agent: str
    target_agent: str
    status: HandoffStatus
    transitions: List[StateTransition] = field(default_factory=list)
    
    def add_transition(self, to_status: HandoffStatus, reason: Optional[str] = None, 
                      triggered_by: Optional[str] = None) -> bool:
        """Add a state transition if valid.
        
        Args:
            to_status: Target status to transition to
            reason: Optional reason for the transition
            triggered_by: Optional agent ID that triggered transition
            
        Returns:
            bool: True if transition was added successfully
        """
        if not validate_transition(self.status, to_status):
            return False
            
        transition = StateTransition(
            from_status=self.status,
            to_status=to_status,
            timestamp=datetime.utcnow(),
            reason=reason,
            triggered_by=triggered_by
        )
        
        self.transitions.append(transition)
        self.status = to_status
        return True


@dataclass
class HandoffResult:
    """Result of a handoff operation.

    Contains the handoff details and any result data from the
    target agent's execution.
    """

    id: str
    status: HandoffStatus
    source_agent: str
    target_agent: str
    result_trace_id: Optional[str] = None
    error: Optional[str] = None
    created_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None


class HandoffStorage:
    """Abstract storage backend for handoff persistence.

    Implementations can store handoffs in memory, files, or distributed storage.
    Default implementation uses in-memory storage.
    """

    def __init__(self) -> None:
        """Initialize storage."""
        self._handoffs: Dict[str, Handoff] = {}

    def save(self, handoff: Handoff) -> None:
        """Save a handoff to storage."""
        self._handoffs[handoff.id] = handoff

    def get(self, handoff_id: str) -> Optional[Handoff]:
        """Retrieve a handoff by ID."""
        return self._handoffs.get(handoff_id)

    def list_pending(self, target_agent: Optional[str] = None) -> List[Handoff]:
        """List pending handoffs, optionally filtered by target agent."""
        pending = [h for h in self._handoffs.values() if h.status == HandoffStatus.PENDING]
        if target_agent:
            pending = [h for h in pending if h.target_agent == target_agent]
        return pending


class HandoffManager:
    """Manages creation and tracking of outgoing handoffs.

    Used by agents to create handoffs to other agents and track their status.
    """

    def __init__(
        self,
        project_id: str,
        agent_id: str,
        storage: Optional[HandoffStorage] = None,
    ) -> None:
        """Initialize the handoff manager.

        Args:
            project_id: Project identifier
            agent_id: ID of the agent creating handoffs
            storage: Optional storage backend (defaults to in-memory)
        """
        self.project_id = project_id
        self.agent_id = agent_id
        self._storage = storage or HandoffStorage()
        self._counter = 0

    def create_handoff(
        self,
        to_agent: str,
        capability_id: str,
        task: str,
        inputs: Dict[str, Any],
        **kwargs: Any,
    ) -> HandoffResult:
        """Create a new handoff to another agent.

        Args:
            to_agent: Target agent ID
            capability_id: Capability being requested
            task: Description of the task
            inputs: Input parameters for the task
            **kwargs: Additional handoff attributes

        Returns:
            HandoffResult with the created handoff details
        """
        import uuid

        handoff_id = f"handoff-{uuid.uuid4().hex[:8]}"
        handoff = Handoff(
            id=handoff_id,
            source_agent=self.agent_id,
            target_agent=to_agent,
            status=HandoffStatus.PENDING,
        )

        self._storage.save(handoff)

        return HandoffResult(
            id=handoff_id,
            status=HandoffStatus.PENDING,
            source_agent=self.agent_id,
            target_agent=to_agent,
            created_at=datetime.utcnow(),
        )

    def get_handoff_status(self, handoff_id: str) -> HandoffResult:
        """Get the current status of a handoff.

        Args:
            handoff_id: Handoff identifier

        Returns:
            HandoffResult with current status

        Raises:
            ValueError: If handoff not found
        """
        handoff = self._storage.get(handoff_id)
        if not handoff:
            raise ValueError(f"Handoff not found: {handoff_id}")

        return HandoffResult(
            id=handoff.id,
            status=handoff.status,
            source_agent=handoff.source_agent,
            target_agent=handoff.target_agent,
        )

    def await_result(self, handoff_id: str, timeout_ms: int = 30000) -> HandoffResult:
        """Wait for a handoff to complete.

        Args:
            handoff_id: Handoff identifier
            timeout_ms: Maximum time to wait in milliseconds

        Returns:
            HandoffResult with final status

        Raises:
            TimeoutError: If handoff doesn't complete within timeout
        """
        # Simple implementation - in production would poll/wait
        return self.get_handoff_status(handoff_id)

    def cancel_handoff(self, handoff_id: str) -> bool:
        """Cancel a pending handoff.

        Args:
            handoff_id: Handoff identifier

        Returns:
            True if cancelled successfully
        """
        handoff = self._storage.get(handoff_id)
        if not handoff:
            return False

        return handoff.add_transition(HandoffStatus.CANCELLED, reason="Cancelled by sender")


class HandoffReceiver:
    """Handles incoming handoffs for an agent.

    Used by agents to receive and process handoffs from other agents.
    """

    def __init__(
        self,
        agent_id: str,
        storage: Optional[HandoffStorage] = None,
    ) -> None:
        """Initialize the handoff receiver.

        Args:
            agent_id: ID of the receiving agent
            storage: Optional storage backend (defaults to in-memory)
        """
        self.agent_id = agent_id
        self._storage = storage or HandoffStorage()

    def poll_handoffs(self, project_id: Optional[str] = None) -> List[Handoff]:
        """Poll for pending handoffs for this agent.

        Args:
            project_id: Optional project filter

        Returns:
            List of pending handoffs for this agent
        """
        return self._storage.list_pending(target_agent=self.agent_id)

    def accept(self, handoff_id: str) -> bool:
        """Accept an incoming handoff.

        Args:
            handoff_id: Handoff identifier

        Returns:
            True if accepted successfully
        """
        handoff = self._storage.get(handoff_id)
        if not handoff:
            return False

        return handoff.add_transition(
            HandoffStatus.ACCEPTED,
            reason="Accepted",
            triggered_by=self.agent_id,
        )

    def complete(self, handoff_id: str, result_trace_id: str) -> bool:
        """Complete a handoff with results.

        Args:
            handoff_id: Handoff identifier
            result_trace_id: Trace ID of the completed work

        Returns:
            True if completed successfully
        """
        handoff = self._storage.get(handoff_id)
        if not handoff:
            return False

        # May need to transition through IN_PROGRESS first
        if handoff.status == HandoffStatus.ACCEPTED:
            handoff.add_transition(HandoffStatus.IN_PROGRESS, triggered_by=self.agent_id)

        return handoff.add_transition(
            HandoffStatus.COMPLETED,
            reason=f"Completed with trace: {result_trace_id}",
            triggered_by=self.agent_id,
        )

    def fail(self, handoff_id: str, reason: str) -> bool:
        """Fail a handoff with an error reason.

        Args:
            handoff_id: Handoff identifier
            reason: Description of why the handoff failed

        Returns:
            True if failure recorded successfully
        """
        handoff = self._storage.get(handoff_id)
        if not handoff:
            return False

        return handoff.add_transition(
            HandoffStatus.FAILED,
            reason=reason,
            triggered_by=self.agent_id,
        )
