# Phase 1: Pipeline Contract Governance — Document Corrections & Security Hardening

## Context

REQ_PIPELINE_CONTRACT_GOVERNANCE.md consolidates 5 design documents into 32 requirements + 5 NFRs. After 4 review rounds (R1-R4), 33 suggestions were accepted and appended to the review log. Codebase exploration revealed that the document contains several factual inaccuracies about implementation status that, if left uncorrected, will mislead implementers. This Phase 1 corrects the document to match reality and applies one high-value security hardening fix.

**Key discovery**: The code is significantly more complete than the document claims. All 7 contract domains have full lifecycle wiring (preflight/runtime/postexec), but the Implementation Status Matrix shows 5 of them as "D" (domain logic only). The pipeline checker has 8 checks, not the 7 claimed in REQ-PCG-020 or the 6 claimed in REQ-CDP-011. Gate 3 exists in startd8-sdk (context_seed_handlers.py) but has no status marker in the requirements.

## Scope

**In scope (Phase 1):**
- Apply all 33 accepted review suggestions to the requirements document body
- Correct Implementation Status Matrix to match actual code
- Reconcile Gate 1 check count (8 actual, 7 documented, 6 in companion doc)
- Add Gate 3 implementation status
- Harden eval() sandbox with AST allowlist (NFR-PCG-004)
- Update companion document REQ-CDP-011 for consistency

**Deferred to Phase 2:**
- BoundaryValidator file-based handoff hydration adapter (R3-S2 — cross-repo design needed)
- Schema versioning strategy (R1-S10 — needs design discussion)
- Gap exclusion mechanism (R1-S9 — needs UX design for `excluded_gaps`)
- Regression baseline definition (R3-S7 — needs CI infrastructure decisions)
- E2E pipeline orchestration scripts (REQ-CDP-001 through -012)
- Domain 3-7 promotion to "Y" validation (confirming lifecycle integration works end-to-end)

## Tasks

### Task 1: Apply Document Corrections to REQ-PCG Body

**File**: `docs/design/requirements/REQ_PIPELINE_CONTRACT_GOVERNANCE.md`

Apply the following corrections inline to the requirements body (grouped by type):

#### 1a. Factual Fixes
- **R1-S1 + R4-S1**: Update REQ-PCG-020 Gate 1 table from 7 to **8 checks**. Add row 8: "Artifact inventory (Mottainai provenance v2 cross-check)" as non-blocking. Fix row 5 (Gap parity) to check against declared gaps in artifact-manifest.yaml, not extracted features (Gate 1 runs before PARSE).
- **R1-S2**: Add to REQ-PCG-022: `**Status:** Partial — Gate 3 validation exists in startd8-sdk (context_seed_handlers.py) for multi-file split completeness; end-to-end finalize verification not yet wired as standalone gate`
- **R1-S4**: Fix "byppassable" → "bypassable". Add: "Bypass MUST be via `--skip-preflight` flag, consistent with `--skip-polish`, `--skip-fix`, `--skip-validate` in the companion pipeline."
- **R3-S3**: Change REQ-PCG-003 through REQ-PCG-007 status from "Implemented" to "Partial — domain logic implemented (N tests), lifecycle wiring implemented but end-to-end integration pending validation"
- **R4-S7**: Change artifact-manifest.yaml references to `{project}-artifact-manifest.yaml` to match REQ-CDP-007
- **R2-S8**: Update pipeline diagram to show Stage 2a (ANALYZE) and Stage 2b (INIT) as sub-steps
- **R2-S5**: Add note to cross-cutting section: "Malformed run-provenance.json MUST produce a warning (not silently ignored) to align with REQ-PCG-023 Fail Loud principle"

#### 1b. Status & Traceability
- **R1-S7**: Add "Promotion Criteria" subsection below Implementation Status Matrix defining what "D → Y" requires (end-to-end integration test per domain × lifecycle cell)
- **R3-S9**: Add requirement-to-domain traceability table mapping REQ-PCG-008/009/010 to all 7 domain × lifecycle cells
- **R3-S5 + R2-S9**: Add `Source:` field to Part 2 requirements (REQ-PCG-017 through REQ-PCG-027) citing specific source document sections

#### 1c. Precision & Testability
- **R1-S5 + R3-S4**: Add test counts to verification plan for REQ-PCG-008 (26 tests), REQ-PCG-009 (30 tests), REQ-PCG-010 (30 tests), REQ-PCG-022 (Gate 3: partial, see context_seed_handlers.py)
- **R1-S8**: Annotate onboarding metadata fields in REQ-PCG-024 as REQUIRED (core fields) or OPTIONAL (enrichment fields)
- **R3-S1**: Define complexity score reasonableness in REQ-PCG-021/026: "At least 2 of 7 dimensions MUST differ by ≥10 points; standard deviation across dimensions MUST exceed 5"
- **R3-S10**: Replace qualitative acceptance criteria in REQ-PCG-006 and REQ-PCG-013 with specific event names and severity values
- **R4-S8**: Clarify REQ-PCG-022 checksums verify integrity (hash files on disk), not reproducibility
- **R4-S3**: Update REQ-PCG-021 Gate 2 Q2 to: "TRANSFORM routing matches complexity score OR explicit force_route override is documented"

#### 1d. Architecture Clarifications
- **R1-S3**: Add REQ-PCG-033 (explicit non-goal): "Checkpoint-based pipeline resumption is an explicit non-goal for the core pipeline. See Extension Concern 10 (Checkpoint Recovery). Operators MUST re-run from Stage 0 on mid-pipeline failure; NFR-CDP-002 (idempotent re-runs) mitigates wasted work."
- **R4-S2**: Add clarification to REQ-PCG-025 and NFR-PCG-002 distinguishing degradable Propagation Contracts (ContextCore) from mandatory A2A Contracts (startd8-sdk Pydantic models always active)
- **R4-S6**: Add to REQ-PCG-013: "When defaults are injected, the injecting phase MUST stamp provenance via `PropagationTracker.stamp()` with the current phase as `origin_phase`"
- **R4-S9**: Add to REQ-PCG-014: "Stages 0 (CREATE) and 1 (POLISH) MUST seed the `_cc_propagation` dict with initial project context provenance"
- **R2-S1**: Clarify Gate 3 relationship to a2a-diagnose: "Gate 3 runs Q3 of the Three Questions diagnostic against contractor outputs"
- **R2-S3**: Define complete handoff artifact set consumed by stages 5-7 (3 core files + glob pattern for optional enrichment)
- **R2-S2**: Add note about E2E runtime environment: "Deferred to Phase 2 — containerized or documented venv setup"

#### 1e. Security
- **R1-S6 + R3-S6**: Expand NFR-PCG-004 with concrete sandbox constraints (see Task 3 for implementation)

#### 1f. New Requirements
- **R2-S4**: Add REQ-PCG-034: Generic failure injection mechanism for all contract types (not just checksums)
- **R1-S9**: Add to REQ-PCG-026: "Gaps MAY be excluded via `excluded_gaps` in artifact-manifest.yaml with mandatory `reason` field. Excluded gaps MUST appear in the audit trail but MUST NOT cause parse coverage failure."
- **R1-S10**: Add REQ-PCG-035: Schema versioning strategy placeholder — "Deferred to Phase 2. MUST support at minimum N and N-1 versions during rollout."

### Task 2: Update Implementation Status Matrix

**File**: `docs/design/requirements/REQ_PIPELINE_CONTRACT_GOVERNANCE.md`

Update the matrix based on actual code exploration:

| Domain | Pre-Flight | Runtime | Post-Exec | Observability | Regression |
|--------|:----------:|:-------:|:---------:|:-------------:|:----------:|
| Context Propagation | Y | Y | Y | Y | Y |
| Schema Compatibility | Y | Y | Y | Y | Y |
| Semantic Conventions | Y* | Y* | Y* | Y* | Y* |
| Causal Ordering | Y* | Y* | Y* | Y* | Y* |
| Capability Propagation | Y* | Y* | Y* | Y* | Y* |
| SLO Budget Tracking | Y* | Y* | Y* | Y* | Y* |
| Data Lineage | Y* | Y* | Y* | Y* | Y* |

`Y*` = Domain logic + lifecycle wiring implemented; end-to-end integration pending validation (Phase 2).

Update A2A governance table Gate 1 check count from 34 to current test count. Add Gate 3 row.

### Task 3: Harden eval() Sandbox (NFR-PCG-004)

**Files**:
- `src/contextcore/contracts/propagation/tracker.py` (line 264 — the eval() call)
- `src/contextcore/contracts/propagation/schema.py` (add validation to PropagationChainSpec)
- New: `tests/unit/contextcore/contracts/propagation/test_expression_safety.py`

**Implementation**:

1. Add `_validate_expression(expr: str)` to `schema.py` that:
   - Parses the expression with `ast.parse(expr, mode="eval")`
   - Walks the AST and rejects prohibited node types: `Import`, `ImportFrom`, `Call` (except to allowlisted functions like `len`, `str`, `int`, `float`, `bool`, `isinstance`), `Attribute` access beyond one level
   - Enforces max expression length (500 chars)
   - Returns a `ValidationResult` with pass/fail and reason

2. Add `@field_validator("verification")` to `PropagationChainSpec` in `schema.py` that calls `_validate_expression()` at parse time — malicious expressions rejected before they ever reach eval()

3. Add timeout wrapper (1 second) around the eval() call in `tracker.py:264`

4. Tests (8-10 tests):
   - Safe expressions pass validation (`source == dest`, `len(context.get("field", "")) > 0`)
   - `__import__("os")` rejected at parse time
   - `os.system("rm -rf /")` rejected at parse time
   - Nested `getattr` beyond one level rejected
   - Expression exceeding 500 chars rejected
   - Long-running expression times out

### Task 4: Update Companion Document REQ-CDP-011

**File**: `docs/design/requirements/REQ_CAPABILITY_DELIVERY_PIPELINE.md`

- Update Gate 1 check count from "6 structural integrity checks" to "8 integrity checks" with updated list
- Ensure filename pattern consistency (`{project}-artifact-manifest.yaml`)

### Task 5: Update Review Log Metadata

**File**: `docs/design/requirements/REQ_PIPELINE_CONTRACT_GOVERNANCE.md`

After applying all suggestions:
- Move applied suggestion IDs from Appendix C (Incoming) to Appendix A (Applied) with implementation notes and date
- Update "Areas Substantially Addressed" to reflect all areas now addressed
- Update "Areas Needing Further Review" to "All areas substantially addressed"

## Verification

1. **Document consistency**: Grep for "6 checks", "7 checks" across both requirements docs — should only find "8 checks"
2. **eval() safety tests**: `python3 -m pytest tests/unit/contextcore/contracts/propagation/test_expression_safety.py -v`
3. **Existing tests pass**: `python3 -m pytest tests/unit/contextcore/contracts/ -v` (all 477+ tests still pass)
4. **No regressions in propagation**: `python3 -m pytest tests/unit/contextcore/contracts/propagation/ -v` (93 tests pass)

## Dependencies

```
Task 1 (doc corrections) ← no deps, do first
Task 2 (matrix update)   ← depends on Task 1 (same file)
Task 3 (eval hardening)  ← independent, can parallel with Task 1
Task 4 (companion doc)   ← depends on Task 1 (gate count reconciliation)
Task 5 (review log)      ← depends on Task 1 (must apply before moving to Applied)
```

## Estimated Scope

- ~200 lines of document edits across Tasks 1, 2, 4, 5
- ~120 lines of new Python code (Task 3: expression validator + tests)
- 0 cross-repo dependencies (eval hardening is ContextCore-only)

---

## Appendix: Iterative Review Log (Applied / Rejected Suggestions)

This appendix is intentionally **append-only**. New reviewers (human or model) should add suggestions to Appendix C, and then once validated, record the final disposition in Appendix A (applied) or Appendix B (rejected with rationale).

### Reviewer Instructions (for humans + models)

- **Before suggesting changes**: Scan Appendix A and Appendix B first. Do **not** re-suggest items already applied or explicitly rejected.
- **When proposing changes**: Append them to Appendix C using a unique suggestion ID (`R{round}-S{n}`).
- **When endorsing prior suggestions**: If you agree with an untriaged suggestion from a prior round, list it in an **Endorsements** section after your suggestion table. This builds consensus signal — suggestions endorsed by multiple reviewers should be prioritized during triage.
- **When validating**: For each suggestion, append a row to Appendix A (if applied) or Appendix B (if rejected) referencing the suggestion ID. Endorsement counts inform priority but do not auto-apply suggestions.
- **If rejecting**: Record **why** (specific rationale) so future models don't re-propose the same idea.

### Areas Substantially Addressed

- **architecture**: 6 suggestions applied (R7-S5, R8-S5, R1-S3, R1-S10, R3-S1, R7-S1)
- **clarity**: 4 suggestions applied (R7-S10, R3-S2, R4-S4, R4-S5)
- **completeness**: 9 suggestions applied (R7-S2, R7-S6, R7-S8, R8-S6, R1-S2, R2-S1, R2-S5, R2-S8, R6-S9)
- **maintainability**: 4 suggestions applied (R8-S3, R3-S5, R4-S6, R4-S7)
- **scalability**: 5 suggestions applied (R2-S6, R5-S1, R5-S3, R5-S10, R6-S1)
- **security**: 11 suggestions applied (R7-S1, R7-S3, R7-S9, R8-S1, R1-S8, R3-S10, R5-S5, R5-S9, R6-S2, R6-S5, R6-S7)
- **testability**: 7 suggestions applied (R7-S4, R4-S1, R4-S3, R5-S6, R5-S7, R5-S8, R6-S4)
- **unknown**: 4 suggestions applied (R1-S1, R1-S5, R3-S3, R3-S6)

### Areas Needing Further Review

All areas have reached the substantially addressed threshold.

### Appendix A: Applied Suggestions

| ID | Suggestion | Source | Implementation / Validation Notes | Date |
|----|------------|--------|----------------------------------|------|
| R1-S1 | The plan must address the accepted R5-S4 E2E integration test or explicitly defer it with justification. | claude-4 (claude-opus-4-6) | Appendix A traceability is a core governance principle of this document. If R5-S4 is marked as applied but has no corresponding task, the plan is internally inconsistent. Adding a task or explicit deferral note is low-cost and high-value for auditability. | 2026-02-19 19:09:57 UTC |
| R1-S2 | Eleven accepted suggestions from Appendix A have no corresponding plan task or deferral entry, creating a traceability gap. | claude-4 (claude-opus-4-6) | This is the most critical finding. The plan's credibility depends on 100% coverage of accepted suggestions — either as tasks or as explicitly deferred items with rationale. Leaving 11 suggestions unaccounted for means the plan will produce a document that claims to have applied changes it hasn't. Each must be mapped to a task or moved to Deferred with justification. | 2026-02-19 19:09:57 UTC |
| R1-S3 | Task 3 hardens eval() but conflicts with accepted R6-S1 which mandates CEL replacement; the plan should acknowledge this as interim work. | claude-4 (claude-opus-4-6) | Without acknowledging that eval hardening is a bridge to CEL, implementers may over-invest in the AST sandbox infrastructure. A simple note in Task 3 and a CEL migration item in the Deferred section resolves this at negligible cost. | 2026-02-19 19:09:57 UTC |
| R1-S4 | Upgrading 5 domains from 'D' to 'Y*' based on code reading alone needs a verification methodology or explicit caveat. | claude-4 (claude-opus-4-6) | The plan correctly identifies that the document understates implementation completeness, but upgrading status markers without test execution risks the same false confidence it criticizes. The Y* notation helps but a verification sub-task (even deferred) strengthens the claim. | 2026-02-19 19:09:57 UTC |
| R1-S5 | Gate 1 check #8 (artifact inventory) needs to be traced to a specific requirement to maintain the document's traceability principles. | claude-4 (claude-opus-4-6) | Adding an undocumented gate check without a requirement mapping violates the very traceability the document enforces. Either mapping to an existing requirement or creating REQ-PCG-036 is a small addition that maintains document integrity. | 2026-02-19 19:09:57 UTC |
| R1-S6 | Task 3's 1-second eval timeout must specify the failure mode (status, error message, retry behavior) to satisfy idempotency requirements. | claude-4 (claude-opus-4-6) | A timeout without defined failure semantics is incomplete. For NFR-PCG-005 idempotency, the behavior on timeout must be deterministic and documented. Specifying BROKEN chain status and whether the timeout is configurable is essential for implementers. | 2026-02-19 19:09:57 UTC |
| R1-S7 | Items listed as deferred in the plan but marked as 'Applied' in Appendix A should be marked as 'Partial' to avoid audit confusion. | claude-4 (claude-opus-4-6) | The distinction between fully applied and partially applied suggestions is critical for auditors. Without explicit 'Partial' annotations, there's a false impression of completeness. This is a documentation fix with high traceability value. | 2026-02-19 19:09:57 UTC |
| R1-S8 | Task 3's AST allowlist needs to distinguish between dangerous arbitrary calls and safe method calls on primitive types. | claude-4 (claude-opus-4-6) | The current allowlist rules would block legitimate expressions like `context.get('x', '').strip()` while trying to block dangerous calls. Refining the distinction between safe method calls and arbitrary callables prevents the sandbox from being either too restrictive for real use or requiring constant expansion. | 2026-02-19 19:09:57 UTC |
| R1-S9 | Complexity score thresholds in Task 1c should be noted as initial values pending calibration against real data. | claude-4 (claude-opus-4-6) | The thresholds appear arbitrary without calibration data. Adding a note that these are initial values subject to Phase 2 calibration is trivial and prevents implementers from treating arbitrary numbers as validated requirements. | 2026-02-19 19:09:57 UTC |
| R1-S10 | The '0 cross-repo dependencies' claim should be scoped more precisely to avoid misleading stakeholders about Phase 2 effort. | claude-4 (claude-opus-4-6) | While technically true for Phase 1 code changes, the claim obscures real cross-repo coordination needs for deferred items. A precise scoping statement prevents underestimation of total effort and is a simple wording fix. | 2026-02-19 19:09:57 UTC |
| R2-S1 | Add a task to resolve the conflict between _cc_propagation injection and extra='forbid' in Pydantic models. | gemini-3 (gemini-3-pro-preview) | This is the R5-S5 suggestion that R1-S2 also flags as missing. Injecting provenance metadata into strict Pydantic models will cause runtime validation failures at the handoff boundary. This is a real integration bug that must be addressed or explicitly deferred. | 2026-02-19 19:09:57 UTC |
| R2-S3 | Add a task to implement fail-closed behavior for safety-critical contracts per R6-S5. | claude-4 (claude-opus-4-6) | R6-S5 is an accepted suggestion (endorsed by 1 reviewer) that graceful degradation is unacceptable for safety-critical checks like PII scrubbing. The plan's NFR-PCG-002 allows degradation but doesn't distinguish between degradable and safety-critical contracts. This is a real safety gap. | 2026-02-19 19:09:57 UTC |
| R2-S4 | Add a Gate 1 check for consistency between inline _cc_propagation and run-provenance.json. | gemini-3 (gemini-3-pro-preview) | This implements the accepted R6-S3 suggestion. Inline and external provenance can drift, and Gate 1 is the natural enforcement point. Adding this check is consistent with the plan's goal of reconciling gate checks. | 2026-02-19 19:09:57 UTC |
| R2-S5 | Add a task to define provenance re-stamping rules for Stage 1.5 (Auto-Remedy). | claude-4 (claude-opus-4-6) | R5-S9 correctly identifies that auto-remedy invalidates provenance hashes. Without defined re-stamping rules, the provenance chain breaks silently at this boundary. This can be a requirements addition even if implementation is deferred. | 2026-02-19 19:09:57 UTC |
| R2-S6 | Add NFR for contract complexity limits (chain count, expression depth) to prevent DoS via complex YAML. | gemini-3 (gemini-3-pro-preview) | R5-S8 is an accepted suggestion. Task 3 adds an eval timeout but doesn't limit the contract structure itself. A contract with 1000 chains would still impose unbounded validation overhead. Adding structural limits is a reasonable hardening measure. | 2026-02-19 19:09:57 UTC |
| R2-S7 | Clarify execution time vs wall time for SLO budget tracking in Task 1c. | gemini-3 (gemini-3-pro-preview) | R6-S4 correctly identifies that human-in-the-loop stages break wall-clock budgets. Without this clarification, SLO budget tracking will produce false positives on any pipeline with manual review stages. This is a precision fix for an existing task. | 2026-02-19 19:09:57 UTC |
| R2-S8 | Add a task to define deterministic resolution for conflicting severity levels across chains. | gemini-3 (gemini-3-pro-preview) | R5-S3 is an accepted suggestion. When a field is BLOCKING in one chain and ADVISORY in another, the system must have a deterministic resolution rule. Without one, validation results depend on chain evaluation order, violating determinism requirements. | 2026-02-19 19:09:57 UTC |
| R3-S1 | Add an explicit contract domain composition architecture describing how 7 domains are loaded, ordered, and composed into a single enforcement pipeline. | claude-4 (claude-opus-4-6) | The defense-in-depth claim requires a defined composition mechanism. Without specifying discovery, ordering, and result merging for domain validators, the architecture leaves the most critical integration pattern unspecified. This is a genuine architectural gap. | 2026-02-19 19:28:23 UTC |
| R3-S2 | Define a glossary of key terms (contract, gate, check, validation, enforcement, verification) used inconsistently across the document. | claude-4 (claude-opus-4-6) | Terminological ambiguity was a root cause of the gate check count discrepancies already corrected. A glossary prevents future drift and is low-cost, high-value for a document of this complexity. | 2026-02-19 19:28:23 UTC |
| R3-S3 | Restructure the NFR section to distinguish pipeline vs. contract-system NFRs and assign explicit IDs to implicit NFRs scattered through the document. | claude-4 (claude-opus-4-6) | Several accepted suggestions (R6-S6, R7-S2, R7-S9, R5-S2) introduced NFR-like constraints that lack formal IDs and cannot be traced in the Verification Plan. Elevating them to proper NFR status is essential for traceability. | 2026-02-19 19:28:23 UTC |
| R3-S5 | Extract the 33+ accepted review suggestions into a categorized Document Amendment Register with semantic sub-tables. | claude-4 (claude-opus-4-6) | The append-only log of amendments is already unwieldy and will become unsearchable. Categorizing by amendment type (corrections, new requirements, status updates, traceability, security) is a low-cost improvement that directly supports maintainability. | 2026-02-19 19:28:23 UTC |
| R3-S6 | Add a machine-readable requirements index (YAML/JSON) for automated traceability checking in CI. | claude-4 (claude-opus-4-6) | With 32+ REQ IDs and 5+ NFR IDs, manual traceability maintenance has already proven error-prone (the D→Y* correction was only found via manual code exploration). A machine-readable index enables automated staleness detection and is endorsed by the maintainability principle. | 2026-02-19 19:28:23 UTC |
| R3-S10 | Define a threat model for the contract governance system covering supply chain attacks, progressive adoption window risks, TOCTOU attacks, and provenance forgery. | claude-4 (claude-opus-4-6) | For a governance system that enforces integrity, a holistic threat model is essential. The progressive adoption window (advisory→blocking) creates a real attack surface. Individual security fixes (eval hardening, checksums) without a threat model leave gaps that attackers can chain together. This has 1 endorsement (R6-S1) supporting the security hardening direction. | 2026-02-19 19:28:23 UTC |
| R4-S1 | Require golden and poison contract YAML test fixtures for each contract domain | claude-4 (claude-opus-4-6) | Without standardized test fixtures, unit tests may use trivial single-field contracts that don't exercise real multi-domain interactions. This is a concrete, low-cost improvement that significantly improves test quality assurance. | 2026-02-19 19:49:46 UTC |
| R4-S3 | Specify a dry-run contract testing mode that validates contracts against synthetic context without executing pipeline stages | claude-4 (claude-opus-4-6) | Essential for the progressive adoption path (REQ-PCG-016 'declaration only' stage) and for CI validation of contract changes. Without this, operators cannot validate contract YAML without running the full pipeline. | 2026-02-19 19:49:46 UTC |
| R4-S4 | Define the contract governance posture for ASSESS phase's LLM-based scoring vs idempotent gate requirements | claude-4 (claude-opus-4-6) | The tension between LLM-based scoring (inherently non-deterministic) and NFR-PCG-005 (idempotent gate execution) is a real architectural conflict that must be resolved. Accepted R6-S6 requires ASSESS determinism but doesn't specify the mechanism. | 2026-02-19 19:49:46 UTC |
| R4-S5 | Specify which provenance source is authoritative when run-provenance.json and _cc_propagation disagree | claude-4 (claude-opus-4-6) | Accepted R6-S3 mandates reconciliation but doesn't specify conflict resolution. Without an authoritative source designation, Gate 1 failures are unactionable. The inline provenance traveling with data is the natural authoritative source. | 2026-02-19 19:49:46 UTC |
| R4-S6 | Require all contract domain validators to implement a common DomainValidator interface/protocol | claude-4 (claude-opus-4-6) | With 7 domains and growing, a common interface prevents the aggregation layer from requiring per-domain special-casing. This is a standard maintainability practice that becomes critical at the current domain count. | 2026-02-19 19:49:46 UTC |
| R4-S7 | Define a contract YAML modularity strategy allowing per-domain contract files that compose into a pipeline-level contract | claude-4 (claude-opus-4-6) | With 7 domains + 9 extensions, a single contract YAML file becomes unwieldy. Per-domain files with directory-based loading directly supports progressive adoption (REQ-PCG-016) where different domains are at different stages. | 2026-02-19 19:49:46 UTC |
| R5-S1 | Add requirement for pipeline-scoped artifact namespacing using run-scoped paths to prevent cross-run interference | claude-4 (claude-opus-4-6) | Endorsed by 1 reviewer. Critical severity is justified: without run-scoped artifact paths, concurrent pipeline runs for the same project will produce checksum interference. This is a fundamental addressing model issue that blocks horizontal scaling. | 2026-02-19 20:25:47 UTC |
| R5-S3 | Add requirement for multi-file contract YAML composition to support multi-team domain scaling | claude-4 (claude-opus-4-6) | With 7 core domains + 9 extensions, a single monolithic contract YAML is architecturally insufficient. Multi-file composition with per-domain files and merge-conflict-free ownership is a real scaling need. The proposed directory-based loading with conflict detection is well-specified. | 2026-02-19 20:25:47 UTC |
| R5-S5 | Prohibit f-strings and str.format() in verification expressions to prevent sensitive value exfiltration | claude-4 (claude-opus-4-6) | Endorsed by 1 reviewer. This is a concrete second-order interaction between the Task 3 AST allowlist and the accepted R8-S3 sensitive field protection. Adding JoinedStr and FormattedValue to prohibited AST nodes is low-cost and closes a real exfiltration vector. | 2026-02-19 20:25:47 UTC |
| R5-S6 | Add property-based testing requirement for contract validation compositional correctness across domain combinations | claude-4 (claude-opus-4-6) | With 7 domains × 3 severity levels × 3 lifecycle stages, the combinatorial state space is too large for manual test design. Property-based testing for domain independence, severity monotonicity, and aggregation correctness directly validates the accepted R7-S3/R9-S3 aggregation semantics. | 2026-02-19 20:25:47 UTC |
| R5-S7 | Require a dry-run validation mode that reports results without mutating context or emitting OTel events | claude-4 (claude-opus-4-6) | Essential for the REQ-PCG-016 'declaration only' progressive adoption stage and for debugging. Dry-run mode enables operators to preview validation outcomes safely, which directly supports adoption and testability. | 2026-02-19 20:25:47 UTC |
| R5-S8 | Add fault-injection testing for pathological contract topologies (circular chains, self-referencing waypoints) | claude-4 (claude-opus-4-6) | Malformed contract graphs could cause infinite loops or stack overflows. Testing that the loader rejects pathological topologies at parse time (not at runtime) is important for robustness. This complements the accepted R2-S4 generic failure injection by testing the contract system's own resilience. | 2026-02-19 20:25:47 UTC |
| R5-S9 | Enforce read-only access to _cc_propagation dict via MappingProxyType for pipeline handlers | claude-4 (claude-opus-4-6) | Provenance is the audit backbone. Convention-based protection ('do not touch') is insufficient when provenance integrity underpins Gate 3 and the entire audit chain. Mechanical enforcement via a read-only view is low-cost and prevents both accidental and malicious provenance tampering. | 2026-02-19 20:25:47 UTC |
| R5-S10 | Add cost/token budget propagation semantics now that R4-F3 generalizes BudgetPropagationSpec to multiple budget types | claude-4 (claude-opus-4-6) | The original R4-S4 rejection rationale ('belongs in companion doc') no longer applies because R4-F3 (now accepted) brings cost budgets into the core domain spec. Without propagation semantics for cost/token budgets, R4-F3 is an empty generalization with no behavioral specification. | 2026-02-19 20:25:47 UTC |
| R6-S1 | Implement provenance snapshotting to prevent linear context growth in _cc_propagation for long pipelines | claude-4 (claude-opus-4-6) | Endorsed by 1 reviewer. In long pipelines or loops, unbounded provenance growth will exceed transport limits. A snapshot/offload mechanism with reference hashes is a sound architectural pattern that keeps context size bounded while preserving full lineage reconstructibility. | 2026-02-19 20:25:47 UTC |
| R6-S2 | Require output sanitization for user-derived data in GateResult error messages to prevent log injection | gemini-3 (gemini-3-pro-preview) | Log injection via malicious input in error envelopes is a well-known attack vector. Requiring truncation and escaping of user-derived data in GateResult messages is low-cost and addresses a real security concern, complementing R3-F3's sensitive field protection. | 2026-02-19 20:25:47 UTC |
| R6-S4 | Add automated telemetry contract validator to verify OTel emission compliance against semantic conventions schema | claude-4 (claude-opus-4-6) | REQ-PCG-011 and REQ-PCG-031 define strict schemas for spans/attributes. Without automated verification, implementation drift will silently break dashboards. Capturing emitted spans in-memory and validating against the schema is a sound regression prevention approach. | 2026-02-19 20:25:47 UTC |
| R6-S5 | Implement anti-tamper root of trust verification for contract definition files against a trusted baseline | claude-4 (claude-opus-4-6) | Endorsed by 1 reviewer. REQ-PCG-019's source_checksum check can be circumvented if both the contract and its checksum are modified in the same PR. Verifying the root contract against the main branch baseline in CI is a practical defense against governance bypass that doesn't require complex cryptographic infrastructure. | 2026-02-19 20:25:47 UTC |
| R6-S7 | Explicitly forbid recursive YAML anchors/aliases to prevent Billion Laughs entity expansion attacks | gemini-3 (gemini-3-pro-preview) | YAML entity expansion is a well-known DoS vector. Since contracts are parsed in CI, a malicious contract could DoS build infrastructure. Adding a constraint to reject recursive anchors is low-cost and addresses a concrete attack surface. | 2026-02-19 20:25:47 UTC |
| R6-S9 | Define cleanup contract requirements to ensure atomicity of artifact generation on pipeline abort | gemini-3 (gemini-3-pro-preview) | Partially written artifacts from a mid-pipeline failure can corrupt state and cause false positives in subsequent runs. Given that REQ-PCG-033 explicitly excludes checkpoint recovery (re-run from Stage 0), ensuring clean output state on abort is essential for the idempotent re-run guarantee. | 2026-02-19 20:25:47 UTC |
| R7-S1 | Refine the AST allowlist in Task 3 to permit method calls (.get, .keys, .values, .items) on allowed variables (context/source/dest). | claude-4 (claude-opus-4-6) | This is a critical implementation correctness issue. The current allowlist would reject `context.get('field', '')`, which is the most natural and likely already-used pattern for safe dictionary access in verification expressions. Without this fix, Task 3 will break existing valid expressions. | 2026-02-19 20:45:18 UTC |
| R7-S2 | Specify the resolution for _cc_propagation handling with extra='forbid' before Phase 2 versioning. | claude-4 (claude-opus-4-6) | This is a genuine blocking decision for Phase 1 code. The plan accepted R5-S5 but didn't specify the implementation choice. Whether _cc_propagation is an explicit field or stripped before validation changes the Pydantic model definition and constrains the Phase 2 versioning strategy. | 2026-02-19 20:45:18 UTC |
| R7-S3 | Specify the failure mode when the eval() 1-second timeout fires (BROKEN chain status with timeout reason). | claude-4 (claude-opus-4-6) | A timeout without a defined failure mode is incomplete hardening. The behavioral contract must specify that timeout produces a BROKEN chain status with a specific reason, not a silently caught exception. This is essential for Task 3 completeness. | 2026-02-19 20:45:18 UTC |
| R7-S4 | Add a Phase 1 smoke test that invokes each domain's lifecycle hooks before updating the matrix from D to Y*. | claude-4 (claude-opus-4-6) | The plan proposes promoting 5 domains based on code exploration without running them. The difference between 'code exists' and 'code works' is significant. A minimal smoke test per domain validates the key discovery at negligible cost and prevents false confidence. | 2026-02-19 20:45:18 UTC |
| R7-S5 | Specify the data flow direction for run-provenance.json generation — which artifact is authoritative and how the other is derived. | claude-4 (claude-opus-4-6) | R6-S3 adds a reconciliation check but without knowing the production pathway, reconciliation failures are ambiguous. Specifying whether _cc_propagation is the source of truth and run-provenance.json is derived (or vice versa) is essential for the check to be meaningful. | 2026-02-19 20:45:18 UTC |
| R7-S6 | Address the tension between R3-S1 complexity score bounds and LLM-based ASSESS non-determinism by specifying that Gate 2 checks the stored score. | claude-4 (claude-opus-4-6) | If ASSESS is non-deterministic, the same input could pass Gate 2 on one run and fail on the next, making the concrete score bounds unreliable as a gate check. Clarifying that Gate 2 operates on the stored assessment result resolves the tension cleanly. | 2026-02-19 20:45:18 UTC |
| R7-S8 | Add accepted but unplanned suggestions R5-S9, R9-S10, and R7-S6 to Task 1d for Stage 1.5 provenance and contract enforcement. | claude-4 (claude-opus-4-6) | Accepted suggestions that don't appear in any task are a plan completeness gap. If they're accepted, they must be tracked in a specific task. If they should be deferred, they should be explicitly listed in the deferred section with rationale. | 2026-02-19 20:45:18 UTC |
| R7-S9 | Add a pre-deployment step to scan all existing contract YAML verification expressions against the new AST validator. | claude-4 (claude-opus-4-6) | Deploying the new expression validator without checking existing expressions could break working pipelines. A simple scan-and-validate step before deployment is standard backward-compatibility practice and low cost. | 2026-02-19 20:45:18 UTC |
| R7-S10 | Either formally define Y* status in the matrix legend or keep domains at D until Phase 2 validates them. | claude-4 (claude-opus-4-6) | Introducing an undefined status symbol (Y*) in a formal matrix creates ambiguity about enforcement reliability. The matrix should have a clear legend defining all status codes. This is a straightforward clarity improvement. | 2026-02-19 20:45:18 UTC |
| R8-S1 | Require a unique run_id binding across all handoff artifacts to prevent mixing artifacts from different runs. | gemini-3 (gemini-3-pro-preview) | Checksums ensure file integrity but not session coherence. Mixing artifacts from different runs is a realistic failure mode, especially in shared filesystem environments. A run_id binding is simple to implement and provides strong protection against Frankenstein pipelines. | 2026-02-19 20:45:18 UTC |
| R8-S3 | Add a global --contract-mode={enforce|audit} flag to support shadow mode execution. | claude-4 (claude-opus-4-6) | This directly supports the progressive adoption path in REQ-PCG-016 by allowing teams to test BLOCKING contracts without breaking builds. An audit mode that downgrades BLOCKING to WARNING is a standard pattern for safely rolling out enforcement. This is practical and high-value. | 2026-02-19 20:45:18 UTC |
| R8-S5 | Explicitly forbid defining contract validation logic in startd8-sdk; restrict it to contract definitions (YAML only). | claude-4 (claude-opus-4-6) | This enforces the Dual Declaration pattern from REQ-PCG-015 and prevents bidirectional dependencies between ContextCore and startd8-sdk. Keeping validation logic centralized in ContextCore is essential for the architecture's maintainability. | 2026-02-19 20:45:18 UTC |
| R8-S6 | Require an explicit log/event when ContextCore is missing and validation is skipped during graceful degradation. | claude-4 (claude-opus-4-6) | NFR-PCG-002 allows graceful degradation, but silent degradation means operators may not realize the pipeline is running unprotected. A simple ContractValidationSkipped warning is low-cost and prevents a dangerous blind spot. | 2026-02-19 20:45:18 UTC |

### Appendix B: Rejected Suggestions (with Rationale)

| ID | Suggestion | Source | Rejection Rationale | Date |
|----|------------|--------|---------------------|------|
| R2-S2 | Replace Task 3's custom AST validation with simpleeval or CEL integration in Phase 1. | claude-4 (claude-opus-4-6) | While CEL is the accepted long-term direction (R6-S1), replacing eval() entirely in Phase 1 is a larger scope change than the plan intends. The AST allowlist is a valid interim hardening measure that can be implemented quickly. The plan should note this is interim (per R1-S3), but replacing the approach entirely in Phase 1 increases risk and scope. A simpleeval dependency also introduces supply chain considerations. | 2026-02-19 19:09:57 UTC |
| R3-S4 | Add sequence diagrams or pseudocode for three critical handoff points showing data transformation pipelines. | claude-4 (claude-opus-4-6) | The BoundaryValidator file-based handoff hydration adapter is already deferred to Phase 2. Adding pseudocode for the hydration step now would be speculative since the cross-repo design hasn't been completed. The existing requirements adequately describe WHAT is checked; HOW is implementation detail that belongs in Phase 2 design. | 2026-02-19 19:28:23 UTC |
| R3-S7 | Define a document update protocol with section owners, review cadence, and CI-based matrix synchronization. | claude-4 (claude-opus-4-6) | This is a process/governance concern, not an architectural requirement. CODEOWNERS and PR workflows are tooling decisions that belong in the project's contributing guidelines, not in the requirements document itself. The CI validation aspect is already partially covered by R3-S6 (machine-readable index). | 2026-02-19 19:28:23 UTC |
| R3-S8 | Add requirements for contract composition scaling to 15+ domains with lazy loading and parallelism strategies. | claude-4 (claude-opus-4-6) | The current system has 7 domains, and the extension concerns in Part 4 are explicitly future considerations. Designing for 16 domains now is premature optimization. The accepted R7-S2 timeout requirement provides a performance safety net. Scaling architecture should be addressed when domain count actually approaches the threshold, not speculatively. | 2026-02-19 19:28:23 UTC |
| R3-S9 | Specify provenance storage scaling for multi-project/multi-run scenarios including retention, archival, and query patterns. | claude-4 (claude-opus-4-6) | This is an operational concern that extends well beyond the contract governance architecture. The accepted R8-S7 pruning strategy addresses single-run provenance management. Multi-project retention policies, archival to external storage, and cross-run query interfaces are infrastructure decisions that depend on deployment context and belong in operational documentation, not architectural requirements. | 2026-02-19 19:28:23 UTC |
| R4-S2 | Require machine-readable per-clause contract coverage reports from pipeline runs | claude-4 (claude-opus-4-6) | This is a sophisticated observability feature that adds significant implementation complexity. The existing propagation summary with completeness_pct provides adequate coverage visibility for Phase 1. Per-clause coverage can be considered as a future enhancement. | 2026-02-19 19:49:46 UTC |
| R4-S8 | Specify contract validation caching strategy to prevent redundant re-validation across pipeline stages | claude-4 (claude-opus-4-6) | This is a premature optimization. The current pipeline has 7-8 stages with validation that parses YAML — this is not a demonstrated bottleneck. The SHOULD qualifier proposed acknowledges it's optional, and caching adds complexity (invalidation logic). Address when profiling shows it's needed. | 2026-02-19 19:49:46 UTC |
| R4-S9 | Define horizontal scaling semantics for concurrent pipeline contract validation | claude-4 (claude-opus-4-6) | Contract validation state is already implicitly per-run (each pipeline loads its own contract). OTel sampling under load is a deployment concern, not a requirements concern. The accepted R7-S9 already addresses concurrent filesystem access. | 2026-02-19 19:49:46 UTC |
| R4-S10 | Require contract YAML integrity verification (checksum) before parsing to prevent TOCTOU attacks | claude-4 (claude-opus-4-6) | Contract YAML files are loaded once at pipeline start and held in memory. The TOCTOU window is negligible for a batch pipeline. The eval() hardening (Task 3) already addresses the malicious expression vector. Adding checksum verification on every contract read adds complexity for a threat that requires filesystem-level access, which implies a much larger compromise. | 2026-02-19 19:49:46 UTC |
| R5-S2 | Specify contract validation caching strategy for repeated boundary checks on unchanged context | claude-4 (claude-opus-4-6) | This is a performance optimization that should emerge from profiling, not a requirement. The 140-invocation estimate assumes worst case, and validation of individual fields is cheap. Premature caching adds complexity (cache invalidation is notoriously error-prone, especially with default injection). If profiling reveals a bottleneck, caching can be added as an optimization without a requirements-level mandate. | 2026-02-19 20:25:47 UTC |
| R5-S4 | Require cryptographic integrity verification of contract YAML files before parsing | claude-4 (claude-opus-4-6) | REQ-PCG-015 specifies contracts are reviewed in PRs alongside code and REQ-PCG-019 checks source checksums. Adding a separate cryptographic verification layer for contract YAML creates redundancy with Git's own integrity guarantees and the existing checksum infrastructure. CI cache poisoning and artifact registry tampering are infrastructure-level concerns better addressed by infrastructure security (signed commits, protected branches), not application-level contract verification. | 2026-02-19 20:25:47 UTC |
| R6-S3 | Mandate property-based testing (fuzzing) for BoundaryValidator implementations | claude-4 (claude-opus-4-6) | R5-S6 (accepted above) already adds a comprehensive property-based testing requirement for contract validation across domain combinations. Adding a separate property-based testing mandate specifically for BoundaryValidator is redundant — the BoundaryValidator is exercised as part of the domain combination tests. | 2026-02-19 20:25:47 UTC |
| R6-S6 | Require caching of compiled contract models (regex, ASTs) to minimize validation overhead | claude-4 (claude-opus-4-6) | Same rationale as R5-S2 rejection: this is a performance optimization that should be driven by profiling data, not mandated as a requirement. Premature caching requirements add complexity without proven need. | 2026-02-19 20:25:47 UTC |
| R6-S8 | Generalize BudgetPropagationSpec to support budget leasing for async/long-running phases | gemini-3 (gemini-3-pro-preview) | The accepted R4-F3 already generalizes BudgetPropagationSpec to multiple budget types. Budget leasing for async phases is a significant new feature that adds substantial complexity and is better addressed in Phase 2 when the generalized budget system is operational. The current pipeline phases are synchronous. | 2026-02-19 20:25:47 UTC |
| R6-S10 | Define DEGRADED and BROKEN status meanings per domain for non-propagation domains | gemini-3 (gemini-3-pro-preview) | Low severity and the per-domain status semantics will naturally emerge as domains 3-7 are promoted from Y* to Y in Phase 2. Adding abstract definitions now without implementation experience would be premature and likely require revision. | 2026-02-19 20:25:47 UTC |
| R7-S7 | Split Task 1 into 6 independently committable sub-tasks (1a through 1f). | claude-4 (claude-opus-4-6) | This is a process/workflow suggestion rather than an architectural or requirements concern. The sub-sections are already well-defined in the plan. How commits are structured is an implementation detail for the person executing the plan, not a requirement that affects the document's correctness or completeness. | 2026-02-19 20:45:18 UTC |
| R8-S2 | Capture critical environment variables in the provenance record. | claude-4 (claude-opus-4-6) | While environment can affect pipeline behavior, this opens a large and poorly-bounded scope question (which env vars? how to determine criticality?). The provenance system already captures pipeline context data. Mandating specific environment variable capture belongs in operational configuration, not requirements. Also risks capturing sensitive values. | 2026-02-19 20:45:18 UTC |
| R8-S4 | Mandate TOCTOU re-verification at Stage 5 ingestion to prevent post-Gate-1 artifact modification. | claude-4 (claude-opus-4-6) | This addresses a real but narrow threat (filesystem modification between Gate 1 and Stage 5). However, the pipeline stages typically run in sequence within the same process or controlled environment, making the TOCTOU window very small. The complexity of re-hashing at every consumer stage is disproportionate to the risk. If the filesystem is compromised, re-hashing alone doesn't solve the problem. | 2026-02-19 20:45:18 UTC |

### Appendix C: Incoming Suggestions (Untriaged, append-only)

#### Review Round R1

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-19 19:02:22 UTC
- **Scope**: Architecture-focused review of the Phase 1 plan against the Pipeline Contract Governance requirements, evaluating completeness of coverage, correctness of proposed corrections, and identification of gaps.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R1-S1 | completeness | critical | The plan does not address R5-S4 (mandatory end-to-end integration test spanning stages 0→7 with contract enforcement), which was accepted in Appendix A. The Verification section only checks unit tests and document consistency, not cross-boundary integration. Add an explicit task or deferral note for this accepted suggestion. | R5-S4 is listed in Appendix A as applied, meaning it must be reflected in the plan. The handoff boundary between ContextCore and startd8-sdk is the highest-risk integration point. Without an E2E test task, the plan claims to apply a suggestion it doesn't actually implement, creating a traceability violation between Appendix A and the plan body. | Add as Task 6 or add explicit deferral note in the Deferred section with justification | Audit Appendix A applied IDs against plan tasks; verify each has a corresponding task or documented deferral |
| R1-S2 | completeness | critical | Multiple accepted suggestions from Appendix A are missing from the plan entirely: R5-S1 (contract versioning strategy — only a placeholder REQ-PCG-035 is added), R5-S2 (clock skew for provenance), R5-S3 (multi-chain severity conflict resolution), R5-S5 (_cc_propagation vs extra="forbid" reconciliation), R5-S8 (contract size/timeout limits), R5-S9 (Stage 1.5 re-stamping behavior), R6-S1 (CEL replacement for eval), R6-S3 (inline vs external provenance reconciliation at Gate 1), R6-S4 (execution time vs wall time for budget), R6-S5 (fail-closed for safety-critical contracts), R6-S6 (ASSESS determinism). Each of these is marked "Applied" but has no corresponding plan task. | Appendix A represents commitments. If these are deferred, they must appear in the Deferred section with rationale. Currently 11 accepted suggestions have no plan coverage, which means the plan will leave the document in an inconsistent state where Applied suggestions reference changes that don't exist. | Either add tasks for each or move them to the Deferred section with explicit rationale for each deferral | Cross-reference every Appendix A entry against plan tasks and Deferred list; verify 100% coverage |
| R1-S3 | architecture | high | Task 3 (eval hardening) implements AST allowlisting per R1-S6/R3-S6 but conflicts with accepted R6-S1 which mandates replacing eval() with CEL entirely. The plan implements the interim hardening without acknowledging that the accepted long-term direction is CEL replacement. This creates contradictory implementations — hardening eval() that is scheduled to be replaced. | R6-S1 is in Appendix A (applied). Task 3 hardens eval() with AST validation, which is valuable as an interim measure, but the plan should explicitly note this is a bridge to CEL adoption and scope the CEL migration as a Phase 2 item. Otherwise implementers may over-invest in the eval() sandbox infrastructure. | Task 3 description: add note that this is interim hardening pending CEL migration (R6-S1); add CEL migration to Deferred section | Review Task 3 implementation for modularity — verify the expression validation interface can be swapped to a CEL evaluator without changing callers |
| R1-S4 | risks | high | The plan proposes changing 5 domains from "D" to "Y*" in the Implementation Status Matrix based on code exploration, but Task 2 provides no verification methodology. "Code exploration revealed lifecycle wiring exists" is not equivalent to "lifecycle wiring works correctly." Without running the actual domain×lifecycle combinations, the status upgrade could be premature. | Changing status markers based on code reading rather than test execution risks the same false confidence the plan criticizes in the current document. The Y* notation partially mitigates this, but the plan should include a specific verification step (even if deferred) that exercises each domain through each lifecycle stage. | Task 2: add a verification sub-task that runs at least one test per domain×lifecycle cell, or explicitly note that Y* status is based on code review only and requires Phase 2 validation | Run domain-specific contract through preflight/runtime/postexec for each of the 5 upgraded domains; verify OTel events are emitted |
| R1-S5 | validation | medium | Task 1a adds Gate 1 check #8 ("Artifact inventory — Mottainai provenance v2 cross-check") as non-blocking, but this check is not referenced in any requirement (REQ-PCG-020 or elsewhere). Adding an undocumented gate check that isn't traced to a requirement violates the document's own traceability principles. | The plan should either create a new requirement for this 8th check or document which existing requirement it satisfies. If the check exists in code but has no requirement, that's a requirement gap that should be surfaced, not silently papered over by updating a count. | Task 1a: add a requirement source for check #8 (either map to existing REQ-PCG-024 provenance cross-check or create REQ-PCG-036) | Verify every Gate 1 check row has a traceable requirement ID |
| R1-S6 | interfaces | medium | Task 3 specifies a 1-second timeout for eval() but does not address what happens when the timeout fires. Does the chain report BROKEN? Does the gate fail? Is the timeout configurable? The plan specifies the mechanism but not the failure mode, which is critical for NFR-PCG-005 (idempotent gate execution) — a timeout that sometimes fires and sometimes doesn't based on system load would violate idempotency. | Timeout behavior must be deterministic and well-defined. If an expression times out, the chain should report a specific status (e.g., BROKEN with reason "verification expression timeout") and the result must be the same on retry (which means the timeout must be generous enough to be deterministic, or the expression must be pre-validated for complexity). | Task 3 implementation section: specify timeout failure mode (BROKEN chain status, specific error message, and whether timeout is configurable via contract YAML or environment variable) | Test: expression that takes 2 seconds with 1-second timeout produces BROKEN status; re-running produces identical BROKEN status |
| R1-S7 | ops | medium | The plan's Deferred section lists "BoundaryValidator file-based handoff hydration adapter (R3-S2)" but R3-S2 is marked as applied in Appendix A, not deferred. The same applies to R3-S7 (regression baseline), R1-S9 (gap exclusion — partially addressed in Task 1f but marked as needing UX design), and R1-S10 (schema versioning — given a placeholder). The plan must be explicit about partial vs full application. | Applied suggestions that are only partially implemented should be clearly marked in Appendix A with "Partial — placeholder added, full implementation in Phase 2" rather than appearing as fully applied. This prevents auditors from believing these requirements are fully satisfied. | Deferred section: for each deferred item that corresponds to an Appendix A entry, note that the Applied entry should be updated to "Partial" status; or update Task 5 to annotate partial applications | Audit: for each Appendix A entry, verify the plan fully implements it or marks it as partial with Phase 2 tracking |
| R1-S8 | security | medium | Task 3's AST allowlist prohibits `Call` nodes except for allowlisted functions (`len`, `str`, `int`, `float`, `bool`, `isinstance`), but does not address method calls on allowed variables. For example, `context.get("field", "").upper()` uses `.upper()` which is an `Attribute` + `Call` on a string return value. The "Attribute access beyond one level" rule would block legitimate expressions like `context.get("x", {}).get("y")`. | The allowlist needs to distinguish between dangerous calls (arbitrary function invocation) and safe method calls on primitive types. Without this distinction, the allowlist will be either too restrictive (blocking legitimate expressions) or require constant expansion, creating maintenance burden. | Task 3: refine the AST validation rules to allow method calls on primitive return types (str, dict, list methods) while blocking calls to arbitrary callables; document the distinction | Test suite: verify `context.get("x", "").strip()` passes validation; verify `eval("os.system('ls')")` fails; verify `context.__class__.__bases__` fails |
| R1-S9 | data | low | Task 1c adds complexity score bounds ("at least 2 of 7 dimensions MUST differ by ≥10 points; standard deviation > 5") but these thresholds appear arbitrary and have no calibration data. If the actual complexity scores from existing pipeline runs cluster tightly (e.g., most scores between 30-50), a std dev > 5 requirement might be trivially satisfied and thus useless, or impossibly strict for simple projects. | The thresholds should be derived from empirical data (existing pipeline runs) rather than invented. If empirical data isn't available, the plan should note that these are initial values subject to calibration in Phase 2, with a mechanism to adjust them based on observed score distributions. | Task 1c: add a note that the complexity score bounds are initial values pending calibration against real pipeline run data; add a Phase 2 task to analyze score distributions and adjust thresholds | Collect complexity scores from 10+ real pipeline runs; verify the bounds correctly classify known-good and known-bad distributions |
| R1-S10 | architecture | low | The plan's dependency graph shows Tasks 1-5 but the Estimated Scope section claims "0 cross-repo dependencies." However, Task 4 modifies REQ-CDP-011 in the companion document, which may be in the same repository but is a separate requirements document with its own review cycle. Additionally, accepted suggestions R2-S2 (E2E runtime environment) and R3-S2 (BoundaryValidator adapter) explicitly require cross-repo coordination between ContextCore and startd8-sdk. Claiming "0 cross-repo dependencies" is misleading. | The dependency claim should be scoped precisely: "0 cross-repo code dependencies for Phase 1; cross-repo coordination deferred to Phase 2 for R2-S2 and R3-S2." This prevents stakeholders from underestimating the total effort across both phases. | Estimated Scope section: revise dependency claim to "0 cross-repo code changes (eval hardening is ContextCore-only); companion document update (Task 4) is same-repo; cross-repo coordination for R2-S2 and R3-S2 deferred to Phase 2" | Review: verify no Task 3 changes require startd8-sdk modifications; verify Task 4 file is in same repository |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- (No untriaged suggestions remain in Appendix C — all prior suggestions have been triaged to Appendix A or B)

#### Feature Requirements Suggestions

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R1-F1 | completeness | high | REQ-PCG-020 Gate 1 table row 3 ("Provenance cross-check") references run-provenance.json but REQ-PCG-024 requirement 1 lists it as the third handoff artifact. There is no requirement specifying the schema or required fields of run-provenance.json itself — only that it exists and its checksums are checked. Add a requirement defining the minimum required schema for run-provenance.json. | Without a schema definition, Gate 1's "provenance cross-check" has no specification for what it's checking beyond checksum presence. Two implementations could define different provenance schemas and both claim compliance. The accepted R6-S3 (reconciliation between inline and external provenance) depends on a defined schema for comparison. | New sub-requirement under REQ-PCG-024 or REQ-PCG-007 defining the run-provenance.json schema with required fields | JSON schema validation test: verify run-provenance.json conforms to declared schema; verify Gate 1 rejects malformed provenance |
| R1-F2 | interfaces | high | REQ-PCG-009 requirement 4 states "existing `validate_phase_entry()` and `validate_phase_exit()` MUST remain unchanged" but doesn't specify the interface contract for these functions (parameters, return types, error signaling). If these are the backward-compatible API surface, their signature must be documented as a frozen interface. | The "MUST remain unchanged" constraint is unenforceable without a documented interface definition. If a new contributor modifies the return type from bool to a ValidationResult, is that a breaking change? The requirement needs to specify what "unchanged" means at the API level. | REQ-PCG-009: add a sub-requirement specifying the frozen interface signatures for validate_phase_entry() and validate_phase_exit() | API compatibility test: verify function signatures match documented interface; regression test fails if signature changes |
| R1-F3 | risks | medium | NFR-PCG-004 sandboxing and the accepted R6-S1 (CEL migration) create a transition risk: during migration from eval() to CEL, existing verification expressions in contract YAML must be ported. No requirement specifies backward compatibility for expression syntax during the transition or a tooling requirement to validate expression portability. | The eval()-to-CEL migration will break all existing verification expressions unless there's a compatibility layer or migration tool. This is a foreseeable risk that should be captured as a requirement before the transition begins, not discovered during implementation. | New NFR or sub-requirement under NFR-PCG-004: "Migration from eval() to CEL MUST include a compatibility validation tool that checks all existing verification expressions against the new evaluator before the switch" | Run compatibility checker against all existing contract YAML files; verify all expressions are either directly portable or flagged with migration instructions |
| R1-F4 | security | medium | REQ-PCG-018 specifies boundary enforcement with `validate_outbound` and `validate_inbound` but doesn't address replay attacks. A captured valid payload could be replayed at a later time to bypass freshness checks. No requirement mandates nonce, timestamp, or sequence validation on boundary payloads. | For a governance system that enforces integrity across trust boundaries, replay protection is a standard security concern. If an attacker captures a valid HandoffContract payload and replays it with stale data, the boundary validator would accept it. The freshness requirement in REQ-PCG-019 (checksums recomputed from files) partially mitigates this for file-based handoffs, but in-memory boundary validation has no freshness mechanism. | REQ-PCG-018: add a sub-requirement for payload freshness validation (e.g., timestamp within N seconds of current time, or monotonic sequence number) | Test: replay a valid payload with a timestamp >60 seconds old; verify boundary validator rejects with freshness violation |
| R1-F5 | completeness | medium | REQ-PCG-027 (Artisan Workflow) specifies 7 phases but doesn't define what happens when a phase partially succeeds — e.g., IMPLEMENT generates 8 of 10 artifacts successfully. The requirement says FINALIZE "MUST produce per-artifact SHA-256, status rollup" but doesn't specify whether partial phase success propagates to subsequent phases or halts the workflow. | The Artisan 7-phase workflow has no partial-success semantics. If IMPLEMENT fails on 2 of 10 artifacts, does REVIEW run on the 8 successful ones? Does FINALIZE report partial success? The current requirements only cover full success and full failure paths, leaving the most common real-world scenario (partial success) unspecified. | REQ-PCG-027: add requirements for partial phase success behavior (e.g., "Subsequent phases MUST execute on successfully generated artifacts; failed artifacts MUST be tracked separately in the status rollup with per-artifact failure reasons") | Test: inject a failure in 2 of 10 IMPLEMENT tasks; verify REVIEW executes on the 8 successful artifacts; verify FINALIZE reports partial success with correct counts |
| R1-F6 | interfaces | medium | REQ-PCG-025's component table maps code to repositories but doesn't specify the ContextCore package version constraint that startd8-sdk should declare. If startd8-sdk uses `contextcore>=1.0,<2.0` but the contract schema evolves in contextcore 1.5, the version constraint determines whether startd8-sdk gets the new schema automatically or must be explicitly upgraded. | The cross-repository dependency between ContextCore and startd8-sdk is the most fragile integration point in the architecture. Without a specified version constraint strategy (pinned, compatible release, or minimum version), the two halves of the pipeline can drift silently. This directly impacts the accepted R5-S1 (versioning strategy). | REQ-PCG-025: add a sub-requirement specifying the version constraint strategy for the ContextCore dependency in startd8-sdk | Integration test: upgrade ContextCore to a minor version with a new optional field; verify startd8-sdk validation wrapper handles it gracefully |
| R1-F7 | completeness | low | REQ-PCG-011 requirement 5 specifies alerting rules for `ContextPropagationDegraded` and `ContextChainBroken` but doesn't define thresholds, evaluation windows, or notification channels. These are critical operational parameters that differ between "requirement defined" and "requirement implementable." | An alerting rule without thresholds cannot be implemented deterministically. "Fire when propagation completeness drops below threshold" — what threshold? 95%? 80%? Over what time window? Without these parameters, each operator will choose different values, making the alerting behavior inconsistent across deployments. | REQ-PCG-011 requirement 5: specify default threshold values and evaluation windows (e.g., "completeness < 90% over 5-minute window" and "any BROKEN chain within 1-minute window") with a note that these are configurable defaults | Verify alerting rules are provisioned with the specified default thresholds; test: inject a BROKEN chain and verify alert fires within the evaluation window |

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| ---- | ---- | ---- | ---- |
| Part 1 §1.1 Theoretical Foundation | (no plan task — conceptual, no corrections needed) | Full | None — this is framing text, not actionable requirements |
| Part 1 §1.2 REQ-PCG-001 (Context Propagation) | Task 2 (matrix update to Y) | Full | None |
| Part 1 §1.2 REQ-PCG-002 (Schema Compatibility) | Task 2 (matrix update to Y) | Full | None |
| Part 1 §1.2 REQ-PCG-003 (Semantic Conventions) | Task 1a (R3-S3 status correction), Task 2 (matrix Y*) | Full | None |
| Part 1 §1.2 REQ-PCG-004 (Causal Ordering) | Task 1a (R3-S3 status correction), Task 2 (matrix Y*) | Full | Accepted R5-S2 (clock skew) not addressed in plan |
| Part 1 §1.2 REQ-PCG-005 (Capability Propagation) | Task 1a (R3-S3 status correction), Task 2 (matrix Y*) | Full | None |
| Part 1 §1.2 REQ-PCG-006 (SLO Budget) | Task 1a (R3-S3 status correction), Task 1c (R3-S10 testable criteria), Task 2 (matrix Y*) | Partial | Accepted R6-S4 (execution vs wall time) not addressed in plan |
| Part 1 §1.2 REQ-PCG-007 (Data Lineage) | Task 2 (matrix Y*) | Partial | Accepted R6-S3 (inline vs external provenance reconciliation) not addressed; run-provenance.json schema undefined (R1-F1) |
| Part 1 §1.3 REQ-PCG-008 (Pre-Flight) | Task 1a (R1-S4 typo fix + bypass mechanism), Task 1c (R1-S5 test counts) | Full | None |
| Part 1 §1.3 REQ-PCG-009 (Runtime Boundary) | (no explicit plan task) | Full | Frozen interface for validate_phase_entry/exit not specified (R1-F2) |
| Part 1 §1.3 REQ-PCG-010 (Post-Execution) | Task 1c (R1-S5 test counts) | Full | None |
| Part 1 §1.3 REQ-PCG-011 (Observability) | Task 1c (R3-S8 test harness approach) | Partial | Alerting thresholds undefined (R1-F7); accepted R3-S8 partially addressed |
| Part 1 §1.3 REQ-PCG-012 (Regression) | Deferred (R3-S7 baseline definition) | Partial | Regression baseline still undefined; deferred to Phase 2 |
| Part 1 §1.4 REQ-PCG-013 (Severity Model) | Task 1c (R3-S10 testable criteria), Task 1d (R4-S6 provenance stamping) | Full | None |
| Part 1 §1.5 REQ-PCG-014 (Provenance) | Task 1d (R4-S9 seed stages 0-1) | Partial | Accepted R5-S2 (clock skew), R5-S9 (Stage 1.5 re-stamping) not addressed |
| Part 1 §1.6 REQ-PCG-015 (Dual-Declaration) | (no corrections needed) | Full | Accepted R5-S5 (_cc_propagation vs extra="forbid") not addressed |
| Part 1 §1.6 REQ-PCG-016 (Progressive Adoption) | (no corrections needed) | Full | None |
| Part 2 §2.1 REQ-PCG-017 (Four A2A Contracts) | Task 1b (R2-S9 source annotations) | Partial | Accepted R5-S1 (versioning strategy) only gets a placeholder |
| Part 2 §2.2 REQ-PCG-018 (Boundary Enforcement) | Task 1b (R2-S9 source annotations) | Full | Replay protection not addressed (R1-F4) |
| Part 2 §2.2 REQ-PCG-019 (Checksums) | (no corrections needed) | Full | None |
| Part 2 §2.3 REQ-PCG-020 (Gate 1) | Task 1a (R1-S1 + R4-S1 gate count reconciliation), Task 4 (companion doc) | Full | 8th check has no requirement traceability (R1-S5 in plan review) |
| Part 2 §2.3 REQ-PCG-021 (Gate 2) | Task 1c (R3-S1 complexity bounds, R4-S3 force_route) | Full | None |
| Part 2 §2.3 REQ-PCG-022 (Gate 3) | Task 1a (R1-S2 status marker), Task 1c (R3-S4 test references) | Full | None |
| Part 2 §2.4 REQ-PCG-023 (Structured Gate Results) | Task 1a (R2-S5 fail loud for provenance) | Full | None |
| Part 2 §2.5 REQ-PCG-024 (Handoff Integrity) | Task 1c (R1-S8 REQUIRED/OPTIONAL), Task 1d (R2-S3 complete artifact set, R4-S7 filename) | Full | None |
| Part 2 §2.5 REQ-PCG-025 (Cross-Boundary Propagation) | Task 1d (R4-S2 contract type distinction), Deferred (R3-S2 hydration adapter) | Partial | BoundaryValidator hydration adapter deferred; ContextCore version constraint unspecified (R1-F6) |
| Part 2 §2.6 REQ-PCG-026 (Plan Ingestion) | Task 1f (R1-S9 gap exclusion), Task 1c (R3-S1 complexity bounds) | Full | None |
| Part 2 §2.6 REQ-PCG-027 (Artisan Workflow) | Task 1b (R2-S9 source annotations) | Full | Partial success semantics undefined (R1-F5) |
| Part 2 §2.7 REQ-PCG-028 (A2A Dashboard) | Task 1c (R3-S8 test harness) | Partial | Test harness approach partially specified |
| Part 2 §2.7 REQ-PCG-029 (Context Dashboard) | Task 1c (R3-S8 test harness) | Partial | Test harness approach partially specified |
| Part 3 REQ-PCG-030 (Contracts vs Events) | (no corrections needed) | Full | None |
| Part 3 REQ-PCG-031 (OTel Schema Consistency) | (no corrections needed) | Full | None |
| Part 3 REQ-PCG-032 (Design Calibration) | (no corrections needed) | Full | None |
| Part 4 Extension Concerns | (no plan task — out of scope) | None | Accepted R5-S7 (traceability to core REQs) not addressed in plan |
| NFRs NFR-PCG-001 (Zero Overhead) | (no corrections needed) | Full | None |
| NFRs NFR-PCG-002 (Graceful Degradation) | Task 1d (R4-S2 contract type distinction) | Partial | Accepted R6-S5 (fail-closed for safety-critical) not addressed |
| NFRs NFR-PCG-003 (Self-Observability) | (no corrections needed) | Full | None |
| NFRs NFR-PCG-004 (Expression Safety) | Task 3 (eval hardening) | Partial | Accepted R6-S1 (CEL replacement) not addressed; eval-to-CEL migration path undefined (R1-F3) |
| NFRs NFR-PCG-005 (Idempotent Gates) | (no corrections needed) | Partial | Accepted R6-S6 (ASSESS determinism) not addressed; timeout non-determinism risk (R1-S6) |

#### Review Round R2
- **Reviewer**: gemini-3 (gemini-3-pro-preview)
- **Date**: 2026-02-19 19:07:06 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
|---|---|---|---|---|---|---|
| R2-S1 | completeness | critical | Add task to resolve conflict between `_cc_propagation` injection and `extra="forbid"` in Pydantic models. | R5-S5 identified that injecting provenance into the context dict causes validation failures in strict Pydantic models (REQ-PCG-017). The Phase 1 Plan does not address this, which will lead to runtime crashes at the handoff boundary. | Phase 1 Plan, Task 1d (Architecture Clarifications) | Unit test: pass context with `_cc_propagation` to Pydantic model; verify success. |
| R2-S2 | security | high | Replace Task 3's custom AST validation with `simpleeval` or CEL integration. | Task 3 proposes a custom AST walker, which is error-prone ("rolling your own sandbox"). R6-S1 correctly suggests using standard libraries like `simpleeval` or CEL. The Plan should adopt a robust library in Phase 1 rather than building a custom validator. | Phase 1 Plan, Task 3 | Replace Task 3 implementation steps with dependency addition and integration. |
| R2-S3 | safety | high | Add task to implement "Fail-Closed" behavior for safety-critical contracts (NFR-PCG-002 update). | R6-S5 highlights that graceful degradation (skipping validation) is unacceptable for safety-critical checks (e.g., PII scrubbing). The Plan must mandate fail-closed logic for these specific contracts. | Phase 1 Plan, Task 1f (New Requirements) | Test: run safety-critical contract without ContextCore; verify pipeline halts. |
| R2-S4 | integrity | medium | Add Gate 1 check for consistency between inline `_cc_propagation` and `run-provenance.json`. | R6-S3 notes that inline and external provenance can drift. Gate 1 should verify they match to ensure audit trail integrity. This check is missing from the updated Gate 1 list in Task 1a. | Phase 1 Plan, Task 1a (Gate 1 checks) | Test: modify context dict but not provenance file; verify Gate 1 fails. |
| R2-S5 | completeness | medium | Add task to define provenance re-stamping rules for Stage 1.5 (Auto-Remedy). | R5-S9 identifies that auto-remedy invalidates provenance hashes. The Plan lacks a task to specify whether to re-stamp or preserve history at this boundary. | Phase 1 Plan, Task 1d | Test: modify field in Stage 1.5; verify provenance chain remains valid. |
| R2-S6 | scalability | medium | Add NFR for contract complexity limits (chains, expression depth) to Task 1f. | R5-S8 notes unbounded validation overhead. The Plan adds an `eval` timeout but no limits on the contract structure itself, risking DoS via complex YAML. | Phase 1 Plan, Task 1f | Test: validate large contract; verify rejection or timeout. |
| R2-S7 | accuracy | medium | Clarify "Execution Time" vs "Wall Time" for SLO Budget tracking in Task 1c. | R6-S4 notes that human-in-the-loop stages (Review) break wall-clock budgets. The Plan should explicitly specify execution time tracking to prevent false positives. | Phase 1 Plan, Task 1c | Test: simulate pause; verify budget preserved. |
| R2-S8 | completeness | medium | Add task to define deterministic resolution for conflicting severity levels across chains. | R5-S3 notes ambiguity when a field is BLOCKING in one chain and ADVISORY in another. The Plan needs a resolution rule (e.g., max severity wins) to ensure deterministic validation. | Phase 1 Plan, Task 1d | Test: conflicting chains; verify strict enforcement. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R5-S5: Critical integration bug; Pydantic strict mode will reject provenance data.
- R6-S1: Security best practice; custom sandboxes are prone to bypasses.
- R6-S5: Essential for safety guarantees; silent bypass of safety checks is dangerous.

#### Feature Requirements Suggestions
(None - The Phase 1 Plan accurately targets the known issues in the Feature Requirements, subject to the improvements suggested above.)

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
|---|---|---|---|
| **REQ-PCG-001** (Propagation) | Task 2, Task 3 | Full | - |
| **REQ-PCG-002** (Schema Compat) | Task 2 | Full | - |
| **REQ-PCG-003..007** (Domains) | Task 2, Task 1b | Partial | R2-S7 (Budget time), R2-S4 (Provenance sync) |
| **REQ-PCG-008..010** (Lifecycle) | Task 1c | Full | - |
| **REQ-PCG-013** (Severity) | Task 1c, Task 1d | Partial | R2-S8 (Conflict resolution) |
| **REQ-PCG-014** (Provenance) | Task 1d, Task 2 | Partial | R2-S1 (Pydantic collision), R2-S5 (Re-stamping) |
| **REQ-PCG-017** (A2A) | Task 1d | Partial | R2-S1 (Pydantic collision) |
| **REQ-PCG-020** (Gate 1) | Task 1a | Partial | R2-S4 (Provenance sync check missing) |
| **REQ-PCG-021** (Gate 2) | Task 1c | Full | - |
| **REQ-PCG-022** (Gate 3) | Task 1a | Full | - |
| **REQ-PCG-024** (Handoff) | Task 1d, Task 1a | Full | - |
| **REQ-PCG-025** (Boundary) | Task 1d | Full | - |
| **REQ-PCG-026** (Ingestion) | Task 1f, Task 1c | Full | - |
| **NFR-PCG-002** (Degradation) | Task 1d | Partial | R2-S3 (Fail-closed missing) |
| **NFR-PCG-004** (Eval Safety) | Task 1e, Task 3 | Full | R2-S2 (CEL preference) |

#### Review Round R3

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-19 19:19:51 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R3-S1 | architecture | high | Add an explicit contract domain composition architecture describing how the 7 domains are loaded, ordered, and composed at each phase boundary into a single enforcement pipeline | The plan corrects the Implementation Status Matrix (Task 2) and adds aggregation semantics (R7-S3), but no requirement or plan task specifies the runtime composition architecture: how are domain validators discovered, in what order are they invoked, and how does the orchestrator collect and merge their results? Without this, each domain operates in isolation and the "defense-in-depth" claim is aspirational rather than structural. The plan's Y* status assumes composition works but never verifies the composition mechanism itself. | New architectural requirement REQ-PCG-036 in Part 3 (Cross-Cutting Requirements), or as a sub-section under Section 1.3 (Defense-in-Depth Lifecycle) specifying the domain composition pipeline | Integration test: register all 7 domain validators, invoke boundary check at a phase transition, verify all 7 produce results and the composite verdict follows documented precedence rules; verify domain addition/removal is plugin-style without modifying orchestrator code |
| R3-S2 | clarity | high | Define a glossary of key terms used inconsistently across the document: "contract", "gate", "check", "validation", "enforcement", "verification" | The document uses these terms interchangeably in ways that create confusion: "gate" sometimes means a named checkpoint (Gate 1/2/3) and sometimes means any blocking check; "contract" refers to both YAML declarations and Pydantic runtime objects; "validation" and "verification" are used as synonyms despite having distinct meanings in formal methods. The plan corrects specific numeric inconsistencies (gate check counts) but doesn't address the underlying terminological ambiguity that caused them. A glossary at the top of Part 1 would prevent future drift. | New subsection "Terminology" between "Audience" and "Pipeline Overview" sections, defining each term precisely with scope of usage | Review: search document for each glossary term; verify every usage is consistent with the definition; add to CI lint rules for future PRs |
| R3-S3 | clarity | high | Restructure the Non-Functional Requirements section to distinguish pipeline NFRs from contract-system NFRs, and add explicit NFR IDs for the 6+ implicit NFRs scattered through the document | NFR-PCG-001 through NFR-PCG-005 are explicitly numbered, but several NFRs are embedded in functional requirements without IDs: deterministic ASSESS scoring (R6-S6/accepted), contract validation timeout bounds (R7-S2/accepted), concurrent run isolation (R7-S9/accepted), clock skew tolerance (R5-S2/accepted). The plan adds these as inline notes but doesn't elevate them to proper NFR status. Without explicit IDs, they cannot be traced in the Verification Plan or Implementation Status Matrix. | Expand the NFR section with NFR-PCG-006 through NFR-PCG-010 covering: validation time budget, concurrent run isolation, deterministic scoring, clock skew tolerance, and provenance storage bounds | Verify each new NFR has a corresponding Verification Plan entry and can be traced to the accepted suggestion that motivated it |
| R3-S4 | clarity | medium | Add sequence diagrams or pseudocode for the three critical handoff points: Stage 4→5 (file-based handoff), Gate 2→Stage 6 (routing decision), and Stage 6→Gate 3 (finalize verification) | The pipeline overview diagram shows stages as boxes but doesn't illustrate the data flow at critical transitions. The plan acknowledges R3-S2 (BoundaryValidator impedance mismatch) as deferred to Phase 2, but even a pseudocode sketch of the hydration step would prevent implementers from making incompatible assumptions. The current text describes WHAT is checked at each boundary but not HOW data transforms between representations (YAML on disk → context dict in memory → Pydantic model for validation). | New subsection "Critical Handoff Sequences" in Part 3 or inline within REQ-PCG-024/025, showing the data transformation pipeline at each boundary | Review: implementer can write the hydration code from the pseudocode alone without consulting source documents; the sequence matches actual code in context_seed_handlers.py |
| R3-S5 | maintainability | high | Extract the 33 accepted review suggestions into a formal "Document Amendment Register" with semantic categories, and require future amendments to follow the same structure | The Appendix A table has grown to 33+ entries spanning corrections, new requirements, status changes, and architectural clarifications. Without categorization, a maintainer cannot quickly determine which amendments affect the requirements body vs. the verification plan vs. the implementation status matrix. The plan (Task 5) moves suggestions to Applied but doesn't restructure the register. As more review rounds accumulate, the append-only log becomes an unsearchable wall of text. | Restructure Appendix A into sub-tables by amendment type: (1) Requirement Corrections, (2) New Requirements Added, (3) Status/Matrix Updates, (4) Traceability Additions, (5) Security Hardening | Verify each amendment in the register has a corresponding diff in the document body; verify categories are mutually exclusive |
| R3-S6 | maintainability | high | Add a machine-readable requirements index (YAML or JSON) alongside the markdown that can be consumed by CI for automated traceability checking | The document defines 32 REQ-PCG-* IDs, 5 NFR-PCG-* IDs, and a verification plan, but all exist only in markdown prose. The plan adds traceability tables (R3-S9) and source annotations (R3-S5), but these remain manually maintained and will drift. A machine-readable index (`requirements-index.yaml`) mapping each REQ ID to its status, priority, test files, domain, and lifecycle stage would enable automated staleness detection, coverage gap reporting, and cross-document consistency checks. | New file `docs/design/requirements/requirements-index.yaml` referenced from the NFR section as a maintainability requirement (NFR-PCG-011) | CI job: parse requirements-index.yaml, verify every REQ-PCG-* in the markdown has an index entry, verify every test file referenced exists, verify status matches Implementation Status Matrix |
| R3-S7 | maintainability | medium | Define a document update protocol specifying who owns sections, review cadence, and how the Implementation Status Matrix stays synchronized with code | The plan corrects the matrix (Task 2) based on code exploration, but no process ensures the matrix stays accurate as code evolves. The D→Y* correction was only discovered because a reviewer manually explored the codebase. Without CODEOWNERS-style section ownership and a CI check that validates matrix claims against test results, the matrix will drift again within weeks. | New subsection "Document Maintenance" after the NFR section, or as NFR-PCG-012, specifying: section owners, update triggers (code changes to contracts/ directories), and CI validation of matrix status claims | CI check: if files in `contracts/{domain}/` change, verify the corresponding matrix cell status is updated in the same PR |
| R3-S8 | scalability | high | Add requirements for contract composition scaling: how the system behaves as contract domains grow from 7 to 15+ and propagation chains grow from tens to hundreds | The plan acknowledges validation timeout bounds (R7-S2/accepted) but doesn't address the architectural scaling implications. The current design loads all domain validators at every phase boundary. With 7 domains this is manageable, but Part 4 lists 9 extension concerns that would bring the total to 16 domains. No requirement specifies lazy loading, domain filtering per stage, or validation parallelism. The plan's Y* status assumes sequential validation, which won't scale. | New scalability requirement in Part 3 or as sub-requirements under REQ-PCG-008/009 specifying: domain filtering (only load domains relevant to the current phase), validation parallelism strategy, and maximum domain count the architecture must support | Benchmark: measure validation latency with 7 vs 16 domains × 50 chains; verify latency stays within the budget defined by the accepted R7-S2 timeout requirement |
| R3-S9 | scalability | high | Specify how the provenance storage model scales across multi-project and multi-run scenarios, including retention, archival, and query patterns | REQ-PCG-007 requires provenance to travel inline with context data, and accepted R8-S7 adds pruning strategy, but neither addresses multi-project scaling. If an organization runs hundreds of pipelines daily, the aggregate provenance data across `run-provenance.json` files and `_cc_propagation` dicts becomes a data management challenge. No requirement specifies retention policies, archival to external storage, or query interfaces for cross-run provenance analysis. The plan focuses on single-run correctness without addressing operational scaling. | New scalability sub-requirements under REQ-PCG-007 or as NFR-PCG-013 specifying: per-run provenance retention period, archival strategy (e.g., to OTel backend), cross-run query interface for lineage analysis, and storage budget per project | Verify provenance storage after 100 simulated runs stays within defined bounds; verify archived provenance is queryable via the specified interface |
| R3-S10 | security | high | Define a threat model for the contract governance system itself, covering supply chain attacks on contract YAML, trust boundaries between pipeline halves, and the security implications of the progressive adoption path | The plan hardens eval() (Task 3) and accepted suggestions address specific attack vectors, but no holistic threat model exists for the governance system. REQ-PCG-016's progressive adoption path (advisory → warning → blocking) means contracts may run in non-blocking mode for extended periods, during which violations are logged but not enforced. An attacker could exploit this window to establish patterns that would later be difficult to remove. Additionally, the file-based handoff between ContextCore and startd8-sdk has no integrity protection beyond checksums — TOCTOU attacks between checksum verification and file consumption are possible. | New section "Threat Model" in Part 3 or as an appendix, covering: (1) contract YAML supply chain, (2) progressive adoption window risks, (3) TOCTOU at file-based handoff, (4) provenance forgery vectors, (5) trust boundary between pipeline halves | Security review: for each threat, verify a mitigating requirement exists or document the accepted risk; penetration test: attempt TOCTOU attack at handoff boundary |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- (No prior untriaged suggestions found in Appendix C to endorse — all prior suggestions have been triaged to Applied or Rejected per the preamble.)

#### Feature Requirements Suggestions

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R3-F1 | clarity | high | REQ-PCG-009 requirement 3 specifies emitting `context.boundary.{entry\|exit\|enrichment}` span events but does not define the cardinality: is one event emitted per boundary direction, or one per field checked? With 7 domains active, a single phase transition could emit dozens of events. Specify whether events are per-boundary (summary) or per-field (detailed). | High-cardinality span events can overwhelm OTel collectors and make traces unreadable. The plan doesn't address this because it focuses on correctness, not operational impact. The requirement must specify the emission granularity so implementers and operators know what to expect. | REQ-PCG-009 requirement 3 and REQ-PCG-031 attribute schema | Verify span event count at a phase boundary matches the documented cardinality; load test with 7 domains to confirm OTel collector handles the volume |
| R3-F2 | architecture | high | REQ-PCG-025's component-to-repository mapping table lists 8 components but doesn't specify the dependency direction or API surface between them. The validation wrapper in startd8-sdk imports from ContextCore, but the contract YAML in startd8-sdk is consumed by the loader in ContextCore. This creates a circular dependency that the plan doesn't address. | The cross-repo dependency direction must be unidirectional for maintainability. If startd8-sdk's contract YAML must be readable by ContextCore's loader, either the YAML schema must be published as a shared artifact or the loader must be invoked within startd8-sdk's process. The plan's Phase 2 deferral of the hydration adapter doesn't resolve this architectural question. | REQ-PCG-025 component table — add dependency direction arrows and clarify which repo's process runs the loader | Verify the dependency graph is acyclic; verify ContextCore can be built and tested without startd8-sdk present and vice versa |
| R3-F3 | security | medium | REQ-PCG-018 requires `validate_outbound` and `validate_inbound` at every boundary but doesn't specify whether validation failures are logged with the payload content. If payloads contain sensitive data (per accepted R8-S3's sensitive field proposal), the error envelope's `failed_path` could leak field values into logs. | The intersection of boundary enforcement error reporting and sensitive field handling creates a data leakage vector that neither requirement addresses individually. The plan's Task 3 (eval hardening) doesn't cover this because it focuses on expression safety, not data exposure in error paths. | REQ-PCG-018 requirement 5 — add: "Error envelopes MUST NOT include field values for fields marked `sensitive=True` in the contract schema" | Unit test: trigger validation failure on a sensitive field; verify error envelope contains the field path but not the value |
| R3-F4 | testability | medium | REQ-PCG-012 (Regression Detection) requires CI to block PRs that reduce propagation completeness, but the plan defers the baseline definition (R3-S7) to Phase 2. Without a baseline, this P2 requirement is unimplementable, yet the Verification Plan claims tests exist in `contracts/regression/`. Clarify whether existing regression tests verify a different property than cross-PR completeness comparison. | The plan correctly identifies the baseline gap but doesn't clarify what the existing regression tests actually verify. If they verify contract YAML syntax rather than cross-build completeness, the Verification Plan entry is misleading. | REQ-PCG-012 verification plan entry — specify what existing tests cover and what remains blocked on the Phase 2 baseline decision | Review existing regression tests; document their actual scope in the Verification Plan |
| R3-F5 | architecture | medium | REQ-PCG-030 distinguishes contract objects from span events but doesn't define what happens when a span event needs to be promoted to a contract object (e.g., when a diagnostic detail becomes a routing signal). The progressive adoption path (REQ-PCG-016) implies fields move from advisory to blocking, but the document doesn't address the event-to-contract promotion pattern. | As the system matures, operators will discover that certain span events carry information needed for boundary decisions. Without a defined promotion pattern, these discoveries lead to ad-hoc contract additions that bypass the review process. | REQ-PCG-030 — add a sub-requirement: "When a span event is identified as carrying boundary-decision data, it MUST be promoted to a contract field via the standard PR review process, with the original span event preserved as diagnostic context" | Review: verify no boundary decision in code depends on span event data rather than contract fields |

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| ---- | ---- | ---- | ---- |
| 1.1 Theoretical Foundation | (no changes needed) | Full | None |
| 1.2 REQ-PCG-001 (Propagation) | Task 2 (matrix update) | Full | None |
| 1.2 REQ-PCG-002 (Schema Compat) | Task 2 (matrix update) | Full | None |
| 1.2 REQ-PCG-003 (Semconv) | Task 1a (status correction via R3-S3) | Full | None |
| 1.2 REQ-PCG-004 (Causal Ordering) | Task 1a (status correction via R3-S3) | Full | None |
| 1.2 REQ-PCG-005 (Capability) | Task 1a (status correction via R3-S3) | Full | None |
| 1.2 REQ-PCG-006 (SLO Budget) | Task 1a (status correction via R3-S3), Task 1c (R3-S10 acceptance criteria) | Full | None |
| 1.2 REQ-PCG-007 (Lineage) | Task 2 (matrix update) | Partial | Provenance scaling across multi-project scenarios not addressed (see R3-S9) |
| 1.3 REQ-PCG-008 (Pre-Flight) | Task 1a (R1-S4 typo fix, bypass mechanism), Task 1c (test counts) | Full | None |
| 1.3 REQ-PCG-009 (Runtime) | Task 1d (R4-S2 degradation distinction) | Partial | Span event cardinality per boundary not specified (see R3-F1); domain composition order not specified (see R3-S1) |
| 1.3 REQ-PCG-010 (Post-Exec) | Task 1c (test counts) | Full | None |
| 1.3 REQ-PCG-011 (Observability) | Task 1c (R3-S8 test harness approach) | Full | None |
| 1.3 REQ-PCG-012 (Regression) | (deferred: baseline definition) | Partial | Baseline for completeness comparison deferred to Phase 2; existing test scope unclear (see R3-F4) |
| 1.4 REQ-PCG-013 (Severity) | Task 1c (R3-S10), Task 1d (R4-S6 provenance stamping on defaults) | Full | None |
| 1.5 REQ-PCG-014 (Provenance) | Task 1d (R4-S9 stage 0-1 seeding) | Partial | repr() replacement deferred (R7-S5 accepted but not in plan scope); sensitive field hashing not addressed in plan (R8-S3 accepted) |
| 1.6 REQ-PCG-015 (Dual Declaration) | (no changes needed) | Full | None |
| 1.6 REQ-PCG-016 (Progressive Adoption) | (no changes needed) | Partial | Progressive adoption window security risks not addressed (see R3-S10) |
| 2.1 REQ-PCG-017 (Four A2A Contracts) | Task 1b (R1-S10 versioning placeholder) | Partial | Schema versioning strategy deferred to Phase 2 |
| 2.2 REQ-PCG-018 (Boundary Enforcement) | (no changes needed) | Partial | Sensitive field leakage in error envelopes not addressed (see R3-F3) |
| 2.2 REQ-PCG-019 (Checksums) | Task 1a (R1-S1 gate count reconciliation) | Full | None |
| 2.3 REQ-PCG-020 (Gate 1) | Task 1a (R1-S1 + R4-S1: 8 checks, gap parity fix) | Full | None |
| 2.3 REQ-PCG-021 (Gate 2) | Task 1c (R3-S1 reasonableness, R4-S3 force_route) | Full | None |
| 2.3 REQ-PCG-022 (Gate 3) | Task 1a (R1-S2 status), Task 1c (R4-S8 integrity vs reproducibility, R3-S4 test refs) | Full | None |
| 2.4 REQ-PCG-023 (Structured Results) | (no changes needed) | Full | None |
| 2.5 REQ-PCG-024 (Handoff Integrity) | Task 1a (R4-S7 filename), Task 1c (R1-S8 field annotations), Task 1d (R2-S3 artifact set) | Full | None |
| 2.5 REQ-PCG-025 (Cross-Boundary) | Task 1d (R4-S2 degradation distinction) | Partial | BoundaryValidator hydration adapter deferred to Phase 2 (R3-S2); cross-repo dependency direction unclear (see R3-F2) |
| 2.6 REQ-PCG-026 (Plan Ingestion) | Task 1c (R3-S1 reasonableness), Task 1f (R1-S9 gap exclusion) | Full | None |
| 2.6 REQ-PCG-027 (Artisan Workflow) | (no changes needed) | Partial | Partial phase success semantics accepted (R1-F5) but not explicitly addressed in plan tasks |
| 2.7 REQ-PCG-028 (A2A Dashboard) | Task 1c (R3-S8 test harness) | Full | None |
| 2.7 REQ-PCG-029 (Propagation Dashboard) | Task 1c (R3-S8 test harness) | Full | None |
| 3 REQ-PCG-030 (Contracts vs Events) | (no changes needed) | Partial | Event-to-contract promotion pattern not defined (see R3-F5) |
| 3 REQ-PCG-031 (OTel Schema) | (no changes needed) | Full | None |
| 3 REQ-PCG-032 (Design Calibration) | (no changes needed) | Full | None |
| Part 4 Extensions | (no changes needed) | Full | Traceability to core REQs addressed by R7-S7 (accepted) |
| NFR-PCG-001 (Zero Overhead) | (no changes needed) | Full | None |
| NFR-PCG-002 (Graceful Degradation) | Task 1d (R4-S2 degradation distinction) | Partial | Fail-closed for safety-critical contracts accepted (R6-S5) but not explicitly in plan task list |
| NFR-PCG-003 (Self-Observability) | (no changes needed) | Full | None |
| NFR-PCG-004 (Expression Safety) | Task 3 (eval hardening) | Full | None |
| NFR-PCG-005 (Idempotent Gates) | (no changes needed) | Partial | Deterministic ASSESS requirement accepted (R6-S6) but not explicitly in plan task list |
| Implementation Status Matrix | Task 2 | Full | None |
| Verification Plan | Task 1c (test counts), Task 5 (review log) | Partial | No integration/E2E test requirement in plan (R7-S4 accepted); domain-logic vs lifecycle-integration test distinction not in plan (R7-S10 accepted) |

#### Review Round R4

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-19 19:41:04 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R4-S1 | testability | high | Add contract-level test fixture requirements: define a minimal "golden" contract YAML fixture and a corresponding "poison" fixture for each contract domain, mandated as test artifacts in the Verification Plan | The Verification Plan cites test counts per domain but no requirement ensures that tests use realistic contract YAML fixtures. Unit tests could use trivial single-field contracts that never exercise multi-chain, multi-domain interactions. Without standardized fixtures, test quality is unverifiable and new contributors cannot assess whether existing tests provide meaningful coverage. This is a testability gap that becomes critical as the 7 domains + 9 extensions grow. | Add a new sub-section under the Verification Plan specifying that each domain MUST have a `fixtures/golden.contract.yaml` (valid, multi-chain) and `fixtures/poison.contract.yaml` (deliberately invalid) checked into the test directory | CI check: verify fixture files exist for all 7 domains; each domain's test suite imports and exercises both fixtures; poison fixtures produce expected validation failures |
| R4-S2 | testability | high | Require contract validation to produce machine-readable coverage reports showing which contract clauses were exercised during a pipeline run | REQ-PCG-010 emits a propagation summary with completeness_pct but no requirement ensures that individual contract clauses (specific FieldSpec entries, specific PropagationChainSpec entries) are tracked for coverage. A pipeline could achieve 100% chain-level INTACT status while never exercising WARNING or ADVISORY severity paths. Without clause-level coverage, operators cannot distinguish "all contracts validated" from "most contracts never triggered." | New sub-requirement under REQ-PCG-010 or REQ-PCG-011: "Post-execution summary MUST include per-clause coverage: how many FieldSpec entries were evaluated, how many PropagationChainSpec chains were verified, and how many severity tiers were exercised" | Integration test: run pipeline with a contract containing BLOCKING, WARNING, and ADVISORY fields; verify post-execution report lists each clause and its evaluation outcome |
| R4-S3 | testability | high | Specify a contract testing mode that validates contracts against synthetic context without executing the actual pipeline stages | REQ-PCG-008 (pre-flight) validates initial context and REQ-PCG-016 supports progressive adoption, but there is no requirement for a dry-run / contract-testing mode that lets operators validate their contract YAML against synthetic or recorded context dicts without running the full pipeline. This is essential for testability during the "declaration only" adoption stage and for CI validation of contract changes in isolation. | New requirement REQ-PCG-036 or sub-requirement under REQ-PCG-016: "The contract system MUST support a `--dry-run` mode that validates contract YAML against a provided JSON context dict without executing pipeline stages" | Test: invoke dry-run with a valid context dict and verify all chains report status; invoke with an invalid context dict and verify BROKEN chains are detected; verify no pipeline stage side effects occur |
| R4-S4 | clarity | high | Define the contract governance posture for the ASSESS phase's LLM-based scoring, reconciling probabilistic scoring with idempotent gate requirements | Accepted R6-S6 requires ASSESS determinism for NFR-PCG-005 compliance, but the plan doesn't specify how this is achieved. If ASSESS uses an LLM (as implied by the "multi-agent review via tiered cost model"), strict determinism requires fixed temperature=0, seed parameters, and model version pinning. The requirements document should clarify whether ASSESS is permitted to use non-deterministic methods and, if so, define a tolerance band for score variation that still satisfies idempotency. | REQ-PCG-026 requirement 2 and NFR-PCG-005: add clarification specifying either (a) ASSESS MUST use deterministic scoring (no LLM, or LLM with temperature=0 and fixed seed) or (b) ASSESS scores are cached after first computation and reused on re-run to satisfy idempotency | Test: run ASSESS 10 times on identical input; verify all scores are identical (deterministic) or within declared tolerance band |
| R4-S5 | clarity | high | Specify the semantic difference between `run-provenance.json` (external audit trail) and `_cc_propagation` (inline provenance), including authoritative source designation for conflict resolution | Accepted R6-S3 mandates reconciliation between inline and external provenance at Gate 1, but neither the requirements nor the plan specifies which source is authoritative when they disagree. If `run-provenance.json` says field X was set in phase 2 but `_cc_propagation` says phase 3, the reconciliation check detects the mismatch but the operator has no guidance on which to trust. This is a clarity gap that directly impacts the actionability of Gate 1 failures. | REQ-PCG-007 or the new Gate 1 check #8 from R6-S3: add "When reconciliation detects a mismatch, `_cc_propagation` (inline) is authoritative because it travels with the data (per REQ-PCG-007 req 3). `run-provenance.json` MUST be regenerated from `_cc_propagation` at export time." | Test: introduce a mismatch between inline and external provenance; verify Gate 1 failure message identifies inline as authoritative and recommends re-export |
| R4-S6 | maintainability | high | Require all contract domain validators to implement a common `DomainValidator` interface/protocol with standardized entry points | The plan promotes 5 domains from "D" to "Y*" but no requirement specifies a common interface for domain validators. Each domain (propagation, schema_compat, semconv, ordering, capability, budget, lineage) can implement validation differently, making the aggregation logic (accepted R9-S3) fragile and domain-specific. A common protocol (`validate_boundary(context, contract) -> DomainResult`) ensures that new domains and the cross-domain aggregation layer can be maintained without per-domain special-casing. | New architectural requirement in Section 1.2 preamble or as a sub-requirement of REQ-PCG-009: "All contract domain validators MUST implement the `DomainValidator` protocol with methods `validate_entry()`, `validate_exit()`, and `validate_enrichment()`, each returning a `DomainResult` with `domain_id`, `severity`, `status`, and `evidence`" | Test: verify all 7 domain validators conform to the protocol via `isinstance` check or structural typing; verify aggregation layer operates generically without domain-specific branches |
| R4-S7 | maintainability | high | Define a contract YAML modularity strategy allowing per-domain contract files that compose into a pipeline-level contract | REQ-PCG-015 specifies a single contract YAML as source of truth, but as 7 domains + 9 extensions each declare contracts, a single file becomes unwieldy. No requirement addresses how contract declarations from multiple domains are organized, merged, or composed. This is a maintainability gap that will become acute as teams adopt contracts progressively (REQ-PCG-016) with different domains at different stages. | New sub-requirement under REQ-PCG-015: "Contract declarations MAY be split into per-domain files (e.g., `propagation.contract.yaml`, `budget.contract.yaml`) and composed via a `contract_path` pointing to a directory. The `ContractLoader` MUST support both single-file and directory-based loading, merging domain contracts into a composite pipeline contract." | Test: create per-domain contract files in a directory; verify ContractLoader produces the same composite contract as an equivalent single file; verify domain-level file changes only trigger domain-specific validation in CI (REQ-PCG-012) |
| R4-S8 | scalability | high | Specify contract validation caching strategy to prevent redundant re-validation of unchanged contract sections across pipeline stages | REQ-PCG-009 runs boundary checks at every phase transition, and with 7 domains × 8 stages, this is 56+ validation invocations per run. Many contract clauses (e.g., schema compatibility, semantic conventions) don't change between phases — only the context dict changes. No requirement addresses whether validators can cache parsed contracts or domain results that are invariant across phases. As pipeline length and domain count grow, redundant validation becomes a scalability bottleneck. | New sub-requirement under NFR-PCG-001 or REQ-PCG-009: "The contract validation system SHOULD cache parsed contract specifications and reuse them across phase boundaries within a single pipeline run. Caching MUST be invalidated if the contract YAML file is modified during execution (checksum comparison)." | Benchmark: compare validation latency for a 7-stage pipeline with and without contract caching; verify cache invalidation on contract file modification |
| R4-S9 | scalability | high | Define horizontal scaling semantics for contract validation when multiple pipeline instances run concurrently on shared infrastructure | Accepted R7-S9 addresses concurrent runs at the filesystem level, but no requirement addresses the contract validation infrastructure's behavior under concurrent load. If 10 pipelines run simultaneously, each loading and parsing the same contract YAML, the OTel collector receives 10× the telemetry volume. The contract system should specify whether validation state is per-run isolated and whether OTel emission should be sampled under high concurrency. | New NFR or sub-requirement: "Contract validation state MUST be fully isolated per pipeline run (no shared mutable state). Under concurrent load, OTel emission MAY be sampled per configurable `contract_telemetry_sampling_rate` (default 1.0 = emit all)." | Load test: run 10 concurrent pipeline instances; verify no cross-run state contamination; verify OTel collector handles the volume or sampling reduces it to sustainable levels |
| R4-S10 | security | high | Require contract YAML files to be integrity-verified (checksum or signature) before parsing, preventing TOCTOU attacks between file read and validation | REQ-PCG-015 loads contract YAML at pipeline start, but if contract files are on shared storage, they could be modified between the time they're loaded and when validation results are used (TOCTOU — Time of Check, Time of Use). The accepted eval() hardening (Task 3) prevents malicious expressions at parse time, but doesn't prevent a legitimate contract file from being swapped for a malicious one after the initial safety check. This extends the defense-in-depth principle to the contract loading mechanism itself. | NFR-PCG-004 or REQ-PCG-015: "The `ContractLoader` MUST compute a SHA-256 checksum of the contract YAML file at load time and store it. If contract YAML is re-read during the pipeline run (e.g., for re-validation), the checksum MUST be re-verified. A checksum mismatch MUST halt the pipeline with a BLOCKING GateResult." | Test: load contract YAML, modify the file on disk, trigger re-validation; verify pipeline halts with checksum mismatch error |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R4-F2: The observation that `BudgetPropagationSpec` is locked to time-based budgets (`remaining_budget_ms`) while the pipeline uses LLM token budgets and cost budgets is a genuine scalability gap that will require generalization as agent-based execution matures.
- R4-F3: The ambiguity about whether `contextcore` is a runtime peer dependency or dev-time requirement for `startd8-sdk` is a real maintainability concern that directly impacts deployment topology and the accepted NFR-PCG-002 graceful degradation semantics.

#### Feature Requirements Suggestions

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R4-F1 | clarity | high | REQ-PCG-016 requirement 3 defines the adoption path as "declaration only → loader → monitor → tighten" but provides no observable criteria for stage transitions, making progressive adoption unverifiable | Without graduation criteria, teams will remain at the easiest stage indefinitely. The "monitor" stage requires dashboard data but no minimum observation period is specified. The "tighten" stage requires promoting severity levels but no confidence threshold is defined. This makes the progressive adoption path aspirational rather than actionable. | REQ-PCG-016 requirement 3: add per-stage graduation criteria (e.g., "loader → monitor requires ≥1 week of span event data; monitor → tighten requires ≥95% INTACT chains over 2 weeks") | Review: verify graduation criteria are testable; integration test: simulate 1 week of data and verify system recommends promotion |
| R4-F2 | maintainability | high | REQ-PCG-027 requirement 6 specifies implementation details ("multi-agent review via tiered cost model (drafter/validator/reviewer)") rather than verifiable contract requirements | A requirements document should specify WHAT must be validated, not HOW the validation is internally structured. The drafter/validator/reviewer pattern is an implementation choice that may change. The requirement should specify: "REVIEW MUST validate generated artifacts against `expected_output_contracts` and produce structured pass/fail results per artifact." | REQ-PCG-027 requirement 6: rewrite to focus on validation outcomes rather than internal review architecture | Verify the rewritten requirement is testable without knowledge of the internal review structure |
| R4-F3 | scalability | medium | REQ-PCG-006 binds SLO budgets exclusively to time (`remaining_budget_ms`) but the pipeline consumes multiple budget types (LLM tokens, API costs, compute time) that are not interchangeable | The Artisan workflow (REQ-PCG-027) uses a "tiered cost model" implying financial budget tracking, and LLM-based ASSESS/REVIEW phases consume tokens. A time-only budget spec cannot represent these constraints. Generalizing `BudgetPropagationSpec` to support `budget_unit: time|tokens|cost` would make the domain applicable to real pipeline economics. | REQ-PCG-006: generalize `remaining_budget_ms` to `remaining_budget` with a `budget_unit` discriminator, or add a note deferring multi-unit budgets to Extension Concern 6E | Test: define a token-based budget contract; verify budget tracking decrements tokens not milliseconds |
| R4-F4 | clarity | medium | REQ-PCG-009 requirement 4 states existing functions "MUST remain unchanged" but doesn't define what "unchanged" means — API signature, return type, or behavioral semantics | If "unchanged" means API signature only, internal implementation can be extended for domain wiring. If it means behavioral semantics, no new validation side effects are permitted. Accepted R1-F2 flagged this but the plan's Task 1 doesn't specify which interpretation to apply. | REQ-PCG-009 requirement 4: clarify "The public API signatures and return types of `validate_phase_entry()` and `validate_phase_exit()` MUST remain backward compatible. Internal implementation MAY be extended to invoke domain-specific validators." | Unit test: verify existing callers of validate_phase_entry() receive identical return values after contract system integration |
| R4-F5 | testability | medium | NFR-PCG-005 (Idempotent Gate Execution) conflicts with REQ-PCG-001 requirement 4 (WARNING defaults mutate context), creating undefined behavior on re-run | Accepted R10-S2 identified this tension but the plan doesn't resolve it. If a gate mutates context by applying defaults, a second run sees the field as present (not defaulted), producing different telemetry. The requirement should specify that idempotency is defined over the original input state, not the mutated state, or that mutation is recorded and replayed identically. | NFR-PCG-005: add "Idempotency is defined over the original pipeline input context. If validation mutates context (e.g., applying defaults per REQ-PCG-001 req 4), the mutation MUST be recorded and the same mutation MUST be applied deterministically on re-run." | Test: run validation twice on same input; verify second run produces identical GateResult including telemetry status |

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| ---- | ---- | ---- | ---- |
| 1.1 Theoretical Foundation | (documentation only, no implementation) | Full | None — foundational framing, not actionable |
| 1.2 Contract Domain Requirements (REQ-PCG-001 to 007) | Task 1a (status corrections), Task 2 (matrix update) | Partial | Domain validator interface not standardized (R4-S6); per-domain contract file modularity not addressed (R4-S7) |
| 1.3 Defense-in-Depth Lifecycle (REQ-PCG-008 to 012) | Task 1a (bypass flag), Task 1c (test counts), Task 1f (REQ-PCG-034 failure injection) | Full | Regression baseline (R3-S7) deferred to Phase 2 — acceptable |
| 1.4 Severity Model (REQ-PCG-013) | Task 1c (qualitative criteria), Task 1d (provenance stamping for defaults) | Full | Idempotency interaction with default mutation (R4-F5) not resolved in plan |
| 1.5 Provenance (REQ-PCG-014) | Task 1d (stage 0-1 seeding, re-stamping) | Partial | Authoritative source for inline vs external provenance mismatch not specified (R4-S5); repr() replacement deferred |
| 1.6 Contract Declaration (REQ-PCG-015, 016) | Task 1f (REQ-PCG-035 versioning placeholder) | Partial | Contract YAML modularity for multi-domain (R4-S7) not addressed; progressive adoption graduation criteria (R4-F1) not specified |
| 2.1 Contract Types (REQ-PCG-017) | Task 1f (REQ-PCG-035 versioning) | Partial | Version negotiation deferred to Phase 2; TOCTOU on contract files not addressed (R4-S10) |
| 2.2 Boundary Enforcement (REQ-PCG-018, 019) | Task 1a (checksum chain), Task 3 (eval hardening) | Full | None |
| 2.3 Gates (REQ-PCG-020, 021, 022) | Task 1a (gate count, force_route, integrity clarification), Task 1c (test counts), Task 4 (companion doc) | Full | None |
| 2.4 Structured Results (REQ-PCG-023) | Task 1a (fail loud for provenance) | Full | None |
| 2.5 Handoff Contract (REQ-PCG-024, 025) | Task 1a (filenames, artifact set), Task 1d (A2A vs propagation distinction) | Partial | BoundaryValidator hydration adapter deferred to Phase 2; schema_version compatibility check at handoff (R10-S4 accepted but not in plan tasks) |
| 2.6 Contractor Execution (REQ-PCG-026, 027) | Task 1c (complexity bounds, gap exclusions) | Partial | ASSESS determinism requirements (R4-S4) not specified; REQ-PCG-027 req 6 conflates implementation with requirements (R4-F2) |
| 2.7 Observability (REQ-PCG-028, 029) | Not explicitly in plan | None | No plan task addresses dashboard or TraceQL query updates. Accepted R3-S8 (test harness for observability) has no corresponding plan task |
| 3.0 Cross-Cutting (REQ-PCG-030, 031, 032) | Task 1d (REQ-PCG-033 non-goal), Task 1f (REQ-PCG-034, 035) | Partial | Multi-domain aggregation semantics (accepted R9-S3) not reflected in a plan task; span event schema updates for new gate checks not addressed |
| NFRs (001-005) | Task 3 (eval hardening for NFR-004) | Partial | NFR-001 "zero overhead" measurability (accepted R9-S5) not in plan; NFR-005 idempotency vs mutation conflict (R10-S2 accepted) not resolved in plan; concurrent run isolation (R7-S9 accepted) has no plan task |
| Part 4 Extension Concerns | Task 1 (traceability additions) | Partial | Prerequisite core REQ mapping (accepted R7-S7) referenced but no specific plan task creates the mapping |

#### Review Round R5

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-19 20:20:04 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R5-S1 | scalability | critical | Add requirements for pipeline-scoped artifact namespacing and isolation to prevent cross-run interference at scale | REQ-PCG-019 recomputes checksums from files and REQ-PCG-014 stores provenance inline, but no requirement specifies run-scoped artifact paths. Accepted R7-S9 identified concurrent run risks, but the plan only defers to Phase 2 without specifying the isolation primitive. At scale (multiple teams, multiple projects, CI parallelism), shared filesystem paths (`onboarding-metadata.json`, `run-provenance.json`) become contention points. Without run-scoped namespacing (e.g., `{project}/{run_id}/`), checksum gates will produce false failures under load. This is distinct from R7-S9's concurrency concern — it's about the fundamental artifact addressing model that enables horizontal scaling. | New requirement REQ-PCG-036 in Part 3 (Cross-Cutting): "Pipeline artifacts MUST be written to run-scoped paths (`{project}/{run_id}/`) to enable concurrent execution. Gate checks MUST resolve artifact paths relative to the run scope, not a global project directory." | Integration test: launch two pipeline runs for the same project concurrently; verify both complete without checksum interference; verify each run's provenance chain references its own artifact paths |
| R5-S2 | scalability | high | Specify contract validation caching strategy for repeated boundary checks on unchanged context within a single run | REQ-PCG-009 validates at every phase boundary and the plan correctly identifies 7 phases × (entry + exit + enrichment) validation points. However, with 7 contract domains each running at every boundary, the total validation count is ~7 domains × ~20 boundaries = ~140 validation invocations per run. Many of these will re-validate unchanged fields. No requirement or plan task addresses whether validation results can be cached within a run when the relevant context subset hasn't changed. As contract adoption grows (REQ-PCG-016 progressive adoption), the cumulative cost becomes a scalability bottleneck. Accepted R7-S2 identified the need for a time budget but not a caching mechanism to stay within it. | New sub-requirement under REQ-PCG-009 or NFR section: "Validation results for unchanged context subsets MAY be cached within a pipeline run. Cache MUST be invalidated when the validated context subset is mutated (including default injection per REQ-PCG-013). Cache key MUST include context hash + contract version." | Benchmark: compare validation latency for a 7-phase pipeline with and without caching; verify cache invalidation on context mutation |
| R5-S3 | scalability | high | Add requirements for contract YAML composition and modular loading to support multi-team, multi-domain scaling | REQ-PCG-015 requires a single `contract_path` parameter and REQ-PCG-016 supports progressive adoption, but no requirement addresses how contracts scale when multiple teams own different domains for the same pipeline. A single monolithic contract YAML becomes a merge-conflict hotspot and prevents domain-independent evolution. The plan's Task 1 applies accepted suggestions but doesn't address the structural scaling of contract declarations. With 7 core domains + 9 extensions, a single file is architecturally insufficient. | New sub-requirement under REQ-PCG-015: "Contract declarations MUST support multi-file composition. `contract_path` MAY reference a directory, in which case all `*.contract.yaml` files MUST be loaded and merged by domain. Conflicting declarations across files for the same field MUST produce a parse-time error with file paths for both declarations." | Test: place Domain 1 contract in `propagation.contract.yaml` and Domain 6 contract in `budget.contract.yaml` in the same directory; verify both are loaded and validated; verify conflicting field declarations produce parse-time error |
| R5-S4 | security | critical | Require cryptographic integrity verification of contract YAML files before parsing to prevent supply-chain tampering | The plan's Task 3 hardens eval() expressions within contracts but doesn't address the trust chain for the contract YAML files themselves. REQ-PCG-015 says contracts are "reviewed in PRs alongside code" and NFR-PCG-004 assumes "trusted sources," but no requirement verifies that the contract YAML loaded at runtime matches what was reviewed and merged. A compromised filesystem, CI cache poisoning, or artifact registry tampering could substitute malicious contract YAML that passes AST validation but weakens enforcement (e.g., changing BLOCKING to ADVISORY). Accepted R8-S2/R12-S5 address expression-level safety but not file-level integrity. | New NFR or sub-requirement under REQ-PCG-015: "Contract YAML files MUST be integrity-verified before parsing. Integrity verification MUST use either (a) a checksum manifest committed alongside contracts and verified at load time, or (b) filesystem-level integrity (read-only mount, signed artifacts). The loader MUST reject contracts that fail integrity verification with a BLOCKING GateResult." | Test: modify a contract YAML after checksum manifest generation; verify loader rejects the tampered file; test with valid checksum; verify loading succeeds |
| R5-S5 | security | high | Require that the AST allowlist for verification expressions (Task 3) also prohibits string formatting operations that could leak context values into logs | The plan's Task 3 implements an AST allowlist for eval() safety but focuses on code execution prevention (Import, Call, deep Attribute access). However, f-strings and `str.format()` within verification expressions could be used to exfiltrate context values into span event messages or error envelopes. With accepted R8-S3 adding `sensitive=True` fields, a verification expression like `f"{context['auth.token']}"` would bypass the sensitive field protection by embedding the value in the expression result. This is a second-order interaction between the expression safety hardening (Task 3) and the sensitive field protection (R8-S3). | Task 3 implementation in `_validate_expression()`: add `JoinedStr` (f-string) and `FormattedValue` to prohibited AST nodes; add `Call` nodes where func is `format` to rejection list. Add to NFR-PCG-004 text: "Verification expressions MUST NOT contain string formatting operations (f-strings, .format()) to prevent sensitive value exfiltration." | Test: verification expression containing f-string referencing a sensitive field is rejected at parse time; test with non-formatting string operations (comparison, len) passes |
| R5-S6 | testability | high | Add property-based test requirement for contract validation to verify compositional correctness across domain combinations | The verification plan (updated by accepted suggestions) has per-domain unit tests and an accepted E2E integration test (R11-S10), but no requirement addresses combinatorial testing of domain interactions. With 7 domains × 3 severity levels × 3 lifecycle stages, the state space is large. Property-based testing (e.g., Hypothesis) can systematically explore domain combinations that manual test design would miss — for example, verifying that enabling Domain 6 (budget) never changes the pass/fail outcome of Domain 1 (propagation) checks when both are present. This addresses the accepted R7-S3/R9-S3 aggregation semantics by verifying the aggregation is correct across random domain combinations. | Verification Plan — add a property-based testing entry: "Contract validation MUST be verified via property-based tests (Hypothesis or equivalent) that generate random combinations of domain contracts, field severities, and context states, asserting: (a) domain independence (enabling domain X doesn't change domain Y's result), (b) severity monotonicity (promoting a field from ADVISORY to BLOCKING never converts a halt into a pass), (c) aggregation correctness (composite result is worst-of-all-domains)." | Hypothesis test suite generating 1000+ random contract/context combinations; verify all three properties hold; report any counterexamples as failing tests |
| R5-S7 | testability | high | Require contract validation dry-run mode that reports what WOULD happen without mutating context or emitting OTel events | Accepted R12-S1 identified the contradiction between REQ-PCG-013 (context mutation) and NFR-PCG-005 (no side effects). The plan resolves this by clarifying that default injection is a "defined effect," but this means operators cannot preview validation results without triggering mutations and telemetry. For debugging, progressive adoption (REQ-PCG-016), and the "declaration only" stage, a dry-run mode that reports validation outcomes without side effects is essential. This also directly supports testability — dry-run results can be compared against actual results to verify mutation correctness. | New sub-requirement under REQ-PCG-016 (Progressive Adoption) or REQ-PCG-009 (Runtime Boundary Checks): "The contract validation system MUST support a `dry_run=True` mode that evaluates all contracts and returns `ValidationResult` objects without mutating the context dict, emitting OTel events, or stamping provenance. Dry-run results MUST be identical to actual results except for mutation side effects." | Test: run validation in dry-run mode; verify context dict is unmodified; verify returned ValidationResult matches actual-mode result for the same input |
| R5-S8 | testability | medium | Add chaos/fault-injection test requirement for the contract system itself — not just pipeline artifacts | Accepted R2-S4 added REQ-PCG-034 for generic failure injection of contract types and gates, but this tests the pipeline's response to injected failures. No requirement tests the contract system's own resilience: what happens when the contract YAML is syntactically valid but semantically pathological (circular propagation chains, self-referencing waypoints, chains that reference non-existent phases)? The plan's Task 3 hardens expressions but not the contract graph topology. A malformed contract graph could cause infinite loops in chain validation or stack overflows in recursive waypoint resolution. | New verification entry or sub-requirement under REQ-PCG-034: "Fault injection testing MUST include pathological contract topologies: circular propagation chains, self-referencing waypoints, chains referencing non-existent phases, and contracts with maximum-depth nesting. The contract loader MUST detect and reject these at parse time with structured errors." | Test suite with 5+ pathological contract YAML files; verify each is rejected at parse time (not at runtime during validation); verify error messages identify the specific structural problem |
| R5-S9 | security | medium | Require that the `_cc_propagation` provenance dict is read-only to pipeline handlers via a frozen view or copy-on-read pattern | REQ-PCG-014.3 states "Handlers MUST NOT overwrite the `_cc_propagation` key (the `_cc_` prefix signals 'internal, do not touch')" but this is enforced by convention, not mechanism. Any handler with access to the context dict can mutate `_cc_propagation` — deleting entries, changing hashes, or injecting false provenance. Accepted R8-S6 adds BypassEvent for intentional overrides, but no mechanism prevents accidental or malicious provenance tampering by handlers. Given that provenance is the audit backbone (REQ-PCG-007, REQ-PCG-022 Gate 3), its integrity should be mechanically enforced, not just documented. | New sub-requirement under REQ-PCG-014: "The `_cc_propagation` dict MUST be exposed to handlers as a read-only view (e.g., `types.MappingProxyType`). Mutations MUST only be possible through the `PropagationTracker.stamp()` API. Direct mutation attempts MUST raise `TypeError`." | Test: handler attempts to directly modify `_cc_propagation`; verify TypeError is raised; verify `PropagationTracker.stamp()` still succeeds; verify read access works normally |
| R5-S10 | scalability | medium | Revisiting R4-S4 (rejected): Financial budget propagation is now architecturally necessary given accepted R4-F3 generalizing BudgetPropagationSpec to multiple budget types | R4-S4 was rejected as "a new feature requirement rather than a gap" with the note that "the companion REQ_CAPABILITY_DELIVERY_PIPELINE.md handles cost budget at the pipeline orchestration level." However, accepted R4-F3 explicitly generalizes `BudgetPropagationSpec` to support "multiple budget units (Time, Tokens, Cost)." This acceptance changes the context: if the spec NOW supports cost budgets, the requirement must specify how cost budget data flows through the propagation chain (remaining_budget_usd at each boundary, DEGRADED when a phase exceeds its cost allocation). Without this, R4-F3 is an empty generalization — the spec supports cost budgets but no requirement defines cost budget propagation semantics. The original rejection rationale ("belongs in Part 4 or companion doc") no longer applies because R4-F3 brought cost budgets into the core domain spec. | REQ-PCG-006 — add sub-requirements for cost/token budget propagation semantics now that BudgetPropagationSpec is generalized: "When `budget_unit` is `cost` or `tokens`, the tracker MUST stamp `remaining_budget_{unit}` at each boundary. Cost budgets MUST use the same DEGRADED/BROKEN thresholds as time budgets." | Test: configure a cost-type budget with per-phase allocations; verify DEGRADED fires when a phase exceeds allocation; verify BROKEN fires when remaining goes negative |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R5-F1 (scalability, R19 checksums): The observation that "recomputed from actual files" implies filesystem dependency is valid — clarifying to support byte streams enables in-memory pipeline architectures and is consistent with my R5-S1 run-scoped namespacing suggestion.
- R5-F2 (maintainability, R23 error codes): A centralized `GateErrorCode` enum prevents arbitrary string proliferation as the number of gates and domains grows — this is especially important given the 8 Gate 1 checks + Gate 2 + Gate 3 all producing `GateResult` objects.
- R4-F1 (clarity, REQ-PCG-001): The undefined "waypoint" term is a real ambiguity that affects chain verification implementation — the suggested definition is precise and testable.
- R4-F4 (testability, REQ-PCG-012): The contract-regression-allowlist mechanism for intentional completeness decreases is essential for real-world refactoring scenarios and directly complements the accepted R3-S7 baseline definition.

#### Feature Requirements Suggestions

| ID | Area | Severity | Requirement Section | Issue | Suggested Fix |
| ---- | ---- | ---- | ---- | ---- | ---- |
| R5-F1 | security | high | REQ-PCG-024 Req 5 | `source_checksum` is verified against `.contextcore.yaml` but no requirement specifies WHO computes the initial checksum or how it is protected from tampering between Stage 0 (CREATE) and Stage 4 (EXPORT). If Stage 0 computes the checksum but a compromised Stage 1.5 (FIX) modifies `.contextcore.yaml` without updating the checksum, the entire chain is silently broken. The checksum origin and update protocol across stages 0-4 is unspecified. | Add: "The `source_checksum` MUST be recomputed at each ContextCore stage that modifies `.contextcore.yaml`. The recomputation MUST be performed by the stage runner (not the handler), ensuring handlers cannot bypass checksum updates. The provenance chain MUST record each recomputation with the stage that triggered it." |
| R5-F2 | scalability | high | REQ-PCG-001 Req 1 | Contract YAML requires `pipeline_id` as a top-level field, but no requirement addresses how contracts are scoped when a single project has multiple pipelines (e.g., dev vs. staging vs. production) that share some but not all contract declarations. Without pipeline-scoped contract inheritance or composition, teams must duplicate entire contract files per pipeline, creating maintenance burden at scale. | Add: "Contract YAML MAY declare `extends: {base_contract_path}` to inherit field declarations from a base contract. Extended contracts MUST be able to override severity levels (promotion only: ADVISORY→WARNING→BLOCKING) and add new fields. Severity demotion in extensions MUST be rejected at parse time." |
| R5-F3 | testability | high | REQ-PCG-010 Req 2 | `context.propagation_summary` emits `completeness_pct` but the calculation method is not specified. Is it `intact_chains / total_chains * 100`? Does it weight chains by severity? A chain with all BLOCKING fields that is DEGRADED should arguably reduce completeness more than a chain with all ADVISORY fields. Without a formula, two implementations could produce different percentages for identical chain results. | Specify: "`completeness_pct` MUST be calculated as `(intact_count / total_chains) * 100`, rounded to one decimal place. DEGRADED and BROKEN chains are both counted as not-intact. Severity-weighted completeness MAY be emitted as an additional attribute `weighted_completeness_pct` but is not required for Phase 1." |
| R5-F4 | security | medium | REQ-PCG-018 Req 5 | `ValidationErrorEnvelope` includes `failed_path` which could expose internal schema structure to callers. Combined with accepted R3-F3 (no filesystem paths in envelopes), the requirement still doesn't address whether `failed_path` values like `$.handoff.auth.scopes` reveal contract structure that an attacker could use to craft targeted bypass payloads. | Add: "Error envelopes MUST NOT include contract schema paths that reveal enforcement structure (e.g., which fields are BLOCKING vs ADVISORY). `failed_path` MUST reference the payload structure, not the contract structure. A separate `contract_evidence` field MAY be included in internal (non-returned) audit logs." |
| R5-F5 | completeness | medium | REQ-PCG-027 Req 4 | "IMPLEMENT MUST use `parameter_sources` and `resolved_artifact_parameters` from onboarding metadata" — but no requirement specifies fallback behavior when `resolved_artifact_parameters` is empty or contains unresolvable references. Gate 1 check #7 (parameter resolvability) is non-blocking (warning only), meaning IMPLEMENT can receive unresolved parameters. The requirement should specify whether IMPLEMENT halts, uses defaults, or emits DEGRADED status for unresolved parameters. | Add: "When `resolved_artifact_parameters` contains unresolved references (marked by Gate 1 check #7 warning), IMPLEMENT MUST emit a WARNING-severity span event per unresolved parameter and MUST use the raw `parameter_sources` expression as a string placeholder. The finalize report MUST flag artifacts generated with unresolved parameters." |

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| ---- | ---- | ---- | ---- |
| 1.1 Theoretical Foundation | N/A (conceptual) | Full | No implementation needed — foundational rationale |
| 1.2 REQ-PCG-001 (Propagation) | Task 1c (R3-S1 complexity bounds), Task 3 (expression safety) | Full | Expression safety hardening directly covers verification expressions in propagation chains |
| 1.2 REQ-PCG-002 (Schema Compat) | Task 2 (matrix update) | Full | Status corrected from D to Y* |
| 1.2 REQ-PCG-003 (Semantic Conv) | Task 1a (R3-S3 status fix), Task 2 | Full | Status clarified as partial |
| 1.2 REQ-PCG-004 (Causal Ordering) | Task 1a (R3-S3 status fix), Task 2 | Partial | Clock skew concern (R5-S2 accepted) not addressed in plan; plan defers cross-host timestamp issues |
| 1.2 REQ-PCG-005 (Capability) | Task 1a (R3-S3 status fix), Task 2 | Full | Status corrected |
| 1.2 REQ-PCG-006 (SLO Budget) | Task 1c (R3-S10 testable criteria), Task 2 | Partial | Accepted R4-F3 (multi-budget generalization) and R6-S4 (exec vs wall time) not reflected in plan tasks; R8-S8 (cleanup budget reservation) accepted but no plan task |
| 1.2 REQ-PCG-007 (Lineage) | Task 2 (matrix update) | Partial | Accepted R7-S5 (replace repr() with canonical serialization) and R12-S4 have no plan task for code change; accepted R8-S7 (pruning strategy) has no plan task |
| 1.3 REQ-PCG-008 (Pre-Flight) | Task 1a (R1-S4 bypass fix), Task 1c (R1-S5 test counts) | Full | Bypass mechanism specified, test counts added |
| 1.3 REQ-PCG-009 (Runtime) | Task 1d (R4-S2 contract distinction) | Full | Backward compat clarified |
| 1.3 REQ-PCG-010 (Post-Exec) | Task 1c (test counts) | Full | Test counts added |
| 1.3 REQ-PCG-011 (Observability) | Task 1c | Partial | Accepted R3-S8 (test harness specification) acknowledged but deferred — plan says "24 query validation tests" without connecting to specific requirements |
| 1.3 REQ-PCG-012 (Regression) | Task 1f (R1-S10 versioning placeholder) | Partial | Accepted R3-S7 (baseline definition) explicitly deferred to Phase 2; accepted R4-F4 (regression allowlist) has no plan task |
| 1.4 REQ-PCG-013 (Severity) | Task 1c (R3-S10), Task 1d (R4-S6 provenance stamping) | Full | Default injection provenance specified |
| 1.5 REQ-PCG-014 (Provenance) | Task 1d (R4-S9 seed stages) | Partial | Accepted R7-S5/R12-S4 (replace repr()) has no implementation task in plan; accepted R5-S9 (Stage 1.5 re-stamping) has no plan task; accepted R8-S3 (sensitive fields) has no plan task |
| 1.6 REQ-PCG-015 (Dual-Declaration) | Task 1e (sandbox constraints) | Partial | Accepted R5-S5 (`_cc_propagation` vs `extra="forbid"` reconciliation) has no explicit plan task |
| 1.6 REQ-PCG-016 (Progressive Adoption) | Task 1f (R1-S10 placeholder) | Partial | Accepted R4-F1 (graduation criteria) has no plan task |
| 2.1 REQ-PCG-017 (A2A Contracts) | Task 1f (R1-S10 versioning) | Partial | Accepted R12-S6 (runtime version compat check) has no plan task |
| 2.2 REQ-PCG-018 (Boundary Enforcement) | No explicit task | Partial | Accepted R3-F3 (sensitive field redaction in envelopes) has no plan task |
| 2.2 REQ-PCG-019 (Checksums) | Task 1a (Gate 1 count), Task 4 | Partial | Accepted R12-S3 (file canonicalization) has no plan implementation task — only document correction |
| 2.3 REQ-PCG-020 (Gate 1) | Task 1a (R1-S1 + R4-S1), Task 4 | Full | Check count corrected to 8, gap parity fixed |
| 2.3 REQ-PCG-021 (Gate 2) | Task 1c (R3-S1, R4-S3) | Full | Complexity bounds defined, force_route accounted for |
| 2.3 REQ-PCG-022 (Gate 3) | Task 1a (R1-S2 status), Task 1c (R4-S8 integrity clarification) | Full | Status added, checksum semantics clarified |
| 2.4 REQ-PCG-023 (Structured Results) | Task 1a (R2-S5 fail-loud) | Full | Fail-loud principle enforced for provenance |
| 2.5 REQ-PCG-024 (Handoff) | Task 1a (R4-S7 filename), Task 1b (R1-S8 required/optional), Task 1d (R2-S3 artifact set) | Full | Filename, field annotations, and artifact set defined |
| 2.5 REQ-PCG-025 (Cross-Boundary) | Task 1d (R4-S2 distinction) | Partial | Accepted R3-S2 (hydration adapter) deferred to Phase 2; accepted R12-S6 (version compat) has no plan task |
| 2.6 REQ-PCG-026 (Plan Ingestion) | Task 1c (R3-S1 complexity), Task 1f (R1-S9 gap exclusions) | Full | Complexity defined, exclusions added |
| 2.6 REQ-PCG-027 (Artisan Workflow) | No explicit task | Partial | Accepted R1-F5 (partial phase success semantics) has no plan task |
| 2.7 REQ-PCG-028 (A2A Dashboard) | No explicit task | Partial | Accepted R3-S8 (test harness) acknowledged but deferred |
| 2.7 REQ-PCG-029 (Propagation Dashboard) | No explicit task | Partial | Accepted R4-F3 (per-pipeline dashboard scoping) has no plan task |
| 3.0 REQ-PCG-030 (Contracts vs Events) | No explicit task | Full | Accepted R4-F5 (structured diagnostic events clarification) covers the taxonomy gap |
| 3.0 REQ-PCG-031 (OTel Schema) | No explicit task | Full | Schema consistency addressed by multiple accepted suggestions |
| 3.0 REQ-PCG-032 (Design Calibration) | No explicit task | Full | No plan changes needed — requirement is self-contained |
| NFR-PCG-001 (Zero Overhead) | No explicit task | Partial | Accepted R9-S5 (measurable threshold) has no plan task to redefine "zero" |
| NFR-PCG-002 (Graceful Degradation) | Task 1d (R4-S2) | Partial | Accepted R6-S5 (fail-closed for safety contracts) and R10-S1 (Gate 1 bypass for minimal installs) have no plan tasks |
| NFR-PCG-004 (Expression Safety) | Task 3 | Full | AST allowlist implementation covers accepted R1-S6, R3-S6, R8-S2, R12-S5 |
| NFR-PCG-005 (Idempotency) | No explicit task | Partial | Accepted R12-S1 (mutation vs side-effect contradiction) and R10-S2 (default re-run semantics) have no plan resolution task |
| Part 4 (Extensions) | No explicit task | Full | Out of scope per document; accepted R5-S7/R7-S7 traceability additions are document-only |

#### Review Round R6
- **Reviewer**: gemini-3 (gemini-3-pro-preview)
- **Date**: 2026-02-19 20:22:41 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R6-S1 | scalability | medium | Implement "Provenance Snapshotting" to prevent linear context growth in `_cc_propagation`. | REQ-PCG-007 requires provenance to travel with data. In long pipelines or loops, the `_cc_propagation` dict grows linearly, potentially exceeding transport limits (e.g., HTTP headers) or memory budgets. Snapshotting allows offloading older history to storage and carrying a reference hash. | REQ-PCG-007, new requirement for snapshot/offload mechanism | Run a pipeline loop 10,000 times; verify context size remains bounded O(1) while full lineage is reconstructible from storage. |
| R6-S2 | security | high | Require output sanitization (truncation/escaping) for all user-derived data in `GateResult` error messages. | REQ-PCG-018 returns `failed_path` and `message`. If input is malicious (e.g., control characters, huge strings), echoing it back in the error envelope facilitates log injection attacks or DoS via error amplification. | REQ-PCG-018, new requirement for safe error construction | Fuzz validator with malicious strings; verify `GateResult` output is sanitized and truncated. |
| R6-S3 | testability | high | Mandate property-based testing (fuzzing) for `BoundaryValidator` implementations. | Unit tests cover known edges. Validators must be robust against random garbage to prevent crashes (DoS) or fail-open behaviors. REQ-PCG-018 implies robustness but doesn't require the testing methodology to ensure it. | Verification Plan for REQ-PCG-018 | Add a test suite using `hypothesis` to fuzz `validate_boundary` with random JSON structures. |
| R6-S4 | testability | medium | Add a "Telemetry Contract Validator" requirement to the test harness to verify OTel emission compliance. | REQ-PCG-011 and REQ-PCG-031 define a strict schema for spans/attributes. Without automated verification, implementation drift will silently break dashboards (REQ-PCG-028). Visual verification is insufficient for regression prevention. | REQ-PCG-031, new requirement for automated telemetry validation | Integration test: Capture emitted spans in memory, validate against `Semantic Conventions` schema, fail build on attribute mismatch. |
| R6-S5 | security | critical | Implement an "Anti-Tamper Root of Trust" check for the contract definition files. | REQ-PCG-019 checks `source_checksum` against `.contextcore.yaml`. If an attacker modifies both in a PR, the check passes. A requirement to verify the root contract against a trusted baseline (e.g., `main` branch) or a signature is needed to prevent governance bypass. | REQ-PCG-019, new requirement for root trust verification | CI test: Attempt to modify `.contextcore.yaml` and its checksum in a single PR; verify CI blocks unless authorized/signed. |
| R6-S6 | scalability | medium | Require caching of compiled contract models (regex, ASTs) to minimize validation overhead. | REQ-PCG-012 implies high-frequency validation. Parsing complex YAML and compiling verification expressions is CPU intensive. Lack of caching requirements threatens the "zero overhead" (or low overhead) goals. | NFR-PCG-001 (or new scalability NFR) | Benchmark validation loop with and without caching; assert <10% CPU overhead for repeated validations. |
| R6-S7 | security | medium | Explicitly forbid recursive anchors/aliases in Contract YAML ("Billion Laughs" protection). | YAML parsers are often vulnerable to entity expansion attacks. Since contracts are parsed in CI (REQ-PCG-012), a malicious contract could DoS the build infrastructure. | REQ-PCG-015, new constraint on YAML subset | Test: Submit a YAML with nested recursive anchors; verify loader rejects it immediately. |
| R6-S8 | scalability | medium | Generalize `BudgetPropagationSpec` to support "Budget Leasing" for async/long-running phases. | REQ-PCG-006 tracks budget per phase sequentially. For phases involving human review (Stage 6) or external builds, the wall-clock budget will always break. A "leasing" or "pause" mechanism is required to track active compute time vs. elapsed time. | REQ-PCG-006 | Simulate an async phase that sleeps for 1 hour but uses 1s compute; verify budget is not exhausted. |
| R6-S9 | completeness | medium | Define a "Cleanup Contract" to ensure atomicity of artifact generation on pipeline abort. | If a pipeline halts due to Gate failure (REQ-PCG-020) or Budget exhaustion (REQ-PCG-006), partially written artifacts may corrupt state. A cleanup requirement ensures the output directory is left in a deterministic state. | REQ-PCG-027 (or new cross-cutting req) | Run pipeline, trigger mid-generation failure; verify output directory contains no partial files. |
| R6-S10 | clarity | low | Generalize "DEGRADED" and "BROKEN" status definitions for non-propagation domains. | REQ-PCG-001 defines these for Propagation. It is unclear what "DEGRADED" means for *Schema Compatibility* or *Causal Ordering*. Explicit definitions per domain prevent implementer ambiguity. | Section 1.2 (per domain) | Review: Ensure each domain spec includes specific criteria for status levels. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R12-S1: The conflict between mutation (applying defaults) and idempotency is a critical logical flaw that must be resolved for deterministic behavior.
- R12-S5: Unconditional removal of `eval()` is the only robust security stance; "trusted sources" is operationally unenforceable in modern CI.
- R11-S1: Lack of a versioning strategy is a "ticking time bomb" for maintenance; addressing it now prevents a future rewrite.

#### Feature Requirements Suggestions
| ID | Area | Severity | Requirement Section | Issue | Suggested Fix |
| ---- | ---- | ---- | ---- | ---- | ---- |
| R6-F1 | scalability | medium | REQ-PCG-007 | Linear growth of `_cc_propagation` context dict is a scalability risk for long pipelines. | Add requirement for provenance snapshotting/offloading when size exceeds threshold. |
| R6-F2 | security | high | REQ-PCG-018 | Error envelopes returning unsanitized input (`failed_path`, `message`) create log injection/XSS risks. | Add requirement: "Error envelope fields MUST be sanitized and truncated." |

#### Requirements Coverage
| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| :--- | :--- | :--- | :--- |
| **1.1 Theoretical Foundation** | Task 1 | Full | None |
| **1.2 Contract Domains (1-7)** | Task 1, 2 | Partial | Lifecycle wiring confirmed, but E2E integration pending (Phase 2). |
| **1.3 Lifecycle (Pre/Run/Post)** | Task 1 | Full | Corrections applied to reflect actual code status. |
| **1.4 Severity Model** | Task 1 | Full | None |
| **1.5 Provenance** | Task 1, 4 | Partial | Snapshotting for scalability missing (R6-S1). |
| **1.6 Contract Declaration** | Task 1 | Full | None |
| **2.1 Contract Types** | Task 1 | Full | None |
| **2.2 Boundary Enforcement** | Task 1 | Full | None |
| **2.3 Gates (1-3)** | Task 1, 4 | Full | Gate 1 count reconciled (8 checks). Gate 3 status added. |
| **2.4 Fail Loud** | Task 1 | Full | Malformed provenance now fails loud. |
| **2.5 Handoff** | Task 1 | Full | Artifact list defined. |
| **2.6 Contractor Exec** | Task 1 | Full | None |
| **2.7 Observability** | Task 1 | Partial | Telemetry contract validation missing (R6-S4). |
| **3. Cross-Cutting** | Task 1, 3 | Partial | `eval()` hardening added. Versioning strategy deferred. |

#### Review Round R7

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-19 20:39:45 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R7-S1 | architecture | critical | The plan's Task 3 AST allowlist for eval() hardening rejects `Call` nodes except for an allowlist (`len`, `str`, `int`, `float`, `bool`, `isinstance`), but verification expressions in `PropagationChainSpec` may legitimately need `context.get("field", "")` — `dict.get()` is a method call on an attribute, which would be rejected by both the "Call except allowlisted" and "Attribute access beyond one level" rules. The allowlist must account for method calls on allowed variables, not just top-level builtins. | The plan's Task 3 implementation spec will break existing verification expressions that use `context.get()`, `source.get()`, or `dest.get()`. These are the most natural Python expressions for safe dictionary access and are likely already in use given the sandbox exposes `context`, `source`, `dest` as variables. The rule should be: allow `Call` on methods of the three allowed variables (`.get`, `.keys`, `.values`, `.items`) plus the listed builtins, and reject all other `Call` nodes. | Task 3 implementation spec — refine the AST allowlist to include method calls on `context`/`source`/`dest` variables | Unit test: `context.get("field", "")` passes validation; `context.__class__.__bases__` is rejected; `context.get("f", "").upper()` is rejected (chained method call beyond one level) |
| R7-S2 | completeness | high | The plan defers schema versioning (R1-S10) to Phase 2 as REQ-PCG-035, but Task 1a simultaneously applies R5-S5 (reconciling `_cc_propagation` with `extra="forbid"`) without specifying the resolution. The plan must state whether `_cc_propagation` is declared as an explicit field in the Pydantic model or stripped before validation, since this decision constrains the Phase 2 versioning strategy. | R5-S5 was accepted but the plan doesn't specify the chosen resolution — only that the reconciliation should happen. If `_cc_propagation` is added to the model, it becomes part of the schema contract (affecting v2 design). If it's stripped before validation, the stripping logic must be specified. Deferring the versioning strategy is fine, but the `_cc_propagation` handling must be decided now because it changes the model definition in Phase 1 code. | Task 1d (Architecture Clarifications) — add explicit decision for R5-S5 resolution | Verify that context dicts with `_cc_propagation` pass through handoff boundary validation without error; verify the chosen approach is documented |
| R7-S3 | security | high | Task 3's 1-second timeout on eval() is specified but no requirement or implementation note addresses what happens when the timeout fires. Does the chain status become BROKEN? Does the pipeline halt? Is the timeout exception caught and converted to a GateResult? Without specifying the timeout failure mode, the hardening is incomplete — a caught-and-ignored timeout is equivalent to no timeout. | The timeout wrapper is listed as an implementation step but the behavioral contract is missing. This is a second-order gap from the eval() hardening: the AST allowlist prevents malicious expressions at parse time, but the timeout handles expressions that are syntactically valid but computationally expensive (e.g., deeply nested legitimate expressions). The failure mode must produce a BROKEN chain status with `reason: "verification expression timed out"` and `next_action: "simplify expression or increase timeout"`. | Task 3 implementation spec and REQ-PCG-001 (add requirement 8 per R11-S6 about exception handling during verification) | Test: verification expression with intentional slow computation (within AST allowlist) triggers timeout; verify BROKEN status with timeout reason in chain event |
| R7-S4 | testability | high | The plan claims "all 7 contract domains have full lifecycle wiring" and proposes changing the matrix from D to Y*, but provides no verification method for this claim beyond "end-to-end integration pending validation (Phase 2)." The plan should include a specific smoke test in Phase 1 that invokes each domain's lifecycle hooks to confirm they are actually wired, not just that the code files exist. | The plan's key discovery ("code is significantly more complete than documented") could itself be inaccurate. The difference between "lifecycle wiring code exists" and "lifecycle wiring works correctly" is significant. Promoting 5 domains from D to Y* based on code exploration without running domain-specific lifecycle tests creates the same false confidence the plan criticizes. A minimal smoke test (invoke preflight/runtime/postexec for each domain with a trivial contract) would validate the claim at negligible cost. | Task 2 verification — add a concrete validation step before updating the matrix | For each of the 5 domains currently at D, run: `validate_phase_boundary()` with a minimal contract referencing that domain at preflight, runtime, and postexec stages; assert non-None result |
| R7-S5 | architecture | medium | The plan applies R6-S3 (reconcile inline `_cc_propagation` with external `run-provenance.json` at Gate 1) but doesn't address the write-side: no requirement specifies which stage is responsible for *generating* `run-provenance.json` from `_cc_propagation` or vice versa. Gate 1 can only reconcile if both artifacts are produced consistently by a defined stage. | R6-S3 adds a verification check but the production pathway is unspecified. If `_cc_propagation` is the source of truth (per REQ-PCG-014) and `run-provenance.json` is derived from it, which stage performs the derivation? If they're independently produced (provenance tracker stamps `_cc_propagation`, export stage writes `run-provenance.json` from a different data source), reconciliation failures are expected rather than anomalous. The plan needs to specify the data flow direction. | Task 1a or 1d — add a note to the R6-S3 reconciliation check specifying which artifact is authoritative and how the other is derived | Trace the code path that produces run-provenance.json; verify it reads from _cc_propagation (or document why they diverge) |
| R7-S6 | completeness | medium | The plan's Task 1c applies R3-S1 (complexity score bounds: "at least 2 of 7 dimensions differ by ≥10 points; std dev > 5") but doesn't address the interaction with R6-S6 (ASSESS determinism). If ASSESS uses LLM-based scoring, the std dev check could flap across runs. The plan should specify whether the concrete bounds apply to the scoring *algorithm output* or to a *deterministic scoring function* — and if the former, whether flapping scores are acceptable for Gate 2. | R3-S1 and R6-S6 were both accepted but create a tension: concrete score bounds require deterministic scores to be meaningful as a gate check. If ASSESS is non-deterministic (LLM-based), the same input could pass Gate 2 on one run and fail on the next. The plan should note this interaction and either require deterministic ASSESS or specify that Gate 2's score reasonableness check runs on the *stored* score (assessed once, checked once) rather than re-assessing. | Task 1c where R3-S1 is applied — add note about determinism requirement or clarify that the check operates on the single stored assessment result | Test: run ASSESS twice on identical input; if scores differ, verify Gate 2 operates on the stored score from the first run, not a re-assessment |
| R7-S7 | maintainability | medium | The plan applies 33 suggestions to a single document in one task (Task 1 with sub-sections 1a-1f), creating a single massive commit that will be difficult to review and impossible to partially revert. If any sub-section introduces an error, the entire Task 1 must be re-reviewed. The plan should split Task 1 into independently committable sub-tasks. | With ~200 lines of document edits touching factual fixes, traceability, precision, architecture, security, and new requirements simultaneously, a single commit conflates unrelated changes. This is a standard software engineering concern: atomic commits enable bisection, targeted review, and safe partial rollback. Sub-tasks 1a through 1f are already well-defined and could be individual commits. | Task 1 — restructure as 6 independent sub-commits (1a through 1f), each reviewable and revertable independently | Each sub-commit passes document consistency checks (no broken cross-references) and can be cherry-picked independently |
| R7-S8 | completeness | medium | The plan lists R5-S9 (provenance re-stamping for Stage 1.5 FIX auto-remedy) as an accepted suggestion but doesn't include it in any Task 1 sub-section. Neither Task 1a (factual fixes) nor Task 1d (architecture clarifications) mentions Stage 1.5 provenance behavior. The suggestion is accepted but not planned for implementation. | Scanning the applied suggestions list: R5-S9 is in Appendix A. R9-S10 (also accepted) explicitly requires Stage 1.5 contract enforcement. R7-S6 (accepted) clarifies Stage 1.5 governance posture. All three are accepted but none appear in the Task 1 change list. This is a plan completeness gap — accepted suggestions that are not reflected in any task. | Task 1d (Architecture Clarifications) — add items for R5-S9, R9-S10, and R7-S6 specifying Stage 1.5 provenance re-stamping and contract enforcement scope | Verify the document text for Stage 1.5 includes provenance re-stamping requirements and boundary check inclusion |
| R7-S9 | security | medium | Task 3 adds expression validation to `PropagationChainSpec` at parse time via `@field_validator`, but the plan doesn't address existing contract YAML files that may already contain expressions which would now fail the new AST validation. If the hardening is deployed without a migration check, existing valid pipelines could break. | This is a backward compatibility concern for the security hardening. The plan should include a step to scan existing contract YAML files for verification expressions and confirm they pass the new validator before deploying the change. If any fail, either the validator needs adjustment or the expressions need migration. | Task 3 — add a pre-deployment validation step: scan all `*.contract.yaml` files for `verification:` fields and run them through the new `_validate_expression()` | Run `_validate_expression()` against all existing verification expressions; assert 100% pass rate or document required expression migrations |
| R7-S10 | clarity | medium | The plan's "Deferred to Phase 2" list includes "Domain 3-7 promotion to Y validation" but also proposes changing the matrix to Y* in Task 2 *during Phase 1*. The asterisk footnote ("end-to-end integration pending validation") creates a new status tier (Y*) that isn't defined in the original requirements document and could confuse readers who expect only Y and D. | The matrix was designed with two clear states: Y (fully integrated) and D (domain logic only). Introducing Y* without a formal definition in the matrix legend creates ambiguity. Is Y* closer to Y or D? Can Y* domains be relied upon for enforcement? The plan should either keep domains at D until Phase 2 validates them (conservative) or define Y* precisely with its implications for enforcement reliability. | Task 2 — either add a formal legend entry for Y* with enforcement implications, or keep domains at D and add a separate "Validation Status" note | Document review: the matrix has a clear legend defining all status codes used; no undefined symbols |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R5-F1: The checksum origin and recomputation protocol across stages 0-4 is genuinely unspecified — the plan applies checksum-related fixes (R1-S1, R4-S1) but only at the Gate level, not the production/stamping level within ContextCore stages.
- R5-F3: The `completeness_pct` calculation formula is unspecified and two implementations could produce different percentages for identical chain results — this is a real testability gap that the plan doesn't address.
- R4-F1: The term "waypoints" in REQ-PCG-001.6 is used once and never defined — the plan doesn't address this terminology gap despite applying multiple clarifications to REQ-PCG-001.
- R4-F4: REQ-PCG-012's regression detection needs an intentional-regression allowlist mechanism — the plan defers the baseline (R3-S7) but doesn't address the legitimate refactoring scenario.
- R6-F2: Error envelope sanitization for log injection/XSS is a distinct concern from the filesystem path issue (R3-F3) and remains unaddressed.

#### Feature Requirements Suggestions

| ID | Area | Severity | Requirement Section | Issue | Suggested Fix |
| ---- | ---- | ---- | ---- | ---- | ---- |
| R7-F1 | completeness | high | REQ-PCG-006 Req 1-2 | `BudgetPropagationSpec` specifies `remaining_budget_ms` but accepted R6-S4 requires distinguishing execution time from wall time, and accepted R4-F3 requires supporting multiple budget types (tokens, cost). The requirement text still only mentions time. These accepted suggestions are not yet reflected in the requirement body. | Add: "BudgetPropagationSpec MUST support a `budget_unit` field (enum: `time_ms`, `tokens`, `cost_usd`) and per-phase allocations in the declared unit. `remaining_budget_ms` is the time-specific convenience alias. Budget tracking MUST distinguish compute time from wall-clock time for time-based budgets (per R6-S4)." |
| R7-F2 | architecture | high | REQ-PCG-020 (Gate 1) | The plan adds Gate 1 check #8 (artifact inventory / Mottainai provenance v2 cross-check) and accepted R6-S3 adds inline/external provenance reconciliation. These are potentially two separate checks (inventory completeness vs. provenance consistency) but the plan counts them as one check (#8). The total could be 8 or 9 depending on interpretation. | Explicitly enumerate all Gate 1 checks in the updated requirement with unambiguous numbering. If R6-S3 reconciliation is merged into existing check #3 (provenance cross-check), state this. If it's a separate check #9, update the count. |
| R7-F3 | clarity | high | REQ-PCG-009 Req 4 | "Existing `validate_phase_entry()` and `validate_phase_exit()` MUST remain unchanged" — accepted R1-F2 and R4-F4 both require documenting frozen interface signatures, but the plan only mentions adding a clarification note. The actual parameter types, return types, and error signaling are still unspecified. Without them, "unchanged" is unenforceable. | Add to REQ-PCG-009 or a linked appendix: the current function signatures including parameter names, types, return type, and exception behavior. Example: `validate_phase_entry(context: dict, phase: str) -> ValidationResult` (or whatever the actual signature is). |
| R7-F4 | security | medium | NFR-PCG-004 | The plan's Task 3 specifies an AST allowlist with max expression length (500 chars) and 1-second timeout, but accepted R9-S2 specifically identified that CI runs contract analysis on PR YAML from forks — meaning untrusted expressions reach the parser even if eval() isn't called. The plan's AST validation runs at Pydantic parse time, which IS during CI analysis. If the AST parser itself has vulnerabilities (e.g., deeply nested expressions causing stack overflow in `ast.parse`), the hardening has a gap. | Add to Task 3: "AST parsing MUST be wrapped in a try/except for RecursionError and MemoryError. Expressions with AST depth > 10 MUST be rejected. CI analysis on untrusted PR YAML MUST run expression validation in a subprocess with resource limits." |
| R7-F5 | completeness | medium | REQ-PCG-022 (Gate 3) | Accepted R8-S4 requires Gate 3 to verify no unaccounted artifacts exist (strict allowlist), and accepted R12-S7 requires explicit semantics for "Partial" status exit codes. The plan marks Gate 3 as "Partial" status but doesn't integrate these accepted suggestions into the Gate 3 requirement text or the plan's Task 1 changes. | Add to Task 1a or 1c: update REQ-PCG-022 requirements to include (a) strict artifact allowlist check per R8-S4, (b) explicit exit code semantics for Partial status per R12-S7: "Partial status MUST exit non-zero by default; `--allow-partial` flag MAY override to exit 0 with a WARNING gate result." |
| R7-F6 | completeness | medium | REQ-PCG-013 + REQ-PCG-014 | Accepted R8-S5 requires default injection to stamp "System Default" provenance, and accepted R10-S5 requires re-stamping value_hash when defaults are applied. The plan's Task 1d applies R4-S6 (stamp provenance on default injection) but doesn't mention the value_hash update or the "System Default" marker. These three accepted suggestions all target the same interaction but the plan only partially addresses it. | Consolidate R4-S6, R8-S5, and R10-S5 into a single coherent addition to REQ-PCG-013/014: "When defaults are injected, `PropagationTracker.stamp()` MUST be called with `origin_phase='system_default:{phase_name}'` and the value_hash MUST reflect the default value, not the absent value." |
| R7-F7 | testability | medium | Verification Plan | Accepted R13-S10 requires fault injection tests for the graceful degradation path (ContextCore not installed), and accepted R11-S4 requires testing `_cc_propagation` key behavior without ContextCore. The plan's Verification section doesn't include any degradation-path test — it only verifies that existing tests pass and eval() safety tests work. | Add to Verification section: "Run startd8-sdk stage 5-7 tests with ContextCore uninstalled (e.g., `pip uninstall contextcore && pytest tests/`); verify all pass with validation wrapper returning None." |

#### Requirements Coverage

| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| ---- | ---- | ---- | ---- |
| 1.1 Theoretical Foundation | N/A (informational) | Full | None — no actionable requirements |
| 1.2 REQ-PCG-001 (Propagation) | Task 1c (R3-S1 score bounds reference) | Full | None — requirement itself is well-covered; plan addresses precision gaps |
| 1.2 REQ-PCG-002 (Schema Compat) | Task 2 (matrix update) | Full | None |
| 1.2 REQ-PCG-003-007 (Domains 3-7) | Task 1a (R3-S3 status correction), Task 2 (matrix Y*) | Partial | **Gap**: Plan changes status but R7-S4 identifies no validation step for the Y* claim. Budget domain doesn't reflect accepted R4-F3 (multi-unit) or R6-S4 (time types). |
| 1.3 REQ-PCG-008 (Preflight) | Task 1a (R1-S4 typo+bypass), Task 1c (R1-S5 test counts) | Full | None |
| 1.3 REQ-PCG-009 (Runtime) | Task 1d (R4-S2 degradation distinction) | Partial | **Gap**: Frozen interface signatures (R1-F2, R4-F4 accepted) not specified in plan. See R7-F3. |
| 1.3 REQ-PCG-010 (Post-Exec) | Task 1c (test counts) | Full | Completeness_pct formula unspecified (R5-F3 untriaged). |
| 1.3 REQ-PCG-011 (Observability) | Task 1c (R3-S8 test harness spec) | Full | None |
| 1.3 REQ-PCG-012 (Regression) | Deferred (R3-S7 baseline) | Partial | **Gap**: Intentional regression allowlist (R4-F4 accepted) not in plan. |
| 1.4 REQ-PCG-013 (Severity) | Task 1c (R3-S10), Task 1d (R4-S6 provenance stamp) | Partial | **Gap**: R8-S5 and R10-S5 (accepted) not fully integrated. See R7-F6. |
| 1.5 REQ-PCG-014 (Provenance) | Task 1d (R4-S9 seed stages) | Partial | **Gap**: R5-S9 (Stage 1.5 re-stamping, accepted) missing from plan. R7-S5/R14-S1 (repr→canonical) accepted but plan doesn't implement the serialization change. |
| 1.6 REQ-PCG-015 (Dual Declaration) | Task 3 (eval hardening) | Full | None |
| 1.6 REQ-PCG-016 (Progressive Adoption) | N/A | Full | R4-F1 (graduation criteria, accepted) not in plan tasks. |
| 2.1 REQ-PCG-017 (A2A Contracts) | Task 1f (R1-S10 versioning placeholder) | Partial | **Gap**: Version negotiation mechanism deferred but no interim compatibility requirement specified. |
| 2.2 REQ-PCG-018 (Boundary) | Task 1c | Full | Error envelope sanitization (R6-F2, R3-F3) partially addressed. |
| 2.2 REQ-PCG-019 (Checksums) | Task 1a (R1-S1 gate count) | Partial | **Gap**: R12-S3 (file canonicalization for deterministic checksums, accepted) not in plan tasks. |
| 2.3 REQ-PCG-020 (Gate 1) | Task 1a (R1-S1 + R4-S1), Task 4 | Full | Gate check count may be 8 or 9 depending on R6-S3 placement. See R7-F2. |
| 2.3 REQ-PCG-021 (Gate 2) | Task 1c (R3-S1, R4-S3) | Full | None |
| 2.3 REQ-PCG-022 (Gate 3) | Task 1a (R1-S2 status) | Partial | **Gap**: R8-S4 (strict allowlist) and R12-S7 (partial exit code) accepted but not in plan. See R7-F5. |
| 2.4 REQ-PCG-023 (Structured Results) | Task 1a (R2-S5 fail loud) | Full | None |
| 2.5 REQ-PCG-024 (Handoff) | Task 1b (R1-S8), Task 1d (R2-S3) | Full | None |
| 2.5 REQ-PCG-025 (Cross-Boundary) | Task 1d (R4-S2), deferred (R3-S2 hydration) | Partial | **Gap**: R12-S6 (runtime version compat check, accepted) not in plan. R5-S5 (_cc_propagation handling) accepted but resolution unspecified. See R7-S2. |
| 2.6 REQ-PCG-026 (Plan Ingestion) | Task 1c (R3-S1 score bounds), Task 1f (R1-S9 exclusions) | Full | None |
| 2.6 REQ-PCG-027 (Artisan Workflow) | Task 1d | Partial | **Gap**: R1-F5 (partial phase success, accepted) not in plan. R4-F2 (review req rewrite, accepted) not in plan. |
| 2.7 REQ-PCG-028-029 (Dashboards) | Task 1c (R3-S8) | Full | None |
| 3 REQ-PCG-030-032 (Cross-Cutting) | Task 1d, 1c | Full | None |
| NFRs 001-005 | Task 1d (R4-S2), Task 3 (NFR-004), Task 1a | Partial | **Gap**: R12-S1 (NFR-005 vs REQ-013 contradiction, accepted) not resolved in plan. R9-S5 (zero overhead measurability, accepted) not in plan. R14-S4 (fail-closed for gate crashes, accepted) not in plan. |
| Part 4 (Extensions) | Task 1b (R5-S7 traceability) | Full | None |

#### Review Round R8
- **Reviewer**: gemini-3 (gemini-3-pro-preview)
- **Date**: 2026-02-19 20:42:07 UTC
- **Scope**: Architecture-focused review

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R8-S1 | security | high | Require a unique `run_id` binding across all handoff artifacts to prevent "Frankenstein" pipelines. | Checksums (REQ-PCG-019) ensure file integrity but not session coherence. A user could accidentally mix `artifact-manifest.yaml` from Run A with `onboarding-metadata.json` from Run B if checksums coincidentally match or if the checker implies "latest available". Explicit run-binding prevents processing mismatched artifact sets. | REQ-PCG-024 | Inject `run_id` into all 3 handoff files; Gate 1 verifies all match. |
| R8-S2 | completeness | medium | Capture critical environment variables (e.g., `DEPLOY_ENV`, `FEATURE_FLAGS`) in the Provenance (REQ-PCG-014). | Context correctness depends on the environment. A plan generated with `FEATURE_X=true` but executed with `FEATURE_X=false` is invalid, even if file checksums match. Provenance must capture the *environmental* context, not just the data context. | REQ-PCG-014 | Run pipeline with specific env vars; verify they appear in `_cc_propagation` (redacted if sensitive). |
| R8-S3 | maintainability | high | Add a global `--contract-mode={enforce|audit}` flag to support "Shadow Mode" execution. | "Progressive Adoption" (REQ-PCG-016) is risky if testing a BLOCKING contract requires breaking the build. An "Audit" mode that downgrades all BLOCKING faults to WARNING allows safe testing of new strict contracts in production pipelines. | REQ-PCG-009 | Run with `--contract-mode=audit` and a known BLOCKING violation; verify pipeline proceeds and emits `severity=BLOCKING` but `blocking=False` in telemetry. |
| R8-S4 | security | medium | Mandate "Time-of-Check to Time-of-Use" (TOCTOU) re-verification at Stage 5 ingestion. | Gate 1 (REQ-PCG-020) checks artifacts, but Stage 5 consumes them. If artifacts are modified on the shared filesystem between Gate 1 completion and Stage 5 read (by a malicious user or race condition), the check is bypassed. Stage 5 must re-hash inputs immediately before parsing. | REQ-PCG-026 | Modify artifact after Gate 1 passes but before Stage 5 reads; verify Stage 5 halts. |
| R8-S5 | architecture | medium | Explicitly forbid defining contract *logic* (validators) in `startd8-sdk`; restrict it to contract *definitions* (YAML). | REQ-PCG-015 splits framework and concrete contracts. Allowing `startd8-sdk` to define custom Python validator logic creates a bidirectional dependency and versioning nightmare. Logic must remain centralized in `ContextCore` to ensure the "Dual Declaration" pattern holds. | REQ-PCG-015 | Architecture lint rule ensuring no `*.py` files in `startd8-sdk` import `pydantic` for the purpose of custom validation logic. |
| R8-S6 | observability | low | Require "Degradation Observability": Emit a specific log/event when ContextCore is missing and validation is skipped. | NFR-PCG-002 allows graceful degradation. Without an explicit signal (e.g., `ContractValidationSkipped`), operators might not realize the pipeline is running unprotected (e.g., due to a broken install), assuming "Green" means "Secure". | NFR-PCG-002 | Run without ContextCore; verify logs contain "WARNING: ContextCore not found, skipping validation". |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R12-S3: Canonicalization for checksums is essential for deterministic verification across different JSON serializers.
- R14-S2: Redacting sensitive fields in OTel is a critical privacy requirement often missed in early observability designs.
- R14-S4: Fail-closed behavior for gate logic errors is standard security practice; a crashing gate should not default to "Pass".

#### Feature Requirements Suggestions
| ID | Area | Severity | Requirement Section | Issue | Suggested Fix |
| ---- | ---- | ---- | ---- | ---- | ---- |
| R8-F1 | clarity | medium | REQ-PCG-021 (Gate 2) | Question 1 asks "Is the contract complete?" and checks "Artifact manifest population". However, Gate 1 runs *before* Plan Ingestion (Stage 5), while the Manifest is created in Stage 2. The timeline of when "Manifest" vs "Plan" exists is slightly ambiguous in the gate definitions. | Clarify that Gate 1 checks the *Exported* Manifest (from Stage 4) and Gate 2 checks the *Ingested* Plan (in Stage 5). |
| R8-F2 | scalability | medium | REQ-PCG-011 | "All contract enforcement actions MUST emit OTel span events". For high-throughput pipelines, this creates massive cardinality. | Add "Telemetry MUST support sampling or aggregation for high-frequency checks to prevent OTel backend saturation." |

#### Requirements Coverage
| Feature Doc Section | Plan Step(s) | Coverage | Gaps |
| :--- | :--- | :--- | :--- |
| **1. Context Correctness** | | | |
| 1.1 Theoretical Foundation | N/A | Full | Conceptual only. |
| 1.2 Contract Domains | Task 1c (Status update), Task 2 (Matrix) | Full | Implementation is ahead of doc; plan updates doc to match. |
| 1.3 Defense-in-Depth | Task 1a (Gate 1 update), Task 1c (Test counts) | Full | |
| 1.4 Severity Model | Task 1d (Clarifications) | Full | |
| 1.5 Provenance | Task 1d (Seed req), Task 1f (Run-provenance warning) | Partial | Missing env var capture (R8-S2). |
| 1.6 Contract Declaration | Task 1f (Versioning placeholder) | Full | |
| **2. A2A Governance** | | | |
| 2.1 Contract Types | Task 1b (Source tracing) | Full | |
| 2.2 Boundary Enforcement | Task 3 (Eval hardening) | Full | |
| 2.3 Gate Requirements | Task 1a (Gate 1 checks), Task 1c (Gate 3 status) | Full | |
| 2.4 Fail Loud | Task 1a (Run-provenance warning) | Full | |
| 2.5 Handoff Contract | Task 1d (Handoff artifacts definition) | Partial | Missing run-id binding (R8-S1). |
| 2.6 Contractor Execution | Task 1c (Score reasonableness) | Full | |
| 2.7 Observability | Task 1c (Test counts) | Full | |
| **3. Cross-Cutting** | | | |
| REQ-PCG-030/031/032 | Task 1c (Event names), Task 4 (Comp doc update) | Full | |
