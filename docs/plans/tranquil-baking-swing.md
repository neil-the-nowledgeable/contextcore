# Plan: Formalize ContextCore Semantic Conventions as an OTel Weaver Registry

## Context

ContextCore defines ~185 semantic convention attributes across 17+ namespaces, currently maintained as:
- **Markdown prose** in `docs/semantic-conventions.md` (1920 lines, hand-maintained)
- **Python enums** in `src/contextcore/contracts/types.py` (canonical source of truth for enum values)
- **Python metric/label contracts** in `src/contextcore/contracts/metrics.py` (metric names, label names, event types)
- **Dual-emit mappings** in `src/contextcore/compat/otel_genai.py` (agent.* -> gen_ai.* mappings)

These sources drift from each other (e.g., `HandoffStatus` in Python has 6 values but Markdown lists 9). There is no machine-readable schema and no automated validation that emitted OTLP conforms to declared conventions.

[OTel Weaver](https://github.com/open-telemetry/weaver) provides schema governance tooling: registry validation, live-checking against OTLP, doc generation from schema, and version diffing. Formalizing ContextCore's conventions as a Weaver-compatible registry gives us automated validation, single source of truth, and positions ContextCore as a well-governed OTel extension.

## Directory Structure

```
semconv/
  registry_manifest.yaml              # Entry point: name, version, OTel dependency
  registry/                            # Attribute group definitions
    task.yaml                          # task.* (17 attrs) - core ContextCore
    project.yaml                       # project.* (5 attrs)
    sprint.yaml                        # sprint.* (7 attrs)
    business.yaml                      # business.*, design.*, requirement.*, risk.* (16 attrs)
    agent.yaml                         # agent.* (6 attrs, all deprecated -> gen_ai.*)
    insight.yaml                       # insight.*, evidence.* (15 attrs)
    handoff.yaml                       # handoff.* (10 attrs)
    guidance.yaml                      # guidance.* (7 attrs)
    install.yaml                       # contextcore.install.* (12 attrs)
    code_generation.yaml               # gen_ai.code.* extensions (16 attrs)
  spans/
    task_spans.yaml                    # contextcore.task span (refs task.* attrs)
    sprint_span.yaml                   # contextcore.sprint span
    install_span.yaml                  # contextcore.install.verify span hierarchy
    handoff_spans.yaml                 # handoff lifecycle spans
  events/
    task_events.yaml                   # task.created, task.status_changed, etc. (10 events)
    agent_events.yaml                  # agent session/insight/handoff events (5 events)
  metrics/
    task_metrics.yaml                  # task.lead_time, task.cycle_time, task.wip, etc. (9 metrics)
    install_metrics.yaml               # contextcore.install.completeness, etc. (3 metrics)
```

## Key Design Decisions

### Define locally vs reference from OTel

**Define in our registry** (ContextCore-specific, no upstream OTel equivalent):
- `task.*`, `project.*`, `sprint.*`, `business.*`, `design.*`, `requirement.*`, `risk.*`
- `insight.*`, `evidence.*`, `handoff.*`, `guidance.*`
- `contextcore.install.*`, `gen_ai.code.*` (our extensions to the gen_ai namespace)

**Reference via `ref:` from OTel semconv dependency**:
- `gen_ai.system`, `gen_ai.request.model`, `gen_ai.agent.id`, `gen_ai.conversation.id`, etc.
- `k8s.namespace.name`, `k8s.deployment.name`, `k8s.pod.name`
- `service.name`, `service.namespace`, `service.version`
- `messaging.*` attributes (Rabbit/Fox)
- `cicd.pipeline.*` attributes

### Enum source of truth

Python enums in `contracts/types.py` and string constants in `contracts/metrics.py` are canonical. Where Markdown diverges (e.g., HandoffStatus), the registry will match Python. Known discrepancy: Markdown lists `input_required`, `cancelled`, `rejected` as handoff statuses but Python `HandoffStatus` only has 6 members. Registry follows Python.

**Action item [R5-S4]**: File an issue to resolve the HandoffStatus discrepancy before Phase 2. Either add the 3 missing members to the Python enum or remove them from Markdown. Must be resolved before `handoff.yaml` creation.

Enum member changes follow the registry versioning policy: adding members is a minor bump; removing or renaming members is a breaking change requiring a major bump and a deprecation cycle. [R2-S7]

### Deprecated agent.* attributes

All 6 `agent.*` attributes will carry `deprecated:` fields pointing to their `gen_ai.*` replacements. This makes the migration machine-readable.

### Deprecation Policy [R2-S10]

The `agent.*` → `gen_ai.*` migration establishes the standard deprecation process for all future attribute changes:

1. **Mark deprecated**: Add `deprecated:` field with replacement attribute and version introduced
2. **Dual-emit window**: Maintain both old and new attributes for at least 2 minor versions
3. **Downstream audit [R4-S5]**: Before removal in a major version, audit known downstream systems (Grafana dashboards, Loki recording rules, alert definitions) for usage of the deprecated attribute. Removal is blocked until usage is migrated or explicitly accepted as a breaking change.
4. **Removal**: Remove deprecated attribute in the next major version bump
5. **Communication**: Deprecations are visible in `weaver registry resolve` output and in generated documentation

### Registry–Runtime Boundary [R1-S4]

The registry is a **CI-only governance artifact**. Python enums in `contracts/types.py` and `contracts/metrics.py` remain the runtime canonical source. The registry does not generate Python code and is not read at runtime. The relationship is:

- **Python** → runtime source of truth (what the SDK emits)
- **Registry YAML** → governance source of truth (what the SDK *should* emit)
- **CI** → enforces parity between the two via `scripts/verify_contracts_parity.py`

### Namespace Governance Policy [R1-S2]

Attributes fall into two categories with different governance rules:

| Category | Namespace Pattern | Examples | Governance |
|----------|------------------|----------|------------|
| **ContextCore-owned** | Unprefixed domain names | `task.*`, `project.*`, `sprint.*`, `handoff.*` | Full control; follow internal versioning policy |
| **OTel-extension** | Extends an upstream OTel namespace | `gen_ai.code.*` | Must monitor upstream SIG for conflicts; prefer `contextcore.*` prefix if collision risk is high |

**Decision criteria for new attribute groups:**
- If the concept is ContextCore-specific with no OTel equivalent → use ContextCore-owned namespace
- If extending an existing OTel namespace → document justification, assign a collision monitor owner, and include a rename escape plan

### YAML Enum Convention [R3-S1, R5-S3]

All enum-typed attributes in the registry MUST use the following canonical YAML structure to enable machine-parseable parity checking by `verify_contracts_parity.py`:

```yaml
type:
  allow_custom_values: false
  members:
    - id: ENUM_MEMBER_NAME    # matches Python enum member name
      value: "enum_value"      # matches Python enum .value
      stability: development
```

**Parity script behavior with `ref:` attributes**: Attributes using `ref:` to inherit from OTel-defined enums (e.g., `gen_ai.system`) are **skipped** by the parity check — they have no local `members` block to validate against. The script must handle this explicitly rather than raising a false-positive error.

**Array-typed attributes [R3-S10]**: Attributes declared as `string[]` (e.g., `task.labels`, `task.blocked_by`) must be emitted via OTel SDK `set_attribute` using `list[str]`, not comma-separated strings. The registry `type: string[]` declaration implies the OTLP repeated field wire format.

### Requirement Level Guidelines [R5-S9]

Span attribute references in `spans/*.yaml` must declare an explicit `requirement_level`. Use these guidelines:

| Level | When to use | Examples |
|-------|------------|----------|
| `required` | Identifiers essential for querying | `task.id`, `project.id` |
| `recommended` | Descriptive fields valuable for analysis | `task.labels`, `task.url`, `task.assignee` |
| `opt_in` | Computed or high-cardinality fields | `task.percent_complete`, `task.story_points` |
| `conditionally_required` | Required only in specific contexts | `sprint.id` (only on sprint-scoped spans) |

### Registry Versioning Policy [R1-S6, R2-S3]

The registry follows SemVer for `semconv_version` in `registry_manifest.yaml`:

| Change Type | Version Bump | Examples |
|-------------|-------------|----------|
| New attributes, new enum members | Minor (0.x.0) | Adding `task.reviewer` attribute |
| Attribute deprecation (with replacement) | Minor (0.x.0) | Deprecating `agent.id` → `gen_ai.agent.id` |
| Attribute removal, enum member removal/rename | Major (x.0.0) | Removing deprecated `agent.*` attributes |
| Documentation-only, stability promotions | Patch (0.0.x) | Promoting `task.*` from `development` to `stable` |

Version is tagged in git. Breaking changes require a PR description explaining the impact on downstream consumers.

**Stability graduation criteria [R10-S6]**: Promotion from `development` → `experimental` requires the attribute to be emitted by the SDK in at least one deployed environment. Promotion from `experimental` → `stable` requires: (a) in production for >= 3 months, (b) referenced by >= 1 dashboard or alert rule, and (c) no breaking changes in the last 2 minor versions. Promotion PRs must include justification referencing these criteria.

### Security & Privacy Considerations [R2-S4]

All attribute groups must be reviewed for PII exposure before inclusion in the registry. Known sensitive attributes:

- `task.assignee` — may contain names/emails; consider hashing or using opaque IDs
- `task.url` — may contain internal URLs; evaluate exposure risk per deployment
- Event body fields (e.g., `task.commented`) — must not capture free-text content

Phase 1 review: `task.*`, `project.*`, `sprint.*` attributes confirmed as low-PII risk (IDs, enums, numeric values). `task.assignee` flagged for per-deployment guidance in documentation.

**Ongoing process [R6-S4]**: PII review is not a one-time activity. The PR template for `semconv/` changes must include a mandatory PII/security review checklist item confirming that new or modified attributes have been assessed. Adding new attribute groups or sensitive attributes requires explicit sign-off.

**Free-text field policy [R6-S10]**: New free-text (unbounded string) attributes are **disallowed by default**. Any free-text attribute requires explicit justification and a PII review before inclusion in the registry. Prefer structured alternatives (e.g., `comment_length: int` instead of `comment_text: string`).

## Phased Implementation

### Phase 1: MVP Registry + CI (this session)

Create a working Weaver registry with the 4 highest-value attribute groups, task spans, task events, and CI validation.

**Files to create:**

1. **`semconv/registry_manifest.yaml`** - Registry entry point. **Day-one smoke test [R3-S4, R7-S2]**: before writing any other YAML, run `weaver registry check` with *only* the manifest file to validate the `[model]` suffix syntax and dependency resolution against the pinned Weaver version. Then add a minimal `agent.yaml` with one `ref:` to `gen_ai.agent.id` and re-run `weaver registry check` to validate cross-dependency `ref:` resolution end-to-end — this confirms the pinned v1.34.0 archive includes the required `gen_ai.*` attributes. If it fails, identify which OTel semconv tag first includes them and update the pin. Document the exact Weaver version in a `.weaver-version` file.
   ```yaml
   name: contextcore
   description: Semantic conventions for project management observability
   semconv_version: 0.1.0
   dependencies:
     - name: otel
       registry_path: https://github.com/open-telemetry/semantic-conventions/archive/refs/tags/v1.34.0.zip[model]
   ```

2. **`semconv/registry/task.yaml`** - 17 attributes including task.id, task.type (enum with 7 members matching `TaskType`), task.status (enum with 7 members matching `TaskStatus`), task.priority (enum with 4 members matching `Priority`), task.assignee, task.story_points, task.labels, task.url, task.due_date, task.blocked_by, task.parent_id, task.percent_complete, task.subtask_count, task.subtask_completed, task.deliverable.count, task.deliverable.verified, task.deliverables_complete. **Date format [R7-S4]**: `task.due_date` must include a `note:` annotation specifying ISO 8601 format (`YYYY-MM-DDTHH:MM:SSZ`). **Disambiguation [R11-S8]**: `task.priority` must include `note: "Work-item scheduling priority. Distinct from business.criticality (Phase 2) which measures organizational impact."` **PII marker [R11-S9]**: `task.url` must include `note: "May contain internal URLs. Deployers should evaluate exposure risk and consider redaction."`

3. **`semconv/registry/project.yaml`** - 5 attributes: project.id, project.name, project.epic, project.task, project.trace_id

4. **`semconv/registry/sprint.yaml`** - 7 attributes: sprint.id, sprint.name, sprint.goal, sprint.start_date, sprint.end_date, sprint.planned_points, sprint.completed_points. **Date format [R7-S4]**: `sprint.start_date` and `sprint.end_date` must include `note:` annotations specifying ISO 8601 format (`YYYY-MM-DDTHH:MM:SSZ`).

5. **`semconv/registry/agent.yaml`** - 6 deprecated attributes with deprecation markers pointing to gen_ai.* replacements

6. **`semconv/spans/task_spans.yaml`** - `span.contextcore.task` (span_kind: internal) referencing task.* and project.id attributes with explicit `requirement_level` per the Requirement Level Guidelines. **Scope rule [R3-S5]**: Phase 1 spans must ONLY reference attributes defined in Phase 1 registry files. No forward references to Phase 2 attributes — `weaver registry check` must pass with only Phase 1 files present.

7. **`semconv/events/task_events.yaml`** - Events matching `EventType` enum: task.created, task.status_changed, task.blocked, task.unblocked, task.completed, task.cancelled, task.assigned, task.commented, task.deliverables_verified, task.progress_updated, subtask.completed [R9-S3]. **Action item [R11-S6]**: `task.deliverables_verified` is not currently in the `EventType` enum in `metrics.py` — add `TASK_DELIVERABLES_VERIFIED = 'task.deliverables_verified'` to `EventType` before creating this file, to maintain bidirectional parity. **Each event must define a `body` schema [R3-S2]** with typed attributes (e.g., `task.status_changed` has `body: { previous_status: string, new_status: string }`). The PII-flagged `task.commented` event must NOT include a `comment_text` field — use `comment_length: int` instead.

8. **`.github/workflows/validate-semconv.yml`** - CI workflow with pinned Weaver version (`WEAVER_VERSION` variable, e.g., `0.12.x`) [R5-S2]. Runs `weaver registry check`, `weaver registry resolve` (with artifact upload and **diff against base branch** for readable PR review [R1-S9, R3-S6]), and `python3 scripts/verify_contracts_parity.py` on semconv/ and contracts/ changes. Includes a step to **validate `ref:` link integrity** when the OTel dependency archive changes [R6-S7, R4-S8]. **Rollback strategy [R1-S3]**: initially runs with `continue-on-error: true` for the first 2 weeks to measure false-positive rate before becoming a hard gate. **`[skip-semconv]` scope [R5-S5]**: the label skips Weaver schema checks (`registry check`, `registry resolve`) but NOT the contracts parity script, since parity failures indicate real drift and are never false positives. **Usage logging [R6-S3]**: CI posts a comment noting when `[skip-semconv]` is used, for periodic audit.

9. **Makefile additions** - `semconv-check`, `semconv-resolve`, `semconv-verify-contracts` targets. **Single-source version pin [R7-S10]**: `WEAVER_VERSION := $(shell cat .weaver-version)` — the `.weaver-version` file is the single source of truth; Makefile and CI workflow both read from it. `make semconv-check` fails if wrong Weaver version is detected. [R5-S2]

10. **`scripts/verify_contracts_parity.py`** [R1-S1, R2-S1, R2-S8, R5-S1, R6-S2, R4-S7, R7-S1, R7-S6, R7-S9] - Comprehensive parity script covering ALL Python contracts, not just enums:
    - **Enums** from `contracts/types.py`: `TaskStatus`, `TaskType`, `Priority`, `HandoffStatus`, `InsightType`
    - **String constants** from `contracts/metrics.py`: `MetricName`, `LabelName`, `EventType`
    - **Deprecation mappings** [R4-S9, R5-S8, R6-S5, R12-S2]: verifies `ATTRIBUTE_MAPPINGS` dict in `otel_genai.py` matches `deprecated:` fields in `agent.yaml`. Also verifies that each deprecated source attribute still exists in Python contracts — a premature removal would break dual-emit logic at runtime. Unit test fixture: remove a deprecated constant from Python mock → script must fail.
    - **Bidirectional parity [R7-S1]**: script must fail if Python has members not in YAML *and* if YAML has members not in Python. Unit test fixtures must include: (a) Python superset of YAML → fail, (b) YAML superset of Python → fail, (c) exact match → pass.
    - **Explicit mapping table [R7-S6]**: script uses a Python dict mapping enum/constant class names to YAML file paths. Includes orphan detection — fails if any registry YAML file in `semconv/registry/` has no corresponding mapping entry.
    - **Raw YAML parsing [R7-S9]**: Phase 1 script parses raw YAML files (sufficient since `ref:` attributes are skipped). Phase 2 pre-merge checklist evaluates switching to resolved output if any cross-file `ref:` inheritance is introduced within ContextCore-owned attributes.
    - Skips `ref:` attributes (no local `members` block). Exits non-zero on any mismatch. Includes unit tests with known-good and known-bad fixtures.

11. **PR template additions [R6-S4, R4-S10]** - PR template for `semconv/` changes includes: (a) PII/security review checklist item, (b) "Have you updated related span/event definitions in `semconv/spans/` and `semconv/events/`?" checklist item.

**Attribute requirements:**
- All attributes must declare a `stability:` level (`development`, `experimental`, or `stable`). Phase 1 attributes start as `development`. [R1-S5]
- All attributes must declare an explicit `type:` field (`string`, `int`, `boolean`, `string[]`, etc.). [R2-S6]

**Verification:**
- `weaver registry check --registry semconv/` passes with zero errors using pinned Weaver version
- `weaver registry resolve --registry semconv/` succeeds and resolved output is uploaded as CI artifact with diff against base branch
- CI workflow passes on PR
- All Python contracts match registry YAML (enforced by `verify_contracts_parity.py`): enums, metric names, label names, event types, and deprecation mappings
- All attribute groups contain `stability:` and `type:` fields
- All span attribute references have explicit `requirement_level`
- All events have `body` schemas with typed fields
- No forward references to Phase 2 attributes in Phase 1 spans/events

### Phase 2: Full Attribute Coverage + Metrics/Events

Add remaining ~125 attributes across all namespaces.

**Files to create:**
- `semconv/registry/business.yaml` - business.*, design.*, requirement.*, risk.* (16 attrs)
- `semconv/registry/insight.yaml` - insight.*, evidence.* (15 attrs, enums match `InsightType`)
- `semconv/registry/handoff.yaml` - handoff.* (10 attrs, enum matches `HandoffStatus`)
- `semconv/registry/guidance.yaml` - guidance.* (7 attrs)
- `semconv/registry/install.yaml` - contextcore.install.* (12 attrs)
- `semconv/registry/code_generation.yaml` - gen_ai.code.* (16 attrs)
- `semconv/spans/sprint_span.yaml` - Sprint span definition
- `semconv/spans/install_span.yaml` - Install verification span hierarchy
- `semconv/spans/handoff_spans.yaml` - Handoff lifecycle spans
- `semconv/events/agent_events.yaml` - Agent session/insight/handoff events
- `semconv/metrics/task_metrics.yaml` - 9 task flow metrics (matching `MetricName` enum: lead_time, cycle_time, blocked_time, wip, throughput, story_points_completed, count_by_status, count_by_type, sprint.velocity). **Each metric must specify instrument type and unit [R3-S7]**:

  | Metric | Instrument | Unit | Rationale |
  |--------|-----------|------|-----------|
  | `task.lead_time` | histogram | seconds | Distribution of durations |
  | `task.cycle_time` | histogram | seconds | Distribution of durations |
  | `task.blocked_time` | histogram | seconds | Distribution of durations |
  | `task.wip` | gauge | {tasks} | Point-in-time count |
  | `task.throughput` | counter | {tasks} | Monotonic completed count |
  | `task.story_points_completed` | counter | {points} | Monotonic sum |
  | `task.count_by_status` | gauge | {tasks} | Point-in-time per status |
  | `task.count_by_type` | gauge | {tasks} | Point-in-time per type |
  | `sprint.velocity` | gauge | {points} | Per-sprint aggregate |

- `semconv/metrics/install_metrics.yaml` - 3 installation metrics (completeness, requirement.status, verification.duration)

**Additional Phase 2 files [R9-S3]:**
- `semconv/events/sprint_events.yaml` — `sprint.started` and `sprint.ended` events (matching `SPRINT_STARTED`, `SPRINT_ENDED` from `EventType`)

**Phase 2 pre-merge checklist:**
- HandoffStatus enum discrepancy resolved (see Phase 1 action item [R5-S4])
- PR template includes span/event update checklist and PII review checkbox
- Extend `verify_contracts_parity.py` mapping table to cover ALL enums in `types.py` that have corresponding registry YAML attribute groups [R9-S1]. Phase 1 covers 5 of ~15 enums; Phase 2 must add `Criticality`, `BusinessValue`, `RiskType`, `ConstraintSeverity`, `SessionStatus`, `AlertPriority`, `AgentType`, `DashboardPlacement`, `LogLevel` — or document explicit exclusion rationale for each.
- `business.yaml` must include `note:` annotations on `business.criticality` documenting its distinction from `task.priority` (identical enum members, different semantic scope) [R9-S8]
- Evaluate switching parity script from raw YAML to resolved output if cross-file `ref:` inheritance is introduced [R7-S9]

**Verification:**
- `weaver registry check` still passes with full coverage
- All Python contracts match registry YAML (enums, metrics, labels, events, deprecation mappings)
- All metric definitions include instrument type and unit
- All metric definitions include required and recommended attributes (dimensions) [R8-S2] — e.g., `task.lead_time` must specify `task.type` as a recommended dimension

### Phase 3: Live-Check, Diffing, Doc Generation

**Live-check integration:**
- Makefile target: `semconv-live-check` runs `weaver registry live-check --registry semconv/` against the local OTLP collector
- Can validate demo generator output against the registry

**Schema diffing:**
- Makefile target: `semconv-diff` compares current vs tagged release
- Tracks deprecated agent.* -> gen_ai.* migration progress

**Documentation generation [R6-S9, R7-S8]** (committed deliverable, not stretch):
- `semconv/templates/markdown/` with Jinja2 templates
- Generates docs equivalent to `docs/semantic-conventions.md` and `docs/agent-semantic-conventions.md` from the registry
- CI step verifies generated docs match committed docs
- On completion: mark both `docs/semantic-conventions.md` and `docs/agent-semantic-conventions.md` as deprecated, pointing to the generated output

**Pre-commit hook:**
- Add to `.pre-commit-config.yaml`: validate registry on semconv/ changes

**Consistency verification:**
- ~~Script to verify Python enum values match registry YAML enum members~~ (moved to Phase 1 CI [R1-S1, R2-S8])
- ~~Verify `ATTRIBUTE_MAPPINGS` in `otel_genai.py` matches deprecated->replacement pairs in registry~~ (moved to Phase 1 parity script [R4-S9, R5-S8, R6-S5])

## Critical Files (existing, read-only reference)

| File | Role |
|------|------|
| `src/contextcore/contracts/types.py` | Canonical Python enums (TaskStatus, TaskType, Priority, HandoffStatus, InsightType, etc.) |
| `src/contextcore/contracts/metrics.py` | Canonical metric names (MetricName), label names (LabelName), event types (EventType) |
| `src/contextcore/compat/otel_genai.py` | Dual-emit ATTRIBUTE_MAPPINGS dict (agent.* -> gen_ai.*) |
| `docs/semantic-conventions.md` | Current prose documentation (will eventually be generated from registry) |
| `docs/agent-semantic-conventions.md` | Agent-specific attribute documentation |
| `.github/workflows/validate-dependencies.yml` | Existing CI pattern to follow |

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Weaver binary not available in CI | Pin to specific release; use setup-weaver GitHub Action. Pin exact Weaver version in `WEAVER_VERSION` Makefile variable and `.weaver-version` file — Weaver is pre-1.0 and schema format changes between releases. [R5-S2] |
| OTel semconv dependency fetch flaky in CI | Cache the archive; add retry |
| Registry format changes upstream | Pin to tagged OTel semconv release (v1.34.0). **Upgrade cadence [R6-S1, R4-S6]**: the collision monitor owner proposes a dependency upgrade quarterly. Upgrade PR must include `weaver registry diff` output and a `ref:` link integrity check to detect upstream breakage. [R6-S7, R4-S8] |
| Upstream OTel renames/removes a `ref:` attribute | Dedicated CI step validates all `ref:` links resolve against the pinned dependency. Runs on every change to the OTel archive. Weekly non-blocking run against upstream `main` for early warning. [R6-S7, R4-S8] |
| gen_ai.code.* may conflict with future OTel extensions | **Owner**: project lead. **Cadence**: quarterly review of OTel GenAI SIG activity. **Automation [R7-S3]**: GitHub Actions cron job auto-opens a quarterly issue with a checklist for collision review and dependency upgrade, auto-assigns project lead with 1-week escalation to named backup. **Trigger**: if SIG publishes a `gen_ai.code.*` RFC, raise a renaming PR to `contextcore.code.*` within 2 weeks. [R1-S10] |
| Existing Markdown docs drift during transition | Keep hand-maintained docs authoritative until Phase 3 doc generation replaces them. Phase 3 doc generation is a committed deliverable (not stretch). [R6-S9] |
| Python contracts don't match registry | Phase 1 CI gate via `scripts/verify_contracts_parity.py` covers enums, metric names, label names, event types, and deprecation mappings. [R1-S1, R2-S1, R5-S1, R4-S9] |
| Weaver CI blocks unrelated PRs with false positives | Initial 2-week rollout with `continue-on-error: true`. **Graduation criteria [R3-S9, R7-S5]**: 0 false positives across 20+ PRs touching semconv/ OR 4 weeks elapsed, whichever comes first. If <10 qualifying PRs at 4 weeks, extend to 6 weeks with explicit decision log entry. Decision owner: project lead. Tracking: log all `continue-on-error` triggered runs, categorize as TP/FP, document graduation decision. Escape hatch: `[skip-semconv]` label (skips Weaver checks only, never parity script [R5-S5]). Usage logged for audit [R6-S3]. **Abuse threshold [R7-S7]**: if `[skip-semconv]` is used on >10% of semconv-touching PRs in any 4-week window, project lead must investigate root cause and report findings in a tracking issue within 1 week. [R1-S3] |
| Registry needs full revert after Phase 1 merge | **Revert runbook [R3-S3, R9-S5]**: (1) Apply `[skip-semconv]` to unblock immediate PRs. (2) If systemic: revert CI workflow file only (`git revert` the validate-semconv.yml change) — registry YAML files remain for future re-enablement. (3) Circuit breakers: `SEMCONV_CI_DISABLED=true` disables Weaver checks; `PARITY_CI_DISABLED=true` disables the parity script (emergency-only, since `[skip-semconv]` never skips parity — this prevents a deadlock if the parity script itself is broken). (4) If >2 incidents/week post-hardening, revert to `continue-on-error` and investigate. |
| Schema formalization breaks downstream consumers | Inventory known consumers (12 Grafana dashboards, Loki recording rules, alert definitions) before Phase 1 merge. Verify dashboard TraceQL queries reference only attributes present in registry. **Major version bump checklist [R6-S8]** must also verify alerts, recording rules, and Grafana value mappings that depend on specific enum values. [R2-S2] |

---

## Appendix: Iterative Review Log (Applied / Rejected Suggestions)

This appendix is intentionally **append-only**. New reviewers (human or model) should add suggestions to Appendix C, and then once validated, record the final disposition in Appendix A (applied) or Appendix B (rejected with rationale).

### Reviewer Instructions (for humans + models)

- **Before suggesting changes**: Scan Appendix A and Appendix B first. Do **not** re-suggest items already applied or explicitly rejected.
- **When proposing changes**: Append them to Appendix C using a unique suggestion ID (`R{round}-S{n}`).
- **When endorsing prior suggestions**: If you agree with an untriaged suggestion from a prior round, list it in an **Endorsements** section after your suggestion table. This builds consensus signal — suggestions endorsed by multiple reviewers should be prioritized during triage.
- **When validating**: For each suggestion, append a row to Appendix A (if applied) or Appendix B (if rejected) referencing the suggestion ID. Endorsement counts inform priority but do not auto-apply suggestions.
- **If rejecting**: Record **why** (specific rationale) so future models don't re-propose the same idea.

### Areas Substantially Addressed

- **architecture**: 16 suggestions applied (R16-S4, R2-S1, R1-S2, R3-S1, R5-S2, R4-S6, R5-S9, R3-S7, R4-S10, R6-S9, R7-S2, R7-S8, R8-S2, R9-S3, R9-S8, R11-S8)
- **data**: 9 suggestions applied (R16-S3, R1-S5, R2-S7, R3-S2, R6-S10, R5-S4, R3-S10, R7-S4, R13-S5)
- **interfaces**: 4 suggestions applied (R1-S4, R5-S3, R3-S4, R7-S6)
- **ops**: 14 suggestions applied (R15-S1, R16-S5, R1-S6, R2-S3, R2-S10, R6-S1, R5-S5, R3-S6, R4-S5, R7-S3, R7-S10, R10-S6, R13-S1, R14-S4)
- **risks**: 11 suggestions applied (R15-S3, R1-S3, R1-S10, R2-S2, R3-S3, R4-S2, R6-S7, R6-S3, R7-S5, R9-S5, R13-S3)
- **security**: 5 suggestions applied (R15-S5, R2-S4, R6-S4, R7-S7, R11-S9)
- **validation**: 20 suggestions applied (R1-S1, R2-S8, R1-S9, R2-S6, R5-S1, R6-S2, R4-S7, R4-S9, R5-S8, R6-S5, R3-S9, R3-S5, R4-S8, R6-S8, R7-S1, R7-S9, R9-S1, R11-S6, R12-S2, R13-S2)

### Appendix A: Applied Suggestions

| ID | Suggestion | Source | Implementation / Validation Notes | Date |
|----|------------|--------|----------------------------------|------|
| R1-S1 | Enum parity CI gate in Phase 1 | claude-4 | Combined with R2-S1 and R2-S8. Added `scripts/verify_enum_parity.py` to Phase 1 file list (item 10) and CI workflow. Auto-generates expected enums from Python, diffs against YAML. | 2026-02-09 |
| R2-S1 | Auto-generate registry enums from Python source | gemini-2.5 | Combined with R1-S1. The parity script parses `types.py` and generates expected YAML sections. Added `semconv-verify-enums` Makefile target. | 2026-02-09 |
| R2-S8 | Move consistency verification to Phase 1 | gemini-2.5 | Subsumed by R1-S1+R2-S1. Phase 3 consistency verification struck through with forward reference. | 2026-02-09 |
| R1-S2 | Namespace governance policy | claude-4 | Added "Namespace Governance Policy" section to Key Design Decisions with category table and decision criteria. | 2026-02-09 |
| R1-S3 | Rollback plan per phase | claude-4 | CI workflow starts with `continue-on-error: true` for 2 weeks. Added `[skip-semconv]` escape hatch. New risk row for false positives. | 2026-02-09 |
| R1-S4 | Registry–runtime boundary | claude-4 | Added "Registry–Runtime Boundary" section: registry is CI-only governance, Python remains runtime canonical. | 2026-02-09 |
| R1-S5 | Stability levels per attribute group | claude-4 | Added requirement: all attributes must declare `stability:` field. Phase 1 attributes start as `development`. | 2026-02-09 |
| R1-S6 | Versioning/release strategy | claude-4 | Combined with R2-S3. Added "Registry Versioning Policy" section with SemVer table. | 2026-02-09 |
| R2-S3 | Formal SemVer policy for semconv_version | gemini-2.5 | Combined with R1-S6 into unified versioning policy section. | 2026-02-09 |
| R1-S9 | Persist resolved registry as CI artifact | claude-4 | Added artifact upload to CI workflow description for diff-based PR review. | 2026-02-09 |
| R1-S10 | Concrete gen_ai.code.* collision owner/trigger | claude-4 | Expanded risk row with named owner, quarterly cadence, and 2-week trigger for renaming PR. | 2026-02-09 |
| R2-S2 | Downstream consumer impact risk | gemini-2.5 | Added risk row: inventory 12 dashboards + recording rules before Phase 1 merge. | 2026-02-09 |
| R2-S4 | PII/privacy review for attributes | gemini-2.5 | Added "Security & Privacy Considerations" section. Flagged task.assignee for per-deployment guidance. | 2026-02-09 |
| R2-S6 | Explicit type fields for all attributes | gemini-2.5 | Added requirement: all attributes must declare `type:` field. Added to Phase 1 verification checklist. | 2026-02-09 |
| R2-S7 | Enum change governance process | gemini-2.5 | Folded into "Enum source of truth" section and versioning policy (add=minor, remove/rename=major). | 2026-02-09 |
| R2-S10 | Deprecation policy | gemini-2.5 | Added "Deprecation Policy" section: deprecated field, 2-minor-version dual-emit window, removal at next major. | 2026-02-09 |
| R3-S1 | Define parity script YAML parsing contract | claude-4 | Combined with R5-S3. Added "YAML Enum Convention" section with canonical YAML shape, `ref:` skip behavior, and unit test requirements. | 2026-02-09 |
| R5-S3 | Specify YAML enum format convention | claude-4 | Combined with R3-S1 into "YAML Enum Convention" section. | 2026-02-09 |
| R5-S1 | Parity script must cover MetricName/LabelName/EventType | claude-4 | Combined with R6-S2, R4-S7. Renamed script to `verify_contracts_parity.py`, expanded scope to cover `types.py` + `metrics.py` + deprecation mappings. | 2026-02-09 |
| R6-S2 | Expand parity script beyond enums | gemini-2.5 | Combined with R5-S1, R4-S7. | 2026-02-09 |
| R4-S7 | Rename to verify_contracts_parity.py, cover metrics/labels | gemini-2.5 | Combined with R5-S1, R6-S2. | 2026-02-09 |
| R4-S9 | Verify ATTRIBUTE_MAPPINGS matches deprecated: fields | gemini-2.5 | Combined with R5-S8, R6-S5. Added deprecation mapping check to parity script. Phase 3 consistency verification struck through. | 2026-02-09 |
| R5-S8 | Move ATTRIBUTE_MAPPINGS check to Phase 1 | claude-4 | Combined with R4-S9, R6-S5. | 2026-02-09 |
| R6-S5 | Accelerate deprecation mapping verification | gemini-2.5 | Combined with R4-S9, R5-S8. | 2026-02-09 |
| R3-S2 | Specify body schemas for task events | claude-4 | Added body schema requirement to Phase 1 event file specification. task.commented uses comment_length not comment_text. | 2026-02-09 |
| R3-S3 | Registry-level revert runbook with circuit-breaker | claude-4 | Combined with R3-S9. Added revert runbook to Risk Mitigation table with 4-step procedure and SEMCONV_CI_DISABLED env var. | 2026-02-09 |
| R3-S9 | Define graduation criteria for continue-on-error | claude-4 | Combined with R3-S3, R4-S2. Added threshold (0 FP across 20+ PRs), tracking mechanism, and decision owner. | 2026-02-09 |
| R4-S2 | Graduation criteria + skip-semconv monitoring | gemini-2.5 | Subsumed by R3-S3 + R3-S9 + R6-S3. | 2026-02-09 |
| R3-S4 | Validate manifest format against pinned Weaver version | claude-4 | Added day-one smoke test to Phase 1 file #1 description. | 2026-02-09 |
| R3-S5 | Phase 1 spans only reference Phase 1 attributes | claude-4 | Added scope rule to Phase 1 file #6 description. | 2026-02-09 |
| R5-S2 | Pin Weaver CLI version | claude-4 | Added WEAVER_VERSION variable to Makefile, .weaver-version file, and CI workflow. Updated Risk Mitigation table. | 2026-02-09 |
| R6-S1 | Quarterly OTel dependency upgrade cadence | gemini-2.5 | Combined with R4-S6. Added upgrade cadence to Risk Mitigation table. | 2026-02-09 |
| R4-S6 | Quarterly OTel upgrade cadence | gemini-2.5 | Combined with R6-S1. | 2026-02-09 |
| R6-S7 | Risk: upstream ref: breakage on OTel upgrades | gemini-2.5 | Combined with R4-S8. Added new risk row and CI step for ref: link validation. | 2026-02-09 |
| R4-S8 | CI check for broken ref: links after upgrade | gemini-2.5 | Combined with R6-S7. | 2026-02-09 |
| R5-S5 | Define [skip-semconv] scope (Weaver vs parity) | claude-4 | Clarified in CI workflow: label skips Weaver checks but never parity script. | 2026-02-09 |
| R6-S3 | Track and audit [skip-semconv] usage | gemini-2.5 | CI posts comment when label is used, for periodic audit. | 2026-02-09 |
| R6-S4 | PII review in ongoing PR process | gemini-2.5 | Added PR template checkbox and ongoing process paragraph to Security section. | 2026-02-09 |
| R6-S10 | Default-deny policy for free-text fields | gemini-2.5 | Added free-text field policy to Security section. | 2026-02-09 |
| R3-S6 | CI artifact diff computation for resolved output | claude-4 | Updated CI workflow to diff resolved output against base branch, not just upload blob. | 2026-02-09 |
| R5-S4 | Resolve HandoffStatus discrepancy before Phase 2 | claude-4 | Added action item in Enum source of truth section and Phase 2 pre-merge checklist. | 2026-02-09 |
| R5-S9 | Requirement level guidelines for span attributes | claude-4 | Added "Requirement Level Guidelines" section to Key Design Decisions. | 2026-02-09 |
| R3-S7 | Specify metric instrument types before Phase 2 | claude-4 | Added instrument type/unit table to Phase 2 task_metrics.yaml specification. | 2026-02-09 |
| R3-S10 | Clarify string[] wire format for array attributes | claude-4 | Added note to YAML Enum Convention section: string[] must use list[str], not comma-separated. | 2026-02-09 |
| R4-S5 | Audit downstream usage before attribute removal | gemini-2.5 | Added step 3 (downstream audit) to Deprecation Policy. | 2026-02-09 |
| R4-S10 | PR template: update spans/events when attrs change | gemini-2.5 | Added to Phase 1 file #11 (PR template additions). | 2026-02-09 |
| R6-S8 | Deepen downstream consumer impact analysis | gemini-2.5 | Expanded Risk Mitigation entry to include alerts, recording rules, and Grafana value mappings in major version bump checklist. | 2026-02-09 |
| R6-S9 | Commit doc generation as Phase 3 deliverable | gemini-2.5 | Changed "stretch" to committed deliverable. Added deprecation notice for semantic-conventions.md on completion. | 2026-02-09 |
| R7-S1 | Bidirectional parity (Python↔YAML both directions) | claude-4 | Added explicit bidirectional check requirement and test fixtures to Phase 1 item 10. | 2026-02-09 |
| R7-S2 | Extend smoke test to validate agent.yaml ref: resolution | claude-4 | Extended Phase 1 item 1 smoke test to include minimal agent.yaml with ref: to gen_ai.agent.id for end-to-end dependency validation. | 2026-02-09 |
| R7-S3 | GitHub Actions cron for quarterly collision review | claude-4 | Added automation to Risk Mitigation gen_ai.code.* row: auto-opens quarterly issue with checklist and escalation. | 2026-02-09 |
| R7-S4 | ISO 8601 date format annotation for date attributes | claude-4 | Added note: annotations to task.yaml (task.due_date) and sprint.yaml (sprint.start_date, sprint.end_date) specifying ISO 8601 format. | 2026-02-09 |
| R7-S5 | Time cap for graduation criteria | claude-4 | Added "OR 4 weeks, whichever comes first" to graduation criteria. If <10 qualifying PRs at 4 weeks, extend to 6 weeks. | 2026-02-09 |
| R7-S6 | Explicit mapping table and orphan detection in parity script | claude-4 | Added mapping table requirement and orphan detection to Phase 1 item 10. Script fails if any registry YAML has no corresponding mapping entry. | 2026-02-09 |
| R7-S7 | [skip-semconv] abuse threshold | claude-4 | Added >10% usage threshold in 4-week window triggering investigation to Risk Mitigation table. | 2026-02-09 |
| R7-S8 | Phase 3 doc generation covers agent-semantic-conventions.md | claude-4 | Extended Phase 3 doc generation scope to include both semantic-conventions.md and agent-semantic-conventions.md. | 2026-02-09 |
| R7-S9 | Raw vs resolved YAML parsing clarification | claude-4 | Added note to Phase 1 item 10: Phase 1 parses raw YAML (sufficient); Phase 2 evaluates switch to resolved if cross-file ref: introduced. | 2026-02-09 |
| R7-S10 | .weaver-version as single source for Makefile and CI | claude-4 | Updated Phase 1 item 9: Makefile reads WEAVER_VERSION via $(shell cat .weaver-version). Single source of truth. | 2026-02-09 |
| R8-S2 | Metric definitions must include attribute dimensions | gemini-2.5 | Added to Phase 2 verification: all metrics must include required/recommended attributes (dimensions). | 2026-02-09 |
| R9-S1 | Phase 2 must extend parity script to cover all enums in types.py | claude-4 | Added to Phase 2 pre-merge checklist: extend mapping table to all ~15 enums or document exclusion rationale for each. | 2026-02-09 |
| R9-S3 | Assign orphan events to YAML files | claude-4 | Added subtask.completed to Phase 1 task_events.yaml. Created Phase 2 sprint_events.yaml for sprint.started and sprint.ended. | 2026-02-09 |
| R9-S5 | PARITY_CI_DISABLED circuit breaker for parity script | claude-4 | Added to revert runbook: PARITY_CI_DISABLED=true env var as emergency escape when parity script itself is broken (prevents CI deadlock). | 2026-02-09 |
| R9-S8 | Document Priority vs Criticality distinction in registry | claude-4 | Combined with R10-S1 (lighter documentation approach over code refactoring). Added to Phase 2 pre-merge checklist: business.yaml must include note: annotations distinguishing business.criticality from task.priority. | 2026-02-09 |
| R10-S6 | Stability graduation criteria | gemini-2.5 | Added criteria to Registry Versioning Policy: development→experimental requires deployed emission; experimental→stable requires 3 months production + dashboard/alert reference + no recent breaking changes. | 2026-02-09 |
| R11-S6 | task.deliverables_verified is phantom event not in EventType | claude-4 | Added action item to Phase 1 item 7: add TASK_DELIVERABLES_VERIFIED to EventType enum before creating task_events.yaml. | 2026-02-09 |
| R11-S8 | Add note: to task.priority distinguishing from business.criticality | claude-4 | Added note: annotation to Phase 1 task.yaml: "Work-item scheduling priority. Distinct from business.criticality." | 2026-02-09 |
| R11-S9 | Add note: to task.url surfacing PII sensitivity | claude-4 | Added note: annotation to Phase 1 task.yaml: "May contain internal URLs. Deployers should evaluate exposure risk." | 2026-02-09 |
| R12-S2 | Deprecation parity check must verify source attribute still exists | gemini-2.5 | Extended deprecation mapping check: verifies deprecated source attributes still exist in Python. Unit test fixture for premature removal. | 2026-02-09 |
| R13-S1 | Add a SHA-256 integrity lockfile for the OTel semconv dependency archive to prevent supply-chain tampering via mutable git tags. | claude-4 (claude-opus-4-6) | This addresses a genuine supply-chain risk: git tags are mutable, so the pinned v1.34.0 tag could be re-pointed to a different commit. A SHA-256 lockfile is low-cost, high-value, and complements the existing version pinning and quarterly upgrade cadence (R6-S1). No prior suggestion covers archive integrity verification. | 2026-02-09 20:01:45 UTC |
| R13-S2 | Define an explicit contract for event body schema validation in the parity script, or document it as a known Phase 2 gap. | claude-4 (claude-opus-4-6) | The plan mandates event body schemas (R3-S2) but the parity script scope only covers enums, string constants, and deprecation mappings — event body field names/types are never cross-checked against Python-side event payload structures. This is a real validation gap. At minimum it should be documented as a known limitation with a tracking issue; ideally Phase 1 adds basic body field validation. | 2026-02-09 20:01:45 UTC |
| R13-S3 | Add a risk mitigation entry for Weaver schema language breaking changes between pinned versions, and decouple Weaver tool upgrades from OTel dependency upgrades. | claude-4 (claude-opus-4-6) | Weaver is pre-1.0 and schema language changes are realistic. The plan already pins both Weaver and OTel semconv versions independently but doesn't address the interaction. Separating these upgrades into distinct PRs is a low-cost process change that isolates breakage and makes debugging significantly easier. This fills a genuine gap in the risk table. | 2026-02-09 20:01:45 UTC |
| R13-S5 | Mandate a `schema_url` field in `registry_manifest.yaml` that maps to the OTLP SchemaUrl on emitted resources/scopes. | claude-4 (claude-opus-4-6) | OTel's schema mechanism relies on SchemaUrl for programmatic signal transformation across versions. The plan versions the registry via `semconv_version` but never connects it to the OTLP wire format. This is a genuine data-layer gap — without it, consumers receiving signals from different ContextCore versions cannot distinguish them. This complements R14-S1's resource attribute approach and is part of the OTel specification's intended usage pattern. | 2026-02-09 20:01:45 UTC |
| R14-S4 | Require a mandatory justification section in the PR body when using `[skip-semconv]`, with CI enforcement. | gemini-2.5 (gemini-2.5-pro) | The plan already logs skip usage (R6-S3) and has an abuse threshold (R7-S7), but neither captures the *reason* for the skip. Requiring justification is a low-cost CI enhancement that significantly improves the audit trail, makes the abuse threshold investigation (R7-S7) more actionable, and discourages casual use. This is a natural strengthening of the existing escape hatch governance. | 2026-02-09 20:01:45 UTC |
| R15-S1 | Add a CI co-change detector that warns when contracts or semconv files are modified without corresponding changes to the other side. | claude-4 (claude-opus-4-6) | This closes a real gap: the parity script validates committed state but cannot detect incomplete commits where only one side is updated. A non-blocking warning is low-risk and high-value as a second line of defense for the governance model. Complements the existing parity script (R7-S1) without adding friction. | 2026-02-09 20:15:49 UTC |
| R15-S3 | Add a risk entry and fallback strategy for the scenario where the pinned OTel semconv v1.34.0 archive lacks the required gen_ai.* attributes for ref: resolution. | claude-4 (claude-opus-4-6) | The plan already acknowledges this possibility in the day-one smoke test description but treats it as a quick fix. The gen_ai.* namespace is relatively new and has changed across OTel semconv tags. A concrete fallback (temporarily inlining definitions) prevents Phase 1 from being blocked and deserves explicit documentation in the risk table. This is a high-severity Phase 1 blocker risk. | 2026-02-09 20:15:49 UTC |
| R15-S5 | Pin the OTel semconv dependency archive by commit SHA or checksum rather than just a mutable Git tag to prevent supply chain attacks. | claude-4 (claude-opus-4-6) | This is a legitimate supply chain security concern. The OTel semconv archive is the sole external dependency and is used to resolve ref: attributes in CI. Tags are mutable in Git, and the plan has already accepted multiple security suggestions (R2-S4, R6-S4). Adding a SHA256 checksum verification is low-effort, high-impact, and consistent with the existing security posture. This is especially important given that the archive content directly influences what attributes are considered valid. | 2026-02-09 20:15:49 UTC |
| R16-S3 | Formalize a distinct stability and deprecation lifecycle for individual enum members, separate from their parent attribute. | gemini-2.5 (gemini-2.5-pro) | This addresses a genuine governance gap. The plan already states that adding enum members is a minor bump and removing them is a major bump (R2-S7), but doesn't address the stability level of individual members. A stable attribute with a new development-stability member is a real scenario that can break downstream value mappings in Grafana dashboards. Requiring per-member stability markers is consistent with the existing YAML enum convention (R3-S1) which already shows a stability field on members, and aligns with the OTel semconv model. This also has 3 endorsements on R11-S8 which covers related enum annotation concerns. | 2026-02-09 20:15:49 UTC |
| R16-S4 | Broaden the quarterly collision monitoring to check all ContextCore custom namespaces (not just gen_ai.code.*) against the latest OTel semconv main branch. | gemini-2.5 (gemini-2.5-pro) | The current collision monitoring (R7-S3) focuses narrowly on gen_ai.code.* but ignores the possibility that OTel could introduce attributes in namespaces like task.* or project.*. While this risk is lower for domain-specific namespaces, the marginal cost of broadening the automated quarterly check to diff the entire registry against upstream main is minimal since the cron job infrastructure is already planned. This provides valuable early warning and is a natural extension of the existing collision monitoring. | 2026-02-09 20:15:49 UTC |
| R16-S5 | Use a partial generation strategy for Phase 3 documentation where Weaver generates schema table snippets that are included into hand-written narrative documents. | gemini-2.5 (gemini-2.5-pro) | This is a practical and important clarification for Phase 3. The current plan says generated docs should match committed docs and eventually replace hand-maintained files, but full file generation would destroy valuable narrative context, examples, and explanatory prose. A partial generation approach (machine-generated schema tables included into human-maintained documents) is the standard best practice for this pattern and prevents the common failure mode of auto-generated documentation that lacks context. This aligns with R6-S9 and R7-S8 goals while being more practical. | 2026-02-09 20:15:49 UTC |

### Appendix B: Rejected Suggestions (with Rationale)

| ID | Suggestion | Source | Rejection Rationale | Date |
|----|------------|--------|---------------------|------|
| R1-S7 | SHA256 checksum for OTel semconv dependency archive | claude-4 | GitHub archive URLs over HTTPS are standard practice for CI dependencies. The marginal security benefit of pinning a hash does not justify the friction of maintaining and updating it on every OTel semconv version bump. The archive is already pinned to a specific git tag (v1.34.0). | 2026-02-09 |
| R2-S5 | Consistent `contextcore.*` prefix for all proprietary attrs | gemini-2.5 | Prefixing `task.*` as `contextcore.task.*` would be a breaking change across all 12 dashboards, Loki recording rules, and the Python SDK emit layer. The existing unprefixed namespaces (`task.*`, `project.*`, etc.) are well-established and do not conflict with any OTel namespace. The namespace governance policy (R1-S2) addresses collision risk for OTel-extension namespaces specifically. | 2026-02-09 |
| R2-S9 | Proactively namespace as `contextcore.gen_ai.code.*` | gemini-2.5 | Triple-nested namespacing (`contextcore.gen_ai.code.*`) is awkward and non-standard. The concrete monitoring/trigger approach (R1-S10) is preferred: named owner, quarterly review, and a 2-week renaming SLA if OTel publishes a conflicting RFC. This balances collision risk against usability. | 2026-02-09 |
| R1-S8 | Include metrics YAML in Phase 1 | claude-4 | **Deferred to Phase 2** (not rejected). Phase 1 scope is already expanded with enum parity CI, stability/type requirements, and governance policies. Metrics validation remains high-value and is the first Phase 2 deliverable. | 2026-02-09 |
| R5-S7 | Restrict [skip-semconv] to CODEOWNERS | claude-4 | This is an internal project, not open-source. CODEOWNERS-gated label access adds process overhead disproportionate to the risk. Usage logging (R6-S3) provides sufficient accountability. | 2026-02-09 |
| R5-S6 | Vendor a checksummed copy of OTel archive | claude-4 | Vendoring a third-party archive into the repo adds maintenance burden (must update on every upgrade). Pinned git tag + CI cache + retry is sufficient. The quarterly upgrade cadence (R6-S1) ensures staleness is managed. | 2026-02-09 |
| R4-S4 | Embed pii_review: object in YAML files | gemini-2.5 | Structured PII metadata per attribute group is over-engineering. The PR template checkbox (R6-S4) and free-text default-deny policy (R6-S10) provide sufficient governance without adding schema overhead to every YAML file. | 2026-02-09 |
| R6-S6 | Long-term vision for registry-runtime boundary | gemini-2.5 | Speculative. The CI-only decision (R1-S4) is clear and can evolve when a concrete runtime validation use case arises. Adding forward-looking vision statements to an implementation plan adds ambiguity without actionable value. | 2026-02-09 |
| R4-S1 | Reverse check: every registry attr used in SDK | gemini-2.5 | **Deferred to Phase 2** (not rejected). Phase 1 scope is already significantly expanded. Reverse usage checking is valuable but not blocking for initial registry creation. | 2026-02-09 |
| R4-S3 | SDK exposes SEMCONV_VERSION constant | gemini-2.5 | **Deferred to Phase 2** (not rejected). This is a runtime concern; Phase 1 is focused on CI governance. Adding SDK constants requires a release coordination step that doesn't belong in the registry-first phase. | 2026-02-09 |
| R3-S8 | PII review for ref: OTel attributes (k8s.*, service.*) | claude-4 | **Deferred**. Referenced OTel attributes are standardized and widely deployed. Reviewing `k8s.pod.name` for PII is out of scope for the ContextCore registry — that's an OTel-level concern. Focus PII review on ContextCore-owned attributes. | 2026-02-09 |
| R5-S10 | Post-hardening incident procedure | claude-4 | Subsumed by R3-S3 (revert runbook) which includes post-hardening escalation: >2 incidents/week triggers revert to continue-on-error. | 2026-02-09 |
| R8-S1 | Production schema conformance monitoring via OTel Collector processor | gemini-2.5 | Out of scope. Phase 3 live-check covers local validation. Production-grade collector processors are a separate initiative requiring dedicated design, not an addendum to a registry formalization plan. | 2026-02-09 |
| R8-S3 | Paired attributes for PII-sensitive fields (task.assignee.id/name) | gemini-2.5 | Over-engineering. The current per-deployment guidance approach is appropriate — renaming `task.assignee` to a sub-attribute pair is a breaking change across all dashboards and SDK emit code for marginal safety gain. Deployments handling PII can configure hashing at the collector level. | 2026-02-09 |
| R8-S4 | Machine-readable conditions for conditionally_required | gemini-2.5 | Premature. Weaver's condition syntax is not standardized enough for custom registries. The prose description in requirement_level guidelines is sufficient for Phase 1-2. Revisit when Weaver adds formal condition evaluation. | 2026-02-09 |
| R8-S6 | Optional code generator (YAML → Python enums) | gemini-2.5 | Contradicts the Registry–Runtime Boundary decision (R1-S4). The parity script ensures correctness by verification, not generation. Introducing an optional generator creates two valid workflows (generate vs hand-write + verify), increasing cognitive load. | 2026-02-09 |
| R8-S7 | Collision monitor owners for all ContextCore-owned namespaces | gemini-2.5 | Over-engineering. ContextCore-owned namespaces (task.*, project.*, etc.) have no realistic collision risk with OTel — they are domain-specific. The gen_ai.code.* collision monitor exists because it extends an upstream namespace. Applying the same overhead to all namespaces adds process without proportional risk reduction. | 2026-02-09 |
| R8-S8 | Secret detection for YAML values and URL scrubbing policy | gemini-2.5 | Over-engineering. Registry YAML contains schema definitions, not runtime data — there are no actual values to scan for secrets. URL scrubbing is an SDK-level concern, not a registry governance concern. The existing PII review process (R6-S4) is sufficient. | 2026-02-09 |
| R8-S9 | Formalize [skip-semconv] audit remediation process | gemini-2.5 | Subsumed by R7-S7 (abuse threshold with investigation trigger) and R6-S3 (usage logging). Adding a Slack channel/Jira ticket pipeline for an internal project is disproportionate. | 2026-02-09 |
| R8-S10 | Mutable array attribute update semantics | gemini-2.5 | Out of scope. Array mutation semantics are an SDK/emit-layer concern, not a registry schema concern. The registry declares the type; the SDK documentation covers emit patterns. | 2026-02-09 |
| R8-S5 | Semantic Impact Analysis CI comment on registry PRs | gemini-2.5 | **Deferred to Phase 3** (not rejected). This enhances the diff-based PR review (R1-S9, R3-S6) with structured BREAKING/MINOR/PATCH labels. Good idea but requires custom tooling beyond what Weaver provides. More appropriate after the basic CI pipeline is established and proven. | 2026-02-09 |
| R9-S2 | Classify MetricName members as registry vs project-prefixed | claude-4 | Premature Phase 2 implementation detail. The mapping table (R7-S6) already requires explicit enum→YAML mappings; members with no YAML mapping are implicitly excluded. | 2026-02-09 |
| R9-S4 | Audit ProjectSchema/REQUIRED_LABELS for deprecated label usage | claude-4 | Runtime code change, not a registry plan concern. The deprecation policy (R2-S10) and downstream audit (R4-S5) already cover this at the appropriate phase boundary. | 2026-02-09 |
| R9-S6 | Specify collector setup for Phase 3 live-check | claude-4 | Phase 3 implementation detail. The existing docker-compose infrastructure is documented elsewhere. Over-specifying Phase 3 now adds plan bloat. | 2026-02-09 |
| R9-S7 | Parity check for RecordingRuleName/AlertRuleName | claude-4 | These enums reference Prometheus metric names, not OTel semantic convention attributes — different governance layer. The major-version checklist (R6-S8) already covers manual review. | 2026-02-09 |
| R9-S9 | Extend free-text policy to sprint.goal and existing attributes | claude-4 | sprint.goal is being formalized as its actual type (string). The free-text policy governs new additions. Adding PII notes to every existing string attribute is over-engineering. | 2026-02-09 |
| R9-S10 | Add note: for histogram bucket boundaries in registry | claude-4 | Runtime configuration, not schema. Bucket boundaries are deployment-specific tuning, not semantic conventions. | 2026-02-09 |
| R10-S1 | Merge Priority and Criticality enums | gemini-2.5 | Runtime code refactoring outside plan scope. Subsumed by R9-S8 (documentation approach — add note: annotations distinguishing the two). | 2026-02-09 |
| R10-S2 | Fix ProjectSchema.metric() prefix logic | gemini-2.5 | Runtime bug fix, not a registry plan concern. Should be filed as a separate issue. | 2026-02-09 |
| R10-S3 | Extend free-text policy to string[] arrays | gemini-2.5 | Already covered by YAML Enum Convention (R3-S1) which specifies string[] wire format. High-cardinality labels are a deployment concern, not schema governance. | 2026-02-09 |
| R10-S4 | Bidirectional orphan detection for contract files | gemini-2.5 | Over-engineering. The contracts directory has 2 known files. File-system scanning for a known-small set adds complexity without proportional value. | 2026-02-09 |
| R10-S5 | Developer helper script to generate YAML from Python | gemini-2.5 | Contradicts Registry–Runtime Boundary (R1-S4). The parity script verifies, not generates. Same rationale as R8-S6 rejection. | 2026-02-09 |
| R10-S8 | Automated PII keyword linter for attribute names | gemini-2.5 | Over-engineering. PR template checkbox (R6-S4) and free-text default-deny policy (R6-S10) are sufficient. Keyword linters produce false positives on legitimate attributes like service.name. | 2026-02-09 |
| R10-S9 | Use resolved registry output instead of raw YAML for parity | gemini-2.5 | Already decided in R7-S9: Phase 1 uses raw YAML (sufficient); Phase 2 evaluates switch to resolved. Re-proposal of a settled decision. | 2026-02-09 |
| R10-S7 | Phase 3 live-check should validate data types | gemini-2.5 | **Deferred to Phase 3** (not rejected). Good enhancement but Phase 3 implementation detail. Type validation is a natural extension of live-check and should be specified when Phase 3 work begins. | 2026-02-09 |
| R10-S10 | Expand SessionStatus enum with FAILED/CANCELLED | gemini-2.5 | **Deferred** (not rejected). Runtime code change worth considering but not a registry plan concern. File as a separate issue. | 2026-02-09 |
| R11-S1 | Cover RecordingRuleName/AlertRuleName in parity script | claude-4 | Re-proposal of R9-S7 (rejected round 5). Prometheus rule names are not OTel semantic convention attributes — different governance layer. | 2026-02-09 |
| R11-S2 | Audit ProjectSchema.promql() for deprecated LabelName usage | claude-4 | Re-proposal of R9-S4 (rejected round 5). Runtime code change, not a registry plan concern. | 2026-02-09 |
| R11-S3 | Orphan detection for spans/events/metrics subdirectories | claude-4 | `weaver registry check` validates structural correctness of these files. Orphan detection is specifically for registry attribute YAML where Weaver doesn't enforce Python↔YAML parity. | 2026-02-09 |
| R11-S4 | Troubleshooting guide for day-one smoke test failure | claude-4 | Over-specifying a manual developer step. Standard diagnostic applies: check Weaver docs, verify GitHub availability, try alternate tag. | 2026-02-09 |
| R11-S5 | Registry counterpart for histogram bucket boundaries | claude-4 | Re-proposal of R9-S10 (rejected round 5). Bucket boundaries are runtime configuration, not semantic conventions. | 2026-02-09 |
| R11-S7 | Dead-man's switch for quarterly cron job | claude-4 | Over-engineering. A manual calendar reminder as fallback is proportionate. Monitoring the monitoring automation is recursive. | 2026-02-09 |
| R11-S10 | Verify BSP_*/BLRP_* constants match SDK version | claude-4 | Out of scope. SDK reference values, not semantic conventions. | 2026-02-09 |
| R12-S1 | Model ProjectSchema constraints in registry | gemini-2.5 | Out of scope. ProjectSchema defines project-specific value sets, not semantic conventions. The registry governs attribute names/types, not project-specific allowed values. | 2026-02-09 |
| R12-S3 | Clarify RecordingRuleName/AlertRuleName governance | gemini-2.5 | Third time proposed (R9-S7, R11-S1). Already rejected twice. Out of registry scope. | 2026-02-09 |
| R12-S4 | Production telemetry validation via collector processor | gemini-2.5 | Re-proposal of R8-S1 (rejected round 5). Production collector processors are a separate initiative. | 2026-02-09 |
| R12-S5 | Formal ticketed downstream impact assessment | gemini-2.5 | Over-engineering for an internal project. Deprecation policy (R2-S10) + downstream audit (R4-S5) + major-version checklist (R6-S8) already cover this. | 2026-02-09 |
| R12-S6 | Mirror OTel dependency archive with checksum | gemini-2.5 | Re-proposal of R1-S7 and R5-S6, both previously rejected. Pinned git tag + HTTPS is sufficient. | 2026-02-09 |
| R12-S8 | Granular [skip-weaver] and [skip-parity] labels | gemini-2.5 | Already addressed by R9-S5 (PARITY_CI_DISABLED env var). Adding another label taxonomy creates confusion. Env var is the emergency escape; [skip-semconv] is the normal escape. | 2026-02-09 |
| R12-S9 | Machine-readable format field for date attributes | gemini-2.5 | Weaver doesn't support a format field on string-typed attributes. The note: annotation (R7-S4) is the pragmatic choice. | 2026-02-09 |
| R12-S7 | Make HandoffStatus resolution a Phase 1 blocker | gemini-2.5 | **Deferred** (not rejected). Already an action item (R5-S4) for resolution before Phase 2. Making it a Phase 1 blocker is too strong since handoff.yaml is Phase 2 scope. Worth revisiting during Phase 1 if easy to resolve alongside agent.yaml work. | 2026-02-09 |
| R12-S10 | Proactive namespace reservation in OTel SIG | gemini-2.5 | **Deferred** (not rejected). Good community practice but not a plan deliverable. Worth doing informally when Phase 1 ships. | 2026-02-09 |
| R13-S4 | Specify behavior when ContextCore-owned attributes shadow upstream OTel attribute names, and add collision detection in the weekly upstream scan. | claude-4 (claude-opus-4-6) | The existing namespace governance policy (R1-S2) and weekly upstream main scan (R6-S7) already provide collision monitoring infrastructure. Adding a separate grep for all ContextCore-owned attribute names against upstream is incremental over what R6-S7 already does. The namespaces like `task.*`, `project.*`, `sprint.*` are domain-specific enough that collision risk is very low. This adds complexity for a speculative risk that the existing mechanisms already cover. | 2026-02-09 20:01:45 UTC |
| R14-S1 | Add a `contextcore.semconv.version` resource attribute populated from the registry manifest during the build process. | gemini-2.5 (gemini-2.5-pro) | R13-S5 (accepted) covers the same need more correctly by using OTel's standard `SchemaUrl` mechanism rather than a custom resource attribute. The OTel specification already defines SchemaUrl for exactly this purpose. Adding a redundant custom attribute creates two versioning mechanisms and deviates from OTel conventions. The plan's registry-runtime boundary (R1-S4) also positions the registry as CI-only, so build-time injection into the SDK conflicts with that design decision. | 2026-02-09 20:01:45 UTC |
| R14-S2 | Implement a production OTLP sampling validator that runs `weaver registry live-check` against 1% of production data and alerts on conformance failures. | gemini-2.5 (gemini-2.5-pro) | This is a significant operational system that goes well beyond the plan's scope. Phase 3 already includes live-check integration as a developer tool against a local collector. Jumping to production sampling with alerting SLAs is premature — the plan hasn't even completed Phase 1 yet. The cost/complexity is high and the incremental value over CI validation + Phase 3 local live-check is not justified at this stage. This could be a future Phase 4 consideration. | 2026-02-09 20:01:45 UTC |
| R14-S3 | Add a `metadata.owner` field to each attribute group YAML file and define a dispute resolution process. | gemini-2.5 (gemini-2.5-pro) | ContextCore appears to be a relatively small project (one project lead referenced throughout, ~185 attributes). Formal per-file ownership metadata and dispute resolution processes add governance overhead disproportionate to the team size. The existing namespace governance policy (R1-S2) and collision monitor owner role already provide sufficient accountability. This is premature formalization that can be added later if the contributor base grows significantly. | 2026-02-09 20:01:45 UTC |
| R14-S5 | Define recurring attribute patterns (like `*.id`) in a central `_base.yaml` file and use local `ref:` pointers to enforce DRY. | gemini-2.5 (gemini-2.5-pro) | The similarity between `task.id` and `project.id` is superficial — they share a type (string) and a naming pattern, but their semantics, stability levels, and documentation will diverge. Introducing internal `ref:` inheritance adds complexity to the parity script (which currently uses raw YAML parsing per R7-S9) and creates a fragile coupling where changing the base definition affects all inheritors. The plan already explicitly chose raw YAML parsing for Phase 1 simplicity. With ~185 attributes across well-separated namespaces, the DRY violation is minimal and the maintenance cost of the proposed abstraction outweighs the benefit. | 2026-02-09 20:01:45 UTC |
| R15-S2 | Define and enforce a style policy for attribute brief and note fields including character limits and Markdown formatting rules. | claude-4 (claude-opus-4-6) | While consistency is desirable, this is premature optimization. Phase 1 has a small number of contributors and few note fields. The overhead of designing, documenting, and enforcing a lint policy for free-text annotations is disproportionate at this stage. This can be addressed organically in Phase 3 when doc generation templates are authored and inconsistencies become visible. | 2026-02-09 20:15:49 UTC |
| R15-S4 | Require ≥90% branch coverage for the verify_contracts_parity.py script's unit tests. | claude-4 (claude-opus-4-6) | The plan already requires unit tests with known-good and known-bad fixtures covering key paths (R7-S1, R7-S9). Adding a specific coverage threshold is a micromanagement-level detail for a planning document and is better handled as a code review standard. The existing test fixture requirements (bidirectional mismatch, orphan detection, ref: skip) effectively target the critical branches. An arbitrary 90% bar may also incentivize coverage gaming rather than meaningful tests. | 2026-02-09 20:15:49 UTC |
| R16-S1 | Introduce a managed parity exception allowlist mechanism for the verify_contracts_parity.py script. | gemini-2.5 (gemini-2.5-pro) | The plan already has multiple escape mechanisms: the [skip-semconv] label (which intentionally doesn't skip parity, by design), the PARITY_CI_DISABLED emergency circuit breaker (R9-S5), and the initial continue-on-error rollout period. Adding a formal allowlist undermines the core design principle that parity failures indicate real drift and should never be bypassed casually. The bidirectional enforcement is the primary governance guarantee; weakening it with an allowlist creates a slippery slope where exceptions accumulate. If runtime code leads YAML, both should be updated in the same PR. | 2026-02-09 20:15:49 UTC |
| R16-S2 | Add a mandatory public comment period before removing deprecated attributes in a major version bump. | gemini-2.5 (gemini-2.5-pro) | The plan already includes a downstream audit (R4-S5) of known consumers and a major version bump checklist (R6-S8). A formal public comment period introduces significant process overhead (3-4 weeks delay per breaking change) that is disproportionate for a project at this scale. The existing deprecation policy with its dual-emit window of at least 2 minor versions already provides ample notice. Dark matter consumers can be addressed through the existing communication step in the deprecation policy rather than a formal SOP. | 2026-02-09 20:15:49 UTC |

### Appendix C: Incoming Suggestions (Untriaged, append-only)

#### Review Round R1

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 17:30:11 UTC
- **Scope**: Architecture-focused review for OTel Weaver registry design, schema governance, and CI integration safety

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R1-S1 | Validation | critical | Add an automated cross-check script in Phase 1 (not Phase 3) that programmatically verifies Python enum members match registry YAML enum values, and fail CI on mismatch. | The plan acknowledges enum drift as the motivating problem but defers automated enforcement to Phase 3. Between Phase 1 and Phase 3, the same drift will recur silently. The "Phase 1 verification step explicitly cross-checks" is described only as a one-time manual check, not a CI gate. Moving this to Phase 1 CI eliminates the window of re-divergence. | Phase 1 verification criteria and `.github/workflows/validate-semconv.yml` | CI job runs `python scripts/verify_enum_parity.py` and exits non-zero on any mismatch; PR that adds a Python enum member without updating YAML (or vice versa) is blocked. |
| R1-S2 | Architecture | high | Define an explicit namespace governance policy that distinguishes ContextCore-owned namespaces from OTel-extension namespaces (`gen_ai.code.*`) and documents the decision criteria for each. | The plan places `gen_ai.code.*` attributes in the ContextCore registry, extending an OTel-governed namespace. This is acknowledged as a risk but lacks a formal policy for when to use `contextcore.*` vs extend `gen_ai.*`. Without a policy, future contributors will inconsistently extend upstream namespaces. | New section between "Key Design Decisions" and "Phased Implementation", titled "Namespace Governance Policy" | Review checklist item for any new attribute group requiring namespace justification; policy document reviewed during Phase 2 attribute expansion. |
| R1-S3 | Risks | high | Add a rollback plan for each phase, specifying how to revert if Weaver integration breaks existing CI pipelines or telemetry emission. | The risk table covers external dependencies but has no rollback strategy. If `weaver registry check` introduces false-positive failures or blocks unrelated PRs, the team needs a documented escape path (e.g., make the Weaver CI step non-blocking for the first N sprints, or gate behind a label). | Risk Mitigation table, as new rows for "Weaver CI blocks unrelated PRs" and "Registry validation rejects valid telemetry" | Dry-run the workflow in non-blocking (`continue-on-error: true`) mode for 2 weeks; track false-positive rate before making it a hard gate. |
| R1-S4 | Interfaces | high | Specify how the registry will be consumed at runtime — whether the Python SDK will import/read the YAML at build time to generate code, or whether the registry is purely a CI/governance artifact with no runtime coupling. | The plan is silent on whether the registry feeds back into the Python SDK. If it's CI-only, the Python enums remain the runtime source and the registry is a parallel governance layer. If code generation is intended, the architecture needs a build step. This ambiguity will cause confusion about which artifact is truly canonical. | Key Design Decisions section, new subsection "Registry–Runtime Boundary" | Document explicitly states one of: (a) registry is CI-only governance, Python remains runtime canonical, or (b) registry generates Python code. Phase 1 PR description includes this decision. |
| R1-S5 | Data | medium | Declare attribute stability levels (`development`, `experimental`, `stable`) for each attribute group, as Weaver supports stability metadata and OTel semconv requires it. | The registry_manifest example shows `semconv_version: 0.1.0` but individual attribute groups have no stability annotation. Weaver validation may warn or fail on missing stability. More importantly, consumers of the registry (dashboards, alert rules) need to know which attributes may change. | Phase 1 file specifications (task.yaml, project.yaml, sprint.yaml, agent.yaml) — each attribute group should declare stability | `weaver registry check` passes without stability warnings; grep confirms every attribute group YAML contains a `stability:` field. |
| R1-S6 | Ops | medium | Define a versioning and release strategy for the registry itself — when `semconv_version` bumps, how breaking changes are communicated, and whether the registry is published as a standalone artifact (e.g., OCI image, GitHub release, or npm-style package). | The plan mentions `semconv_version: 0.1.0` and Phase 3 diffing, but doesn't define how downstream consumers (other teams, dashboards, Grafana provisioning) discover or pin to a registry version. Without this, the registry is an internal-only artifact with limited governance value. | New subsection under Phase 3 or as a standalone "Versioning & Release" section after Phased Implementation | Registry version is tagged in git; CHANGELOG or diff is generated on version bump; at least one downstream consumer (e.g., Grafana dashboard JSON) references the registry version. |
| R1-S7 | Security | medium | Validate the integrity of the OTel semconv dependency archive fetched in CI — use a checksum or signature verification rather than trusting an unauthenticated zip download. | The `registry_manifest.yaml` references a GitHub archive URL. In CI, fetching arbitrary archives without integrity verification is a supply-chain risk. A compromised or MITM'd archive could inject invalid semconv definitions. | `registry_manifest.yaml` specification and CI workflow file | CI step includes `sha256sum` verification of the downloaded archive against a pinned hash in the repository; hash is updated via a dedicated PR when upgrading OTel semconv versions. |
| R1-S8 | Architecture | medium | Add `semconv/registry/metrics/` YAML files to Phase 1 scope, or explicitly justify why metrics are deferred to Phase 2 given that `MetricName` is already defined in `contracts/metrics.py` and metric validation is high-value. | Metrics are arguably the highest-value telemetry to validate against a schema (wrong metric names cause silent data loss in dashboards), yet they're deferred to Phase 2. Including even 2–3 task metrics in Phase 1 would validate the metrics schema pattern early and de-risk Phase 2. | Phase 1 file list — add `semconv/metrics/task_metrics.yaml` with a subset (e.g., `task.lead_time`, `task.cycle_time`, `task.wip`) | `weaver registry check` validates metric definitions; metric names in YAML match a subset of `MetricName` enum values. |
| R1-S9 | Validation | medium | Add a Phase 1 CI step that runs `weaver registry resolve` and persists the resolved output as a build artifact, enabling diff-based review on PRs that modify the registry. | `weaver registry resolve` is listed as a verification step but only as a pass/fail check. Persisting the resolved output and diffing it against `main` would give reviewers visibility into the semantic impact of registry changes (e.g., new attributes, changed requirement levels). | `.github/workflows/validate-semconv.yml` — add artifact upload step after resolve | PR comments or CI artifacts show a human-readable diff of resolved registry between PR branch and main; reviewers can see exactly what changed. |
| R1-S10 | Risks | medium | Address the risk of `gen_ai.code.*` namespace collision with a concrete trigger and action plan, not just "monitor and rename." Define the OTel SIG meeting cadence to monitor, the team member responsible, and the threshold for preemptive renaming. | The current mitigation ("Monitor OTel GenAI SIG; rename to contextcore.code.* if needed") is vague. Without an owner and a trigger condition, this risk will be forgotten until a collision causes a breaking change. | Risk Mitigation table — expand the `gen_ai.code.*` row with owner, cadence, and trigger criteria | Risk register includes named owner and quarterly review checkpoint; if OTel GenAI SIG publishes a `gen_ai.code.*` RFC, renaming PR is raised within 2 weeks. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- (none — this is the first review round)

#### Review Round R2
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 17:37:53 UTC
- **Scope**: Architecture-focused review for OTel Weaver registry design, schema governance, and CI integration safety

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R2-S1 | Architecture | high | Automate the generation of registry enum definitions directly from the canonical Python enum source files. | The plan makes Python the source of truth but relies on manual transcription to YAML, creating a high risk of drift. Automation enforces the "source of truth" principle, eliminating manual sync errors and making the process safer. | Add a new step in "Phase 1: MVP Registry + CI" to create a code generation script. Add a `make semconv-generate-enums` target. | The generated YAML sections for enums are identical to the output of a script that directly parses `types.py`. The CI check should run the generator and fail if there's a diff. |
| R2-S2 | Risks | high | Add a risk and mitigation for the impact of schema formalization on downstream consumers (e.g., dashboards, alerts). | The plan focuses on producers. Formalizing ~185 attributes, even with deprecations, will inevitably break consumers that rely on old/inconsistent names or values. Acknowledging this risk is critical for a smooth transition. | Add a new row to the "Risk Mitigation" table. | Create a simple inventory of known downstream consumers (e.g., key Grafana dashboards) and review their queries for dependencies on the attributes being formalized in Phase 1. |
| R2-S3 | Ops | high | Define a formal versioning policy for the semantic convention registry itself (e.g., `semconv_version`). | The plan introduces `semconv_version: 0.1.0` but lacks a policy for how it will be incremented. Consumers need a clear contract (like SemVer) to understand the impact of registry changes (e.g., when an attribute is removed vs. added). | Add a new sub-section under "Key Design Decisions" titled "Registry Versioning Policy". | The versioning policy is documented. PRs that introduce breaking changes (per the policy) correctly increment the major version number in `registry_manifest.yaml`. |
| R2-S4 | Security | high | Incorporate a security and privacy review step for all attributes to identify and manage potential PII or sensitive data. | Attributes like `task.assignee`, `task.url`, and event attributes for comments could inadvertently capture PII. A formal check is needed to prevent sensitive data leaks into the observability pipeline. | Add a new row to the "Risk Mitigation" table. Also, add a "Security & Privacy Considerations" sub-section under "Key Design Decisions". | A checklist for PII review is created. A review of the initial Phase 1 attributes (`task.*`, `project.*`, `sprint.*`) is conducted and documented, confirming no PII is exposed. |
| R2-S5 | Architecture | medium | Formalize a namespace prefixing policy, recommending `contextcore.*` for all proprietary conventions. | The plan mixes unprefixed (`task.*`) and prefixed (`contextcore.install.*`) namespaces. Adopting a consistent prefix (e.g., `contextcore.task.*`) aligns with OTel best practices, prevents name collisions with future OTel standards, and improves clarity. | Add a new sub-section under "Key Design Decisions" titled "Namespace Strategy". | The policy is documented. All newly created YAML files in Phase 1 and 2 adhere to the chosen prefixing convention. |
| R2-S6 | Validation | medium | Explicitly define the data type (e.g., `type: int`, `type: string`) for all attributes in the registry YAML. | The plan lists attribute names but omits their expected data types. Enforcing types in the schema is a core benefit of Weaver, preventing incorrect data (e.g., `"5"` instead of `5`) and improving consumer reliability. | Add a requirement to the "Verification" section of Phase 1: "All attributes must have an explicit `type` field defined." | Run `weaver registry check` and confirm it passes. Manually inspect the generated `task.yaml` and other files to ensure `type` fields are present for all attributes. |
| R2-S7 | Data | medium | Establish a governance process for changes to canonical enums, especially for removal or renaming of members. | The plan correctly identifies Python as the source of truth but doesn't define the process for evolving these enums. Removing an enum member is a breaking change for consumers who may be querying or alerting on that value. | Add to the "Enum source of truth" section a paragraph detailing the governance process for breaking vs. non-breaking enum changes. | The process is documented. A hypothetical PR that removes an enum member is shown to require a major `semconv_version` bump according to the new policy. |
| R2-S8 | Validation | medium | Promote the "Consistency verification" script (Python enums vs. registry YAML) from a Phase 3 goal to a required CI check in Phase 1. | Waiting until Phase 3 to automate the check between the code (source of truth) and the registry (declaration) is too long. This is a critical safety check that should be part of the core CI workflow from the start to prevent drift. | Move the "Consistency verification" bullet point from "Phase 3" to the `.github/workflows/validate-semconv.yml` description in "Phase 1". | The CI workflow in a PR fails if a change is made to a Python enum in `types.py` without a corresponding, matching change in the registry YAML. |
| R2-S9 | Risks | medium | Add a mitigation strategy for the potential conflict between `gen_ai.code.*` and future official OTel `gen_ai.` conventions. | The plan correctly identifies this risk but the mitigation ("monitor OTel GenAI SIG") is passive. A more proactive stance is to initially namespace them as `contextcore.gen_ai.code.*` to guarantee no future conflict. | Modify the `gen_ai.code.*` risk in the "Risk Mitigation" table to propose namespacing as the primary mitigation. | The `code_generation.yaml` file is defined with the `contextcore.gen_ai.code.*` namespace from the beginning of Phase 2. |
| R2-S10 | Ops | low | Document the process for deprecating attributes and how consumers should track these changes. | The plan mentions using the `deprecated:` field for `agent.*` attributes, which is good. However, it should be formalized as the standard process for all future deprecations, including how long deprecated attributes will be supported. | Add a "Deprecation Policy" sub-section under "Key Design Decisions". | The policy is documented and the `agent.yaml` file serves as a valid implementation of this policy. |

#### Review Round R3

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 17:53:41 UTC
- **Scope**: Architecture-focused review for OTel Weaver registry design, schema governance, and CI integration safety. This is a post-triage round — review the updated plan body and applied suggestions for gaps, conflicts, or new risks introduced by the triage decisions.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R3-S1 | Architecture | critical | Define a concrete contract for `verify_enum_parity.py`'s YAML parsing expectations — specify which YAML keys it reads (`type: enum`, `members:`, `value:`) and how it handles `ref:` attributes that inherit enums from OTel upstream. | This script is now a Phase 1 CI gate (R1-S1, R2-S1, R2-S8 applied), but the plan never specifies how it parses registry YAML. Weaver's schema for enum attributes uses `members` with nested objects — if the script assumes a flat list of strings, it will silently pass or fail incorrectly. A `ref:` attribute pointing to an OTel-defined enum has no local `members` block, creating a false-positive mismatch. This is the single most likely source of CI gate failures on day one. | New subsection under Phase 1 after file #10, or as a specification block within file #10's description | Script has explicit unit tests: one for a locally-defined enum, one for a `ref:` attribute (should skip), one for an enum with `deprecated` members. Tests run in CI before the script gates anything. |
| R3-S2 | Data | high | Specify the `body` schema for each event in `task_events.yaml` — Weaver events support a `body` field with typed attributes, and omitting it means events carry no structured payload beyond the span context. | The plan lists 10 task events but only names them. Events like `task.status_changed` need `body` fields (e.g., `previous_status`, `new_status`) to be useful. Without body schemas, the registry validates event *names* but not event *content*, undermining the governance value. The security review (R2-S4) flagged `task.commented` must not capture free-text — this constraint should be encoded in the schema itself (e.g., `body` has `comment_length: int` but no `comment_text: string`). | Phase 1 file #7 (`task_events.yaml`) description; extend to Phase 2 events | `weaver registry resolve` output includes body field definitions for each event. Review resolved output in CI artifact for completeness. |
| R3-S3 | Risks | high | Add a rollback/revert plan for the registry itself — if Phase 1 merges and then a blocking issue is found (e.g., Weaver version incompatibility, CI instability beyond the 2-week window), what is the revert procedure? | The plan has a soft-gate rollback (R1-S3 applied), but no rollback for the *registry files themselves*. If the registry YAML causes downstream tooling issues or the `verify_enum_parity.py` script has a systematic bug, the team needs a documented path: revert the CI workflow only vs. revert all semconv/ files vs. disable the check via label. The 2-week `continue-on-error` window implicitly assumes issues surface early, but subtle parity bugs may only trigger on specific enum changes weeks later. | Risk Mitigation table, new row | Documented runbook exists before Phase 1 merge; includes specific git revert commands and a "circuit breaker" mechanism (e.g., env var or config flag to disable parity check without removing files). |
| R3-S4 | Interfaces | high | Define the OTel semconv dependency resolution mechanism — the `registry_manifest.yaml` shows a zip URL with `[model]` suffix, but Weaver's actual dependency resolution format and offline/cached behavior needs to be validated against the pinned Weaver version. | The dependency declaration `registry_path: https://...v1.34.0.zip[model]` uses a specific Weaver syntax that has changed across versions. If the pinned Weaver release doesn't support this exact format (e.g., `[model]` suffix was introduced in Weaver 0.12+), the registry check will fail opaquely. The risk table mentions caching but not format validation. | Phase 1 file #1 description; add a verification step | Before writing any other YAML, run `weaver registry check` with *only* the manifest file against the pinned Weaver version. Document the exact Weaver version in the manifest or a `.weaver-version` file. |
| R3-S5 | Validation | medium | Add cross-reference validation between `spans/task_spans.yaml` attribute references and `registry/task.yaml` attribute definitions — Weaver validates this, but the plan should specify expected behavior when a span references an attribute not yet defined (Phase 2 attributes referenced from Phase 1 spans). | Phase 1 creates task spans that may naturally want to reference attributes defined in Phase 2 files (e.g., `insight.*` attributes on a task span for enriched context). If Phase 1 span definitions are written with forward references to Phase 2 attributes, `weaver registry check` will fail. The plan needs an explicit rule: Phase 1 spans reference ONLY Phase 1 registry attributes. | Phase 1 "Attribute requirements" section, as an additional bullet | `weaver registry check` passes with only Phase 1 files present. No `ref:` to attributes outside Phase 1 scope. |
| R3-S6 | Ops | medium | Specify CI artifact retention policy and naming convention for `weaver registry resolve` output, and define how PR reviewers should use the diff artifact for schema review. | R1-S9 was applied (artifact upload for diff-based PR review), but the plan doesn't specify: artifact retention period, naming convention (e.g., `semconv-resolved-<sha>.yaml`), or whether the CI workflow computes a diff against the base branch's resolved output. Without an actual *diff*, uploading the resolved output just gives reviewers a large YAML blob with no indication of what changed. | Phase 1 file #8 (CI workflow) description | CI workflow includes a step that diffs resolved output against the base branch's artifact. PR comment or check annotation shows added/removed/changed attributes. Manual test: create a PR adding one attribute, verify diff is readable. |
| R3-S7 | Architecture | medium | Address the metric `instrument` type and `unit` for each metric in `task_metrics.yaml` — Weaver metric definitions require instrument type (counter, histogram, gauge, updowncounter) and unit, and incorrect choices have downstream implications for backends. | The plan lists 9 task metrics by name but doesn't specify instrument types. `task.wip` is a gauge (point-in-time), `task.throughput` is a counter, `task.lead_time` is a histogram — choosing wrong types causes incorrect aggregation in Prometheus/OTLP backends. These decisions should be made explicitly in the plan, not deferred to implementation. | Phase 2 `task_metrics.yaml` description; but the *decisions* should be documented in Phase 1 as a design decision table | Review resolved metrics output; cross-reference instrument types against Prometheus exposition format expectations. Validate that gauge-type metrics are not monotonic, histogram metrics have meaningful bucket boundaries. |
| R3-S8 | Security | medium | Specify how `ref:` attributes from the OTel dependency are governed for PII — the plan reviews ContextCore-owned attributes (R2-S4) but `service.name`, `k8s.pod.name`, and `messaging.*` attributes pulled via `ref:` may also carry deployment-specific PII or internal infrastructure details. | R2-S4 was applied for ContextCore attributes, but referenced OTel attributes are also emitted by the SDK. `k8s.namespace.name` could reveal internal org structure; `service.name` patterns could leak project codenames. The PII review should extend to all attributes the SDK actually emits, not just those defined in the registry. | Security & Privacy Considerations section, as an additional paragraph covering referenced attributes | PII review checklist includes a column for "referenced OTel attributes used in spans/events" with per-deployment sensitivity assessment. |
| R3-S9 | Validation | medium | Define acceptance criteria for the `continue-on-error` graduation — the plan says "measure false-positive rate before becoming a hard gate" but doesn't specify what false-positive rate threshold triggers graduation, the measurement mechanism, or who decides. | Without concrete criteria, the soft gate could persist indefinitely (becoming security/governance theater) or be prematurely hardened. Need: (1) define "false positive" precisely (Weaver check fails but no actual schema violation exists), (2) tracking mechanism (GitHub issue? spreadsheet? CI metrics?), (3) threshold (e.g., "0 false positives across 20+ PRs touching semconv/"), (4) decision owner. | Risk Mitigation table, expand the `continue-on-error` row | After 2-week window: review log of all `continue-on-error` triggered runs, categorize each as true positive or false positive, document decision to graduate or extend with rationale. |
| R3-S10 | Data | low | Clarify how `string[]` type attributes (e.g., `task.labels`, `task.blocked_by`) are represented in OTLP and validated by Weaver — OTLP uses repeated fields, but SDK emit patterns vary (some serialize as comma-separated strings). | R2-S6 requires explicit `type:` fields, but `string[]` handling is a known source of interop issues. If the Python SDK emits `task.labels` as a single comma-separated string while the registry declares `string[]`, live-check (Phase 3) will flag violations. The plan should note the expected wire format now to avoid rework. | Phase 1 `task.yaml` description, as a note on array-typed attributes | Review Python SDK emit code for array attributes; verify OTel SDK `set_attribute` calls use `list[str]` not `str`. Add a test case to `verify_enum_parity.py` or a sibling script for type checking. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- None identified — all prior suggestions have been triaged into Applied or Rejected.

#### Review Round R4
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 17:56:18 UTC
- **Scope**: Architecture-focused review for OTel Weaver registry design, schema governance, and CI integration safety. This is a post-triage round — review the updated plan body and applied suggestions for gaps, conflicts, or new risks introduced by the triage decisions.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R4-S1 | Validation | high | Implement a "schema usage" CI check that verifies every attribute defined in the registry is referenced in the Python SDK source code. | The plan validates that Python enums are reflected in the registry (`Python -> YAML`), but not the reverse. This creates a risk of "schema-only" attributes being added to YAML but never emitted by the SDK, misleading consumers. This check ensures the registry only describes telemetry that is actually implemented. | Phased Implementation / Phase 2 | A CI script (`scripts/verify_attribute_usage.py`) scans `src/` for references to attribute IDs found in `semconv/registry/` and fails if any registry attribute is unused. |
| R4-S2 | Risks | medium | Formalize the CI rollback exit criteria and add monitoring for the `[skip-semconv]` bypass. | The 2-week trial for the CI gate is a good safety measure, but lacks specific success criteria. The `[skip-semconv]` bypass is a necessary escape hatch that could be abused without oversight, negating the benefits of the CI gate. | Risk Mitigation | Update the "Weaver CI blocks unrelated PRs" risk mitigation entry to define an explicit success threshold (e.g., "<5% failure rate on unrelated PRs") and add a CI step that posts a GitHub comment or Slack alert when `[skip-semconv]` is used. |
| R4-S3 | Interfaces | high | The ContextCore Python SDK must expose the `semconv_version` it complies with. | Consumers of the telemetry have no way to know which version of the semantic convention schema to validate against for a given version of the SDK. This tight coupling is critical for downstream tooling and validation. | Registry–Runtime Boundary | Add a new section stating that the SDK's `__init__.py` or a constants file will contain a `SEMCONV_VERSION` string literal. A CI check will ensure this version matches `semconv/registry_manifest.yaml` on every release. |
| R4-S4 | Security | high | Formalize the PII review process and record its outcome within the registry YAMLs. | The current plan mentions PII review but lacks a concrete process, making it easy to overlook. Storing the outcome in the YAML makes the PII status of each attribute group explicit, machine-readable, and auditable. | Security & Privacy Considerations | Add a requirement for a `pii_review` object in each attribute group YAML file (e.g., `pii_review: {status: reviewed, outcome: pii_absent, reviewer: '@user', date: 'YYYY-MM-DD'}`). The PR template for `semconv/` changes should include a PII review checklist. |
| R4-S5 | Ops | medium | Augment the deprecation policy to include mandatory analysis of downstream consumer usage before attribute removal. | The current policy focuses on the provider's dual-emit window but doesn't prevent breaking consumers (dashboards, alerts) who fail to migrate. Removing an attribute should be gated on confirming it's no longer in use. | Deprecation Policy | Add a step to the policy: "Before removal in a major version, an audit of known downstream systems (e.g., Grafana, Loki) must be performed to identify usage of the deprecated attribute. Removal is blocked until usage is migrated or explicitly accepted as a breaking change." |
| R4-S6 | Architecture | medium | Define a formal process and cadence for upgrading the upstream OTel semconv dependency. | The plan pins the OTel dependency to a specific version but provides no strategy for future upgrades. This risks the registry becoming stale and missing critical upstream changes, especially in namespaces like `gen_ai` that we extend. | Risk Mitigation | Add a new risk "Upstream OTel dependency becomes stale". Mitigation: "The OTel SIG collision monitor owner is responsible for proposing a dependency upgrade on a quarterly basis. The upgrade PR must include the output of `weaver registry diff` to assess the impact." |
| R4-S7 | Validation | high | Expand `verify_enum_parity.py` to validate all contracts, not just enums. | The script name and description imply it only checks `Enum` members from `types.py`. Metric names and label names defined as string constants in `contracts/metrics.py` are also a source of truth that can drift from the registry YAMLs. | Phased Implementation / Phase 1 | Rename the script to `verify_contracts_parity.py`. Expand its scope to parse `MetricName` and `LabelName` constants from `metrics.py` and verify they match the corresponding `name` and `id` fields in `semconv/metrics/*.yaml`. |
| R4-S8 | Validation | medium | Add a CI check to verify the integrity of all `ref:` links after an OTel dependency upgrade. | When the upstream OTel dependency is upgraded, attributes we `ref:` could be renamed or removed, causing our schema to be invalid. The `weaver registry resolve` failure might be hard to debug. A dedicated check makes this failure mode explicit. | Phased Implementation / Phase 1 | In the `validate-semconv.yml` workflow, add a step that runs only when the OTel zip file is changed. This step would parse all `ref:` values from our YAML files and ensure they exist in the resolved OTel schema. |
| R4-S9 | Validation | high | Add a CI script to verify the `ATTRIBUTE_MAPPINGS` in `otel_genai.py` matches the `deprecated:` fields in the registry. | The dual-emit logic for `agent.*` -> `gen_ai.*` is a critical part of the migration. There is currently no check to ensure this runtime mapping stays in sync with the formal deprecation metadata declared in the registry YAML. | Phased Implementation / Phase 1 | Create `scripts/verify_deprecation_mapping.py` to be run in CI. This script will parse `deprecated:` fields from `agent.yaml` and assert that the Python mapping dictionary in `otel_genai.py` reflects the exact same old->new attribute pairs. |
| R4-S10 | Architecture | low | Mandate a review process for related spans/events when an attribute group is modified. | A developer might add a critical attribute like `task.team` to `task.yaml` but forget to add it to the `contextcore.task` span definition, leading to incomplete span schemas. This makes the relationship between attribute groups and their usage implicit. | Phased Implementation / Phase 2 | Update the PR template for changes in `semconv/registry/` to include a checklist item: "Have you reviewed and updated all related span and event definitions in `semconv/spans/` and `semconv/events/` that use this attribute group?" |

#### Review Round R5

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 18:02:31 UTC
- **Scope**: Post-triage round 2: review the updated plan with applied governance policies, enum parity CI, and risk mitigations. Look for implementation gaps, conflicts between applied suggestions, or new risks.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R5-S1 | Validation | critical | `verify_enum_parity.py` must also cover `MetricName`, `LabelName`, and `EventType` enums from `contracts/metrics.py`, not just `contracts/types.py` | The plan specifies the script "parses Python enums from `contracts/types.py`" but Phase 2 verification says "All metric names match `MetricName` enum" and Phase 1 events reference `EventType`. If the script only reads `types.py`, metrics.py-sourced enums will have no CI parity check until someone remembers to extend it. This is a silent coverage gap in a critical gate. | Update file #10 description and the script specification to explicitly enumerate both source files: `contracts/types.py` (TaskStatus, TaskType, Priority, HandoffStatus, InsightType) and `contracts/metrics.py` (MetricName, LabelName, EventType). | Script unit test: mock a MetricName mismatch and confirm non-zero exit. CI: Phase 1 task_events.yaml event names validated against EventType. |
| R5-S2 | Architecture | high | Define the YAML schema dialect and Weaver version compatibility contract | The plan pins OTel semconv to v1.34.0 but never pins the Weaver CLI version. Weaver is pre-1.0 and its registry schema format has changed between releases (e.g., `attribute_group` → `group` migration). Without a pinned Weaver version, CI may break silently on Weaver upgrades or local dev may produce YAML that CI rejects. | Add a `weaver_version` pin (e.g., `0.12.x`) to the Risk Mitigation table and to the CI workflow specification. Add a Makefile variable `WEAVER_VERSION`. | CI workflow uses exact version pin. `make semconv-check` fails if wrong Weaver version is detected. |
| R5-S3 | Interfaces | high | Specify the YAML structure for enum-typed attributes to enable machine-parseable parity checking | The plan says the parity script "auto-generates expected enum sections, then diffs against registry YAML" but never specifies what the YAML enum format looks like. Weaver supports `members` lists with `id` and `value` fields, but also allows `allow_custom_values`. Without a documented convention, YAML authors may use inconsistent formats and the parity script will need fragile heuristics. | Add a "YAML Enum Convention" subsection under "Key Design Decisions" showing the canonical YAML shape (e.g., `type: { allow_custom_values: false, members: [{ id: ENUM_NAME, value: "enum_value" }] }`). | Review all Phase 1 YAML files against the convention. Parity script tests include a malformed-enum fixture that must be rejected. |
| R5-S4 | Data | medium | Resolve the Markdown vs Python discrepancy for HandoffStatus *before* Phase 1 merge, not implicitly | The plan notes "Markdown lists 9 values, Python has 6" and says "registry follows Python." However, Phase 1 does not include `handoff.yaml` (it's Phase 2). When Phase 2 arrives, if no one has triaged whether `input_required`, `cancelled`, `rejected` should be added to Python, the discrepancy will resurface. This is a deferred decision masquerading as a resolved one. | Add an explicit action item in Phase 1: "File issue to resolve HandoffStatus discrepancy: either add 3 missing members to Python enum or remove from Markdown. Must be resolved before Phase 2 handoff.yaml creation." Place in Phase 1 verification checklist. | Phase 2 PR template includes a pre-merge checkbox confirming HandoffStatus enum is reconciled in both Python and Markdown. |
| R5-S5 | Ops | medium | Define the `[skip-semconv]` escape hatch interaction with the parity check | The plan provides a `[skip-semconv]` label to bypass Weaver CI (R1-S3), but the parity script `verify_enum_parity.py` is described as a "Phase 1 CI gate." It's ambiguous whether `[skip-semconv]` also skips the parity check. If it does, a developer could merge a Python enum change without registry update. If it doesn't, the escape hatch is incomplete for false-positive scenarios. | Clarify in CI workflow specification: `[skip-semconv]` skips Weaver schema checks (`registry check`, `registry resolve`) but NOT the parity script, since parity failures are never false positives—they indicate real drift. | Test: apply label, change a Weaver YAML comment, confirm Weaver steps skip but parity still runs. |
| R5-S6 | Risks | medium | Add a risk entry for OTel semconv dependency archive URL stability | The `registry_manifest.yaml` references a GitHub archive URL (`/archive/refs/tags/v1.34.0.zip[model]`). GitHub archive URLs are not immutable—repository renames, tag force-pushes, or GitHub infrastructure changes can break them. The existing risk table mitigates "flaky fetch" with retry/cache but not "URL permanently broken." | Add to Risk Mitigation table: "OTel semconv archive URL becomes unavailable — Mitigation: vendor a checksummed copy of the dependency in `semconv/vendor/` or use a lockfile with SHA-256 hash. CI validates checksum before resolution." | CI: checksum validation step before `weaver registry resolve`. Yearly review of upstream URL viability. |
| R5-S7 | Security | medium | The `[skip-semconv]` label is a security-sensitive CI bypass that needs access control | Any contributor who can add labels to a PR can bypass semconv validation. In an open-source or inner-source model, this means untrusted contributors could skip governance checks. This is especially concerning since the parity check enforces the runtime↔governance contract. | Restrict `[skip-semconv]` label application to CODEOWNERS of `semconv/` or require a CODEOWNER approval when the label is present. Document this in the CI workflow as a required reviewers condition. | Audit: verify GitHub branch protection rules require CODEOWNER review when label is applied. Test: non-CODEOWNER applies label, confirm CI still enforces checks or PR is blocked. |
| R5-S8 | Validation | medium | Phase 3's `ATTRIBUTE_MAPPINGS` verification lacks a Phase 1/2 interim check | Phase 3 includes "Verify `ATTRIBUTE_MAPPINGS` in `otel_genai.py` matches deprecated→replacement pairs in registry." But Phase 1 creates `agent.yaml` with deprecation markers *now*. Between Phase 1 and Phase 3, these mappings can drift with no automated check. Since the data exists on both sides from Phase 1, the verification should start in Phase 1. | Move the `ATTRIBUTE_MAPPINGS` ↔ `agent.yaml` deprecated field consistency check into `verify_enum_parity.py` (or a sibling script) in Phase 1. It's a simple dict-key-to-YAML-field comparison. | Script test: add a bogus mapping to `ATTRIBUTE_MAPPINGS`, confirm script exits non-zero. CI: runs in Phase 1 workflow. |
| R5-S9 | Architecture | low | Clarify the `requirement_level` taxonomy for span attributes | Phase 1 file #6 mentions "appropriate requirement_levels" for span attributes but never defines what levels are used or the decision criteria. OTel Weaver supports `required`, `recommended`, `opt_in`, and `conditionally_required`. Without guidance, YAML authors will make inconsistent choices, leading to noisy `weaver registry check` output or overly strict span validation. | Add a "Requirement Level Guidelines" subsection under "Key Design Decisions" with rules like: identifiers (`task.id`, `project.id`) → `required`; descriptive fields (`task.labels`, `task.url`) → `recommended`; computed fields (`task.percent_complete`) → `opt_in`. | Review Phase 1 span YAML: every attribute reference has an explicit `requirement_level`. Weaver check confirms no missing levels. |
| R5-S10 | Ops | low | No rollback plan if Phase 1 registry YAML introduces CI flakiness beyond the 2-week window | The plan addresses the initial 2-week `continue-on-error` period, but doesn't specify what happens if flakiness emerges *after* the hard gate is enabled (e.g., Weaver release introduces a regression, or a transient network issue fetching the OTel dependency). Without a documented rollback procedure, an on-call engineer must rediscover the `[skip-semconv]` label or disable the workflow entirely. | Add a "Post-Hardening Incident Procedure" to Risk Mitigation: (1) Apply `[skip-semconv]` to unblock; (2) File incident issue with `semconv-ci-incident` label; (3) If >2 incidents/week, revert to `continue-on-error` and investigate root cause before re-hardening. | Runbook exists in `docs/runbooks/` or equivalent. Incident label exists in issue tracker. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R3-S1: The absence of a consumer notification mechanism for schema changes is a real operational gap—dashboards and alerts that reference renamed attributes will silently break without proactive communication.
- R4-S3: Testing the parity script itself with known-good and known-bad fixtures is essential; without it, the script could silently pass on malformed YAML, undermining the entire CI gate strategy.
- R3-S5: A concrete attribute count reconciliation (185 claimed vs. actual per-file totals) would catch silent scope creep or undercounting that persists across phases.
- R4-S1: Explicit mapping between the ~185 attributes and their target YAML files prevents Phase 2 from becoming an ambiguous "add everything else" bucket.

#### Review Round R6
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 18:03:37 UTC
- **Scope**: Post-triage round 2: review the updated plan with applied governance policies, enum parity CI, and risk mitigations. Look for implementation gaps, conflicts between applied suggestions, or new risks.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R6-S1 | Ops | high | Formalize OTel Dependency Upgrade Cadence | The plan pins the OTel semconv dependency to `v1.34.0` for stability but lacks a process for future upgrades. Without a defined cadence (e.g., quarterly review) and process, our conventions will grow stale and diverge from the upstream OTel standard, re-introducing collision risks. | Add a new section under "Risk Mitigation" or "Operational Readiness" (a new section). | A process document is created outlining the owner, cadence, and steps for reviewing and applying updates to the OTel semconv dependency. |
| R6-S2 | Validation | high | Expand Parity Script Scope Beyond Enums | The `verify_enum_parity.py` script is a critical control, but its description focuses only on enums. The canonical Python contracts also define metric names, event names, and label names. The script's scope should be explicitly expanded to cover all contract types to prevent drift in these critical identifiers. | Update the description of `scripts/verify_enum_parity.py` in Phase 1. | The `verify_enum_parity.py` script is updated to fail CI if metric names from `MetricName` or event names from `EventType` in Python do not match their definitions in the registry YAMLs. |
| R6-S3 | Risks | medium | Track and Audit `[skip-semconv]` Usage | The `[skip-semconv]` escape hatch (R1-S3) is a necessary safety valve but also a potential source of governance decay. The plan lacks a mechanism to monitor its usage. This creates a risk that it will be used for convenience, allowing schema drift to accumulate unnoticed. | Add to the "Risk Mitigation" entry for "Weaver CI blocks unrelated PRs". | Implement a CI step that flags PRs using the `[skip-semconv]` label for manual review or logs its usage to a dashboard for periodic audit. The audit process should be owned. |
| R6-S4 | Security | high | Integrate PII/Security Review into Schema Change Workflow | The plan describes a one-time PII review for Phase 1 attributes (R2-S4). This creates a gap where future attributes could be added without a formal security review. The process for adding or modifying attributes should include a mandatory security review checkpoint. | Add to "Namespace Governance Policy" section, as a required step for adding any new attribute group or sensitive attribute. | Update the PR template for `semconv/` changes to include a mandatory PII/Security review checklist item that must be signed off by a security team member. |
| R6-S5 | Validation | high | Accelerate Deprecation Mapping Verification | The plan defers verification of `ATTRIBUTE_MAPPINGS` in `otel_genai.py` against the registry to Phase 3. This mapping is critical for the deprecation strategy's correctness. A drift between the implementation and the schema renders the `deprecated:` field in the registry unreliable and should be caught immediately. | Move this verification from Phase 3 ("Consistency verification") to the scope of `scripts/verify_enum_parity.py` in Phase 1. | The `verify_enum_parity.py` script is extended to parse `deprecated:` fields in the registry and assert they match the key-value pairs in the `ATTRIBUTE_MAPPINGS` dict. |
| R6-S6 | Architecture | medium | Define a Long-Term Vision for the Registry-Runtime Boundary | The "CI-only governance artifact" (R1-S4) is a pragmatic starting point, but it's a strong architectural constraint that may not hold long-term (e.g., runtime validation at the collector). The plan should acknowledge this and articulate a long-term vision to prevent future designs from being painted into a corner. | Add a paragraph to the "Registry–Runtime Boundary" section discussing the potential future evolution of this boundary. | The architectural principles or design decisions section includes a statement like: "While initially a CI-only artifact, the registry may be used for runtime validation in the future. System components should not be architected in a way that precludes this possibility." |
| R6-S7 | Risks | high | Mitigate Risk of Upstream Breaking Changes in Referenced Attributes | The registry uses `ref:` to link to OTel attributes (e.g., `gen_ai.*`). This creates a dependency risk: if OTel renames or removes a referenced attribute in a future version, our `resolve` step will break. The current mitigations only cover our own extensions, not our consumption of upstream conventions. | Add a new entry to the "Risk Mitigation" table. | Create a dedicated, non-blocking CI job that runs daily/weekly against the `main` branch of the upstream OTel semantic conventions repository to detect future breaking changes early. |
| R6-S8 | Validation | medium | Deepen Downstream Consumer Impact Analysis | The mitigation for breaking downstream consumers (R2-S2) focuses on verifying TraceQL queries in dashboards. This is insufficient. It misses alerts, recording rules, and dashboard logic that relies on specific enum *values* (e.g., Grafana value mappings). The impact analysis must be more comprehensive. | Expand the "Risk Mitigation" entry for "Schema formalization breaks downstream consumers". | Create a checklist for major version bumps that includes verifying specific dashboards, alert definitions, and recording rules known to be sensitive to attribute or enum value changes. |
| R6-S9 | Architecture | medium | Commit to a Timeline for Documentation Generation | Classifying documentation generation as a "stretch" goal in Phase 3 creates a high risk that it never gets done, leaving the project with a permanent drift between the official schema (YAML) and human-readable docs (Markdown). This undermines the goal of having a single source of truth. | Change "Documentation generation (stretch)" in Phase 3 to a committed deliverable. | The Phase 3 plan is updated to treat documentation generation as a core task, not a stretch goal. The `docs/semantic-conventions.md` file is marked as deprecated, pointing to the new process. |
| R6-S10 | Data | medium | Formalize Policy for Schema-less/Free-text Fields | The plan identifies PII risk in specific free-text fields like `task.commented` but doesn't establish a general policy for them. As new events and attributes are added, a formal policy is needed to govern when free-text is allowed, what the default privacy posture is (e.g., opt-in), and what sanitization is required. | Add a new subsection under "Security & Privacy Considerations". | A policy is documented stating that new free-text attributes are disallowed by default and require explicit justification and a PII review to be added to the registry. |

#### Review Round R7

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 18:25:54 UTC
- **Scope**: Final review: the plan has been through 3 triage rounds. Look for internal inconsistencies, over-engineering, or gaps in the now-expanded Phase 1 scope.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R7-S1 | Validation | critical | `verify_contracts_parity.py` has no defined behavior for Python enum members that exist but have no registry counterpart (superset on Python side). Specify that the script must fail if Python has members not in YAML *and* if YAML has members not in Python — bidirectional parity, not just registry→Python. | The plan says "exits non-zero on any mismatch" but never explicitly states directionality. A Python enum could gain a new member in a hotfix, pass all existing tests, and silently have no registry coverage. This is the exact drift the system is designed to prevent. | Phase 1 item 10 (`verify_contracts_parity.py`) — add explicit bidirectional check requirement | Unit test fixtures include: (a) Python superset of YAML, (b) YAML superset of Python, (c) exact match. All three must produce correct pass/fail. |
| R7-S2 | Architecture | high | Phase 1 scope includes `agent.yaml` (6 deprecated attributes referencing `gen_ai.*` via `ref:`), but the `gen_ai.*` attributes themselves are only available through the OTel dependency archive. If the pinned v1.34.0 archive doesn't include the specific `gen_ai.agent.id` etc. attributes, `weaver registry check` will fail on unresolved refs. No validation of this assumption exists. | The plan pins OTel semconv v1.34.0 but never confirms which `gen_ai.*` attributes exist at that tag. GenAI semconv was experimental and rapidly evolving in 2024-2025. The day-one smoke test (R3-S4) only validates the manifest, not cross-dependency `ref:` resolution. | Phase 1 item 1 (day-one smoke test) — extend to include a minimal `agent.yaml` with one `ref:` to `gen_ai.agent.id` to validate dependency resolution end-to-end before writing all 6 attributes | Smoke test pass/fail; if fail, document which OTel semconv tag first includes required `gen_ai.*` attributes and update the pin. |
| R7-S3 | Ops | high | No defined ownership or rotation for the quarterly collision monitor and OTel dependency upgrade. "Project lead" is named but there's no fallback, no calendar mechanism, and no definition of what happens if the quarterly review is skipped. | Quarterly cadence obligations decay quickly without automation. If the project lead is unavailable, the review silently doesn't happen, defeating the purpose of collision monitoring for `gen_ai.code.*`. | Risk Mitigation table — add: scheduled GitHub issue (created via GitHub Actions cron) that auto-opens quarterly with a checklist for collision review and dependency upgrade. Auto-assigns project lead with a 1-week escalation to a named backup. | Verify cron workflow exists and produces issues; audit that no quarter is skipped after 2 cycles. |
| R7-S4 | Data | medium | The plan defines `task.due_date` and `sprint.start_date`/`sprint.end_date` but never specifies the expected format (ISO 8601, Unix epoch, etc.). OTel has no native `date` type — these will be `string` typed, making format ambiguity a real interop risk. | Downstream consumers (Grafana dashboards, recording rules) will parse these fields. Without a declared format, different emitters may use different representations, breaking queries. The `type:` field requirement (R2-S6) catches missing types but not format constraints on string-typed dates. | Phase 1 `task.yaml` and `sprint.yaml` — add a `note:` or `brief:` annotation on all date-typed attributes specifying ISO 8601 format (`YYYY-MM-DDTHH:MM:SSZ`). Consider adding a `verify_contracts_parity.py` check that date-attributed fields in Python emit ISO 8601. | Review resolved registry output for date attributes; confirm format annotation is present. Spot-check emitted OTLP from demo generator for format compliance. |
| R7-S5 | Risks | medium | The 2-week `continue-on-error` graduation window and the "20+ PRs" criterion may be unreachable if the project has low PR velocity on `semconv/` paths. The plan doesn't address what happens if fewer than 20 qualifying PRs occur in 2 weeks. | If only 3-5 PRs touch `semconv/` in the first 2 weeks, the graduation criteria can't be met, leaving the gate in soft-fail indefinitely. This creates ambiguity about when hardening actually happens. | Phase 1 item 8 (CI workflow) and Risk Mitigation (graduation criteria) — add a time cap: "Graduate after 20+ qualifying PRs OR 4 weeks, whichever comes first. If <10 qualifying PRs at 4 weeks, extend to 6 weeks with explicit decision log entry." | Track PR count in graduation decision log; review at 2-week and 4-week marks. |
| R7-S6 | Interfaces | medium | `verify_contracts_parity.py` must parse both Python AST and YAML, but the plan doesn't specify how it discovers which YAML files to check or how it maps Python enum class names to YAML files. With 4+ registry files in Phase 1 and 10+ in Phase 2, the mapping strategy matters. | Without an explicit mapping mechanism (convention-based filename matching, a manifest, or exhaustive glob), the script could silently skip new registry files or new Python enum classes. This is a second-order drift risk in the drift-prevention tool itself. | Phase 1 item 10 — specify that the script uses an explicit mapping table (Python dict) from enum/constant class names to YAML file paths, and that the script fails if any registry YAML file in `semconv/registry/` has no corresponding mapping entry (orphan detection). | Add a test that introduces a new YAML file without a mapping entry and confirms the script fails. |
| R7-S7 | Security | medium | The `[skip-semconv]` escape hatch with usage logging (R6-S3) has no defined threshold for triggering a review. Logging without action criteria is audit theater. | If `[skip-semconv]` is used on 30% of PRs, the governance system is effectively bypassed. Without a threshold that triggers investigation, the audit log accumulates but never drives action. | Risk Mitigation (revert runbook / skip-semconv) — add: "If `[skip-semconv]` is used on >10% of semconv-touching PRs in any 4-week window, project lead must investigate root cause and report findings in a tracking issue within 1 week." | Quarterly audit of skip-semconv usage rate; automated alert if threshold exceeded (can be a simple GitHub Actions summary step). |
| R7-S8 | Architecture | medium | The plan states Phase 3 doc generation will "mark `docs/semantic-conventions.md` as deprecated" but doesn't address `docs/agent-semantic-conventions.md` listed in Critical Files. This second doc file will also drift from the registry and needs the same generated-replacement treatment. | Inconsistent treatment of the two documentation files means one source of drift is fixed while another persists. Agent semantic conventions are particularly important given the `agent.*` → `gen_ai.*` deprecation. | Phase 3 (Documentation generation) — explicitly include `docs/agent-semantic-conventions.md` in the doc generation scope and deprecation plan. | Verify Phase 3 deliverables list includes both doc files; generated output covers agent/gen_ai namespace. |
| R7-S9 | Validation | low | The Phase 1 verification criteria say "All Python contracts match registry YAML" but don't specify whether the parity script runs against the *resolved* registry output or the raw YAML files. If it parses raw YAML, it won't catch errors in `ref:` attribute inheritance that could affect resolved enum values. | Running parity checks against raw YAML is simpler and sufficient for Phase 1 (where `ref:` attributes are skipped). But in Phase 2, if any ContextCore-owned attribute inherits properties from another via `ref:`, raw YAML parsing could miss resolved-state discrepancies. Clarifying now prevents a Phase 2 surprise. | Phase 1 item 10 — document that Phase 1 parity script parses raw YAML (sufficient since `ref:` attrs are skipped). Add a Phase 2 action item to evaluate switching to resolved output if any cross-file `ref:` inheritance is introduced within ContextCore-owned attributes. | Phase 2 pre-merge checklist includes a decision record on raw vs. resolved parity checking. |
| R7-S10 | Ops | low | The `.weaver-version` file (mentioned in Phase 1 item 1) and the `WEAVER_VERSION` Makefile variable are two sources for the same version pin. No mechanism ensures they stay in sync. | Dual-source version pins are a classic drift pattern. A developer updating the Makefile but not `.weaver-version` (or vice versa) causes silent inconsistency — local `make` runs use one version while CI might read the other. | Phase 1 items 1 and 9 — specify that the Makefile reads `WEAVER_VERSION` from `.weaver-version` (e.g., `WEAVER_VERSION := $(shell cat .weaver-version)`) making the file the single source. CI workflow also reads from `.weaver-version`. | Verify Makefile sources version from file; test that changing `.weaver-version` changes both `make semconv-check` and CI behavior. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- None identified — all prior suggestions from Appendix C appear to have been triaged into Applied or Rejected in the current document state.

#### Review Round R8
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 18:27:00 UTC
- **Scope**: Final review: the plan has been through 3 triage rounds. Look for internal inconsistencies, over-engineering, or gaps in the now-expanded Phase 1 scope.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R8-S1 | Ops | high | Implement production schema conformance monitoring via an OTel Collector processor. | The plan validates schemas pre-merge (CI) and locally (Phase 3 live-check), but lacks a mechanism to detect schema violations from clients in production. A collector processor can sample OTLP, validate against the registry, and emit metrics (e.g., `semconv.validation.errors`) to provide a continuous, operational feedback loop on adoption and drift. | Add to Phase 3 as a new "Production Monitoring" deliverable. | A test OTLP pipeline demonstrates the collector processor dropping or flagging spans/metrics that violate the ContextCore schema (e.g., wrong enum value, missing required attribute). |
| R8-S2 | Architecture | high | Mandate that all metric definitions in `metrics/*.yaml` include a list of required and recommended attributes (dimensions). | The Phase 2 plan for metrics specifies instrument type and unit, but critically omits the attributes (dimensions) for each metric. A metric like `task.lead_time` is not useful without dimensions like `task.type`. This is a fundamental gap in the metric schema definition. | Add to "Phase 2: Full Attribute Coverage" section, requiring an `attributes:` block for each metric definition. | The `weaver registry check` command should fail if a metric is defined in the registry without an `attributes:` block. The parity script could be extended to check this. |
| R8-S3 | Security | high | Formalize the PII-safe identifier pattern by defining paired attributes for sensitive fields like `task.assignee`. | The current plan flags `task.assignee` as a PII risk and punts the solution to "per-deployment guidance," which invites inconsistency. The registry should enforce a safer pattern by defining `task.assignee.id` (required, opaque) and `task.assignee.name` (opt_in, sensitive), making the safe approach the default. | Modify the "Security & Privacy Considerations" section and the definition of `task.yaml` in Phase 1. | The registry schema for `task.yaml` is updated to include `task.assignee.id` and `task.assignee.name` with the specified requirement levels. The PII policy is updated to mandate this pattern for all new person-identifying attributes. |
| R8-S4 | Validation | medium | Require `conditionally_required` attributes to include a machine-readable expression of the condition. | The plan introduces `conditionally_required` as a concept but provides no mechanism for automated validation, making it just prose. The schema should be enhanced to include a parseable condition (e.g., `condition: "span.name == 'contextcore.sprint'"`), enabling static analysis and live-check tools to enforce these rules. | Add to "Requirement Level Guidelines" section. | A test span definition that violates a conditional requirement (e.g., a non-sprint span using `sprint.id`) is flagged by an enhanced linter script or the Phase 3 live-check tool. |
| R8-S5 | Interfaces | medium | Enhance CI to post a "Semantic Impact Analysis" comment on PRs changing the registry. | A raw `diff` of the resolved registry YAML can be hard for reviewers to parse. The CI job should analyze the diff and post a human-readable summary of changes, explicitly calling out `BREAKING`, `MINOR`, and `PATCH` changes (e.g., "BREAKING: Enum member `rejected` removed from `HandoffStatus`"). This improves review safety and clarity. | Add to `.github/workflows/validate-semconv.yml` plan, specifically enhancing the "diff against base branch" step. | A sample PR that removes an enum member triggers a CI comment with a clear "BREAKING CHANGE" warning. A PR adding a new attribute triggers a "MINOR CHANGE" notification. |
| R8-S6 | Architecture | medium | Introduce an optional code generator to create Python enums from registry YAML. | The plan's core principle of "no code generation" forces reliance on a complex parity script (`verify_contracts_parity.py`) to prevent drift between YAML and Python. Providing an optional generator script would allow developers to ensure parity *by construction*, simplifying workflows and reducing the risk of human error, without making it a mandatory build step. | Add as a new tool under a "Developer Tooling" section or as a sub-point in the "Registry–Runtime Boundary" section, clarifying it is an optional helper, not a required CI step. | A developer can run `make generate-contracts` and the `src/contextcore/contracts/types.py` file is updated to perfectly match the enums defined in `semconv/registry/`. |
| R8-S7 | Risks | medium | Generalize the collision monitoring owner concept to all ContextCore-owned namespaces. | The plan astutely assigns an owner and review cadence for the OTel-extension namespace `gen_ai.code.*`, but leaves core namespaces like `task.*` and `project.*` without explicit owners. This creates a risk of collision with other emerging standards. All top-level namespaces should have a designated owner responsible for monitoring the wider ecosystem. | Add to the "Namespace Governance Policy" section, creating a table of namespaces and their assigned "Collision Monitor Owner". | A new manifest file (e.g., `semconv/OWNERS.md`) is created mapping namespaces like `task.*` to specific teams or individuals. |
| R8-S8 | Security | medium | Add secret detection for registry default values and a formal policy for URL attribute scrubbing. | The PII review process overlooks two risks: 1) developers committing example enum values that are actually secrets, and 2) URL-type attributes (`task.url`) containing sensitive session tokens in parameters. The plan should add a CI step to scan for secrets in YAML files and a policy requiring SDKs to scrub URL query parameters by default. | Add to "Security & Privacy Considerations" and the CI workflow plan in `.github/workflows/validate-semconv.yml`. | A PR attempting to add an enum member with a value that looks like an API key (`value: "sk-..."`) is blocked by CI. The security policy is updated with guidance on URL scrubbing. |
| R8-S9 | Interfaces | low | Formalize the audit and remediation process for `[skip-semconv]` usage. | The plan mentions logging the use of the `[skip-semconv]` escape hatch for audit, but doesn't define the audit process itself. This risks the log being ignored and the escape hatch being abused. The process should be formalized: logged events create a ticket or metric, which is reviewed weekly by a named owner/team. | Add to the "Risk Mitigation" table entry for "Weaver CI blocks unrelated PRs". | The CI workflow is updated to, for example, post to a specific Slack channel or create a Jira task when `[skip-semconv]` is used. The governance policy document assigns responsibility for reviewing this feed. |
| R8-S10 | Data | low | Define the lifecycle and update semantics for mutable array attributes. | The plan specifies that `string[]` attributes like `task.labels` exist, but is silent on how they are updated. This ambiguity can lead to inconsistent implementations. The registry should specify whether clients must re-emit the full array on change, or if there are specific mutation events (e.g., `task.label_added`) for tracking deltas. | Add a new sub-section under "Key Design Decisions" titled "Mutable Attribute Policy". | The policy is documented. For example: "Array-typed attributes represent a point-in-time snapshot. Any mutation must be accompanied by re-emitting the attribute with its new complete value." |

#### Review Round R9

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 18:37:27 UTC
- **Scope**: Final review: the plan has been through 4 triage rounds (47 applied, 22 rejected/deferred). Look for internal inconsistencies introduced by the latest edits, any remaining gaps, or over-engineering that should be simplified.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R9-S1 | Validation | high | `verify_contracts_parity.py` does not cover `Criticality`, `BusinessValue`, `RiskType`, `ConstraintSeverity`, `QuestionStatus`, `SessionStatus`, `AlertPriority`, `AgentType`, `DashboardPlacement`, or `LogLevel` enums from `types.py` — only 5 of 15 enums are listed. The explicit mapping table (R7-S6) will have orphan YAML files in Phase 2 for these unless the script's scope is extended. | The plan lists exactly `TaskStatus, TaskType, Priority, HandoffStatus, InsightType` for enum parity. Phase 2 adds `business.yaml` (which will contain `Criticality`, `BusinessValue`, `RiskType` enums), `guidance.yaml` (`ConstraintSeverity`), etc. But no action item says "extend the parity script enum list for Phase 2." Without this, the Phase 2 YAML files will either have no parity enforcement or the orphan-detection logic (R7-S6) will flag them as unmapped — creating noise rather than safety. | Phase 2 pre-merge checklist: add item "Extend `verify_contracts_parity.py` mapping table to cover all enums in `types.py` that have corresponding registry YAML attribute groups." Also add `SessionStatus`, `AlertPriority`, `AgentType`, `DashboardPlacement`, `LogLevel` to the Phase 2 scope or explicitly mark them as out-of-registry-scope with rationale. | Phase 2 PR review confirms mapping table covers all 15 enums (or documents exclusion rationale for each). |
| R9-S2 | Data | medium | `MetricName` enum contains project-prefixed metrics (e.g., `PROGRESS = "progress"`) and OTel-convention metrics (e.g., `TASK_LEAD_TIME = "task.lead_time"`) but the parity script doesn't distinguish which metrics belong in `task_metrics.yaml` vs. `install_metrics.yaml` vs. are project-prefixed (not in registry at all). | Project-prefixed metrics like `PROGRESS`, `COMPLETION_RATE`, `BLOCKED_COUNT` are used via `ProjectSchema.metric()` which prepends a prefix. These are not OTel semantic convention metrics and arguably don't belong in the Weaver registry. The parity script needs explicit rules for which `MetricName` members map to which YAML files, and which are intentionally excluded. Without this, orphan detection will either false-positive on project-prefixed metrics or miss actual drift. | Phase 1 parity script design: add a `METRIC_SCOPE` classification in the mapping table distinguishing `registry` (maps to YAML), `project_prefixed` (intentionally excluded from registry), and document the rationale. The orphan detector skips `project_prefixed` members. | Unit test fixture includes a project-prefixed metric not in YAML → should pass (excluded by scope), and an OTel metric missing from YAML → should fail. |
| R9-S3 | Architecture | medium | The plan references `semconv/events/task_events.yaml` with 10 events but `EventType` enum in `metrics.py` has 20 members (10 task + 2 subtask/sprint + 5 agent + `TASK_PROGRESS_UPDATED`, `TASK_ASSIGNED`, `TASK_COMMENTED`). Phase 2's `agent_events.yaml` covers 5 agent events, but `SUBTASK_COMPLETED`, `SPRINT_STARTED`, `SPRINT_ENDED` have no assigned YAML file. | These 3 events fall between task_events.yaml and agent_events.yaml. `SUBTASK_COMPLETED` could go in task_events, but sprint events logically belong with `sprint_span.yaml`. Without explicit assignment, Phase 2 will either silently omit them or the parity script will flag them. | Add `SUBTASK_COMPLETED` to the Phase 1 `task_events.yaml` event list (it's task-scoped). Add `SPRINT_STARTED` and `SPRINT_ENDED` to Phase 2's `sprint_span.yaml` section or create `semconv/events/sprint_events.yaml`. Update the directory structure accordingly. | Parity script confirms all 20 `EventType` members have corresponding YAML event definitions after Phase 2. |
| R9-S4 | Interfaces | medium | `ProjectSchema.promql()` uses deprecated `LabelName.PROJECT` ("project") rather than `LabelName.PROJECT_ID` ("project.id"), and `REQUIRED_LABELS` / `AGGREGATE_LABELS` reference deprecated labels (`STATUS`, `PRIORITY`). The registry will use OTel-convention `task.status`, `task.priority`, `project.id`. | The plan acknowledges deprecated labels exist (`STATUS`, `PRIORITY`, `ASSIGNEE`) but doesn't address the runtime-registry inconsistency: the parity script will validate `LabelName` members against registry YAML, but `REQUIRED_LABELS`, `AGGREGATE_LABELS`, and `ProjectSchema` methods hardcode the deprecated forms. This creates a split where the registry says `project.id` but runtime code emits `project`. | Add a Phase 2 action item: audit all `validate_labels`, `REQUIRED_LABELS`, `AGGREGATE_LABELS`, and `ProjectSchema` methods for usage of deprecated `LabelName` members. Create a migration plan to shift runtime code to `PROJECT_ID`/`TASK_STATUS`/`TASK_PRIORITY` with backward-compatible dual-emit if dashboards depend on old names. | Parity script includes a "deprecated label usage" warning mode that flags Python code importing deprecated `LabelName` members outside of backward-compat shims. |
| R9-S5 | Risks | high | No rollback or failure mode defined for `verify_contracts_parity.py` itself. If the script has a bug (crashes, false negatives), there's no circuit breaker equivalent to `[skip-semconv]` / `SEMCONV_CI_DISABLED`. | The revert runbook (R3-S3) covers Weaver checks but explicitly says `[skip-semconv]` never skips the parity script (R5-S5). If the parity script itself is broken, the only escape is to modify the script in the same PR — which may be blocked by the broken script. This is a CI deadlock scenario. | Add to revert runbook: `PARITY_CI_DISABLED=true` env var that skips the parity script (distinct from `SEMCONV_CI_DISABLED` which covers Weaver checks). Document that this is an emergency-only escape. Add to `[skip-semconv]` scope discussion: consider a separate `[skip-parity]` label with the same audit logging (R6-S3) and abuse threshold (R7-S7). | Test the deadlock scenario: introduce a deliberate parity script syntax error and verify the escape hatch allows the fix PR to merge. |
| R9-S6 | Ops | medium | The plan specifies `weaver registry live-check` in Phase 3 but doesn't define what OTLP endpoint or collector configuration is required. Live-check validates emitted telemetry against the registry — this requires a running collector that the check can query. | Without specifying the collector setup (local dev vs. CI vs. staging), Phase 3 live-check is underspecified. In CI, there's no collector running by default. In local dev, developers may have different collector configs. This will likely delay Phase 3 or produce a feature that only works in one environment. | Phase 3 section: specify that live-check targets the local dev environment using `docker-compose` collector setup (reference existing infra if any). For CI, add an integration test job that spins up a collector, runs the demo generator, and validates output via live-check. Define minimum collector version required. | Phase 3 PR includes a working `make semconv-live-check` that passes in CI with an ephemeral collector. |
| R9-S7 | Validation | medium | `RecordingRuleName` and `AlertRuleName` enums in `metrics.py` have no corresponding registry YAML files and no mention in the parity script scope. | These enums define Prometheus recording rules and alert rules that reference ContextCore metrics. If the registry changes metric names or label names, these rules could silently break. The plan's major-version-bump checklist (R6-S8) mentions verifying alerts and recording rules, but there's no automated parity check between these enum values and the registry's metric/label definitions. | Add to Phase 2 or Phase 3: extend parity script or add a separate validation that `RecordingRuleName` and `AlertRuleName` reference only metrics and labels defined in the registry. Alternatively, document these as explicitly out of registry scope with a manual review checklist item for metric renames. | Validation script parses recording rule name patterns and confirms base metric portions correspond to registered metric names. |
| R9-S8 | Architecture | low | `Priority` and `Criticality` enums in `types.py` have identical members (`CRITICAL`, `HIGH`, `MEDIUM`, `LOW`) with identical values. The registry will need two separate attribute definitions with the same enum members, which adds maintenance burden and confusion about when to use which. | This isn't a bug, but the registry formalization is an opportunity to document the distinction clearly. `Priority` is for task/handoff/question prioritization; `Criticality` is for business criticality. If they're semantically identical, consider whether `Criticality` should be a type alias. If they're distinct, the registry YAML should include `note:` annotations explaining the difference. | In `business.yaml` (Phase 2), add a `note:` annotation on the criticality attribute explaining its distinction from `task.priority`. Consider whether `Criticality` should reference `Priority` via `ref:` if they're intended to stay synchronized. | Review during Phase 2 PR: confirm both enums are independently justified and documented in registry YAML. |
| R9-S9 | Security | medium | The plan flags `task.assignee` and `task.url` for PII review but doesn't address `sprint.goal` (free-text), `project.name` (potentially sensitive project names), or `guidance.*` attributes (Phase 2, likely contain directive text). The free-text field policy (R6-S10) only applies to "new" attributes — these are existing attributes being formalized. | The free-text policy creates a loophole: existing free-text attributes being migrated into the registry bypass the "disallowed by default" rule since they're not "new." `sprint.goal` is explicitly free-text and could contain sensitive strategic information. `guidance.*` attributes (7 total, Phase 2) likely contain instructional text that could leak internal processes. | Extend Phase 1 PII review to explicitly assess `sprint.goal` — add a `note:` recommending truncation or hashing for external-facing deployments. Phase 2 pre-merge checklist: PII review must cover all `guidance.*` attributes with the same rigor as new free-text fields, regardless of their pre-existing status. Amend the free-text policy to say "new or newly-formalized." | Phase 1 and Phase 2 PRs include PII assessment for all string-typed attributes (not just those flagged). Reviewer checklist requires explicit sign-off. |
| R9-S10 | Data | low | `GENAI_TOKEN_USAGE_BUCKETS` and `GENAI_DURATION_BUCKETS` in `metrics.py` define histogram boundaries but have no corresponding registry representation. If Phase 2 `task_metrics.yaml` specifies histogram instrument types for `task.lead_time` etc., there's no mechanism to declare recommended bucket boundaries in the registry YAML. | Weaver registry YAML supports `instrument` and `unit` but bucket boundaries are typically runtime configuration, not schema. However, the plan's metric specification table (Phase 2) implies these are contractual. If boundaries are only in Python, they can drift from any documentation generated from the registry. | Add a `note:` annotation on histogram-type metrics in `task_metrics.yaml` referencing the Python constants for bucket boundaries (e.g., "See `GENAI_DURATION_BUCKETS` in `metrics.py` for recommended boundaries"). This creates a human-readable cross-reference even if machine-enforced parity isn't feasible. | Generated documentation (Phase 3) includes bucket boundary recommendations sourced from the `note:` annotations. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R7-S3: The quarterly cron job automation for collision monitoring is well-specified and directly addresses the highest-probability risk (gen_ai.code.* conflict). The auto-assign with escalation backup prevents the review from silently lapsing.
- R7-S4: Date format annotations are a concrete, low-cost addition that prevents ambiguity in `task.due_date`, `sprint.start_date`, and `sprint.end_date` — particularly important since ISO 8601 has multiple valid representations.
- R8-S2: Requiring metric definitions to include recommended dimensions/attributes (e.g., `task.type` on `task.lead_time`) is essential for ensuring the registry is useful for dashboard builders, not just schema validators.

#### Review Round R10
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 18:38:53 UTC
- **Scope**: Final review: the plan has been through 4 triage rounds (47 applied, 22 rejected/deferred). Look for internal inconsistencies introduced by the latest edits, any remaining gaps, or over-engineering that should be simplified.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R10-S1 | Data | high | Consolidate the redundant `Priority` and `Criticality` enums in `types.py`. | Both enums define identical `critical`, `high`, `medium`, `low` values, creating semantic confusion and code drift. The registry project is the ideal time to refactor this into a single canonical enum (`Priority` is the suggested survivor) and update all call sites. | Key Design Decisions | The `Criticality` enum is removed from `types.py` and the registry. A code search confirms no remaining usages. |
| R10-S2 | Interfaces | critical | Correct the `ProjectSchema.metric()` helper to conditionally apply the metric prefix. | The current implementation in `metrics.py` incorrectly prefixes all metrics, including OTel-conventional ones (e.g., `task.lead_time`), which will generate invalid metric names and break telemetry. The helper must differentiate between ContextCore-owned metrics and OTel-passthrough metrics. | `metrics.py` (implementation detail) | Unit tests for `ProjectSchema.metric()` confirm it correctly prefixes `MetricName.PROGRESS` (e.g., `lm1_progress`) but does NOT prefix `MetricName.TASK_LEAD_TIME` (e.g., `task.lead_time`). |
| R10-S3 | Risks | medium | Extend the free-text attribute policy [R6-S10] to explicitly govern unbounded string arrays (`string[]`). | Unbounded string arrays like `task.labels` carry the same high-cardinality risk as free-text fields but are not covered by the current policy. The policy should require explicit justification for `string[]` types and recommend bounded enum arrays as the preferred alternative. | Key Design Decisions > Security & Privacy Considerations | The policy text is updated. A PR adding a new `string[]` attribute without justification is correctly flagged during review. |
| R10-S4 | Validation | medium | Enhance the parity script's orphan detection [R7-S6] to be fully bidirectional. | The script currently detects registry YAML files not mapped in its configuration. It does not detect Python contract files (e.g., a new file in `src/contextcore/contracts/`) that have not been added to the mapping. The script should also scan the contracts directory to ensure all discovered contract files are present in its mapping. | Phase 1 > `scripts/verify_contracts_parity.py` | A unit test for the parity script confirms that adding a new `contracts/foo.py` with an enum, without updating the script's mapping table, causes a CI failure. |
| R10-S5 | Architecture | low | Create a local developer script to generate registry enum YAML from Python source. | The current developer workflow is reactive (change Python -> CI fails -> manually edit YAML). A helper script (`make semconv-sync-enum ENUM=TaskStatus`) would proactively generate the correct `members:` block, improving developer experience, reducing errors, and saving CI cycles. | Phase 1 > Makefile additions | A developer can run `make semconv-sync-enum ENUM=TaskStatus` and get a valid YAML snippet printed to stdout, which can be pasted into the registry file. |
| R10-S6 | Ops | medium | Define a formal process for graduating an attribute's stability level (e.g., from `development` to `stable`). | The plan requires a `stability` field but provides no criteria for promoting it. This leads to ambiguity. A formal policy should be documented with criteria like "in production for >= 3 months" and "used in >= 1 critical dashboard/alert". | Key Design Decisions > Registry Versioning Policy | The policy is documented. A PR to change an attribute's stability to `stable` includes a justification that references the new policy criteria. |
| R10-S7 | Validation | high | Expand the Phase 3 `live-check` to perform data type validation, not just attribute presence. | The registry defines types (`int`, `boolean`, etc.), but the SDK could mistakenly emit a value with the wrong type (e.g., `task.story_points="5"`). This breaks queries. The live-check should validate that the type of the value in the OTLP stream matches the type declared in the registry schema. | Phase 3 > Live-check integration | The `live-check` tool is run against a test OTLP stream containing a `task.story_points` attribute with a string value; the check fails with a type mismatch error. |
| R10-S8 | Security | medium | Augment the manual PII review with an automated linter to flag potentially sensitive attribute names. | The current PII review relies solely on human diligence. A linter in the `validate-semconv.yml` workflow should automatically flag new attributes containing keywords like `name`, `title`, `goal`, `url`, `comment`, etc., and require an explicit `# pii-reviewed` comment or similar annotation before passing. | Phase 1 > `.github/workflows/validate-semconv.yml` | A PR adding a `sprint.description` attribute without a PII review annotation fails the new linting step in CI. |
| R10-S9 | Architecture | medium | Use the resolved registry schema as input for the parity script instead of parsing raw YAML files. | The plan to parse raw YAML [R7-S9] is brittle and will break if ContextCore attributes ever use `ref:` to inherit from each other. The script should instead consume the output of `weaver registry resolve`, which provides a flattened, canonical view of the schema. This is more robust and avoids a future migration. | Phase 1 > `scripts/verify_contracts_parity.py` | The parity script is implemented to parse the JSON output of `weaver registry resolve semconv/`. This is verified by adding a `ref:` between two test attributes and confirming the script still works. |
| R10-S10 | Data | low | Expand the `SessionStatus` enum to include terminal failure and cancellation states. | The current `SessionStatus` (`ACTIVE`, `COMPLETED`, `ABANDONED`) lacks states for sessions that end non-gracefully. Adding `FAILED` and `CANCELLED` would provide a more complete lifecycle model, analogous to the richer `TaskStatus` and `HandoffStatus` enums, improving observability of agent session health. | `types.py` (implementation detail) | The new enum members are added to `SessionStatus` in Python and the corresponding registry YAML. Downstream dashboards can now distinguish between sessions that were abandoned vs. those that hit an unrecoverable error. |

#### Review Round R11

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 18:57:38 UTC
- **Scope**: Final review round 6: the plan has been through 5 triage rounds (52 applied, 37 rejected/deferred). Look for internal inconsistencies, contradictions between applied suggestions, or any remaining gaps. Most runtime code concerns and Phase 2/3 implementation details have been explicitly rejected — do not re-propose them.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R11-S1 | Validation | high | **Parity script does not cover `RecordingRuleName` or `AlertRuleName` from metrics.py** — The plan's parity script scope lists `MetricName`, `LabelName`, `EventType` from metrics.py, plus enums from types.py and deprecation mappings. But `metrics.py` also defines `RecordingRuleName` (6 members) and `AlertRuleName` (4 members) which encode canonical telemetry names that could drift from any future registry representation. Phase 2 pre-merge checklist [R9-S1] calls for covering "ALL enums in types.py" but says nothing about metrics.py enums beyond the three already covered. Add `RecordingRuleName` and `AlertRuleName` to the Phase 2 parity mapping table or document explicit exclusion rationale. | These enums define the exact string names used in Prometheus recording rules and alerting rules. If registry governance expands to cover rule definitions (plausible in Phase 3 with doc generation), drift between Python and YAML will be undetected without parity coverage. Even without registry YAML counterparts, the exclusion should be explicitly documented per the Phase 2 checklist pattern. | Phase 2 pre-merge checklist, as an addition to the R9-S1 enum coverage expansion paragraph | Verify the Phase 2 checklist either adds these to the mapping table or includes a documented exclusion rationale for each |
| R11-S2 | Architecture | high | **`ProjectSchema.promql()` and `logql()` use deprecated `LabelName.PROJECT` ("project") instead of `LabelName.PROJECT_ID` ("project.id")** — `metrics.py` defines both `PROJECT = "project"` and `PROJECT_ID = "project.id"` following OTel semantic conventions. `REQUIRED_LABELS` uses `PROJECT.value` ("project"), and `ProjectSchema.promql()`/`logql()` hardcode `LabelName.PROJECT.value`. But the registry will define the attribute as `project.id` per OTel conventions. This creates an internal inconsistency: the registry says `project.id`, the runtime emits `project`, and the parity script may not catch it because label names are validated from `LabelName` enum (which contains both). | The plan establishes the registry as governance truth and Python as runtime truth, with parity enforced between them. But if the registry uses `project.id` and Python helpers use `project`, there's a semantic gap that the parity script's enum-member comparison won't detect (both exist in `LabelName`). This needs a reconciliation decision documented in Phase 1. | Phase 1, as a new action item under "Key Design Decisions" or a note in the `project.yaml` file specification | Phase 1 `project.yaml` explicitly documents which label name form is canonical; parity script includes a check that `REQUIRED_LABELS` set members correspond to registry-defined attribute names |
| R11-S3 | Interfaces | medium | **`verify_contracts_parity.py` orphan detection has a false-positive gap for `spans/`, `events/`, and `metrics/` subdirectories** — R7-S6 established orphan detection that "fails if any registry YAML file in `semconv/registry/` has no corresponding mapping entry." But the registry also has YAML files in `semconv/spans/`, `semconv/events/`, and `semconv/metrics/` that reference attributes. These files are not covered by orphan detection, so a new span or event YAML file could be added without any parity validation. | The orphan detection scope is explicitly limited to `semconv/registry/` but the overall verification story assumes all YAML files are governed. A span definition referencing a non-existent attribute would be caught by `weaver registry check`, but a span file that's never referenced by any parity check could accumulate semantic drift (e.g., wrong requirement_levels, missing body schemas) without detection. | Phase 1, as a scope clarification in the `verify_contracts_parity.py` specification (item 10) | Add a note that orphan detection covers `semconv/registry/` only in Phase 1, with Phase 2 extending to span/event/metric YAML files, OR document why `weaver registry check` is sufficient for non-registry files |
| R11-S4 | Risks | high | **No rollback or error handling for the OTel dependency archive fetch failure during the day-one smoke test [R3-S4, R7-S2]** — The plan specifies a day-one smoke test that fetches `v1.34.0.zip[model]` and validates `ref:` resolution. If this archive is unavailable (GitHub outage, tag renamed, format changed), the entire Phase 1 kickoff is blocked with no documented workaround. | The risk table covers "OTel semconv dependency fetch flaky in CI" with caching and retry, but the day-one smoke test is a one-time manual step that predates CI setup. If it fails, the author needs to know: (a) how to diagnose archive vs. Weaver format issues, (b) whether to try an alternate tag, (c) when to escalate. This is the highest-risk moment in Phase 1 because no CI infrastructure exists yet to help. | Phase 1, item 1 (registry_manifest.yaml), as a troubleshooting note after the smoke test description | Author confirms they can articulate the diagnostic steps before starting Phase 1; smoke test includes explicit success/failure criteria and a fallback to a known-good local archive |
| R11-S5 | Data | medium | **`GENAI_TOKEN_USAGE_BUCKETS` and `GENAI_DURATION_BUCKETS` in metrics.py have no registry counterpart planned** — These histogram bucket boundaries are critical operational parameters that affect metric precision and storage cost. The Phase 2 metric definitions specify instrument type and unit but not bucket boundaries. | Bucket boundaries are a key part of the metric contract — changing them breaks dashboard percentile calculations and alert thresholds. If the registry governs metrics, it should either declare advisory bucket boundaries or explicitly document that bucket configuration is runtime-only and outside registry scope. Without this decision, Phase 2 could introduce conflicting bucket specs. | Phase 2, `semconv/metrics/task_metrics.yaml` specification, as a design note on whether `note:` annotations should document recommended bucket boundaries for histogram metrics | Phase 2 metric YAML files either include `note:` annotations with bucket recommendations or the plan explicitly states bucket boundaries are runtime-only configuration |
| R11-S6 | Validation | medium | **The plan specifies 10 task events in `task_events.yaml` but `EventType` enum has 11 task/subtask members** — Phase 1 item 7 lists: task.created, task.status_changed, task.blocked, task.unblocked, task.completed, task.cancelled, task.assigned, task.commented, task.deliverables_verified, task.progress_updated, subtask.completed (11 items). But the plan text says "Events matching `EventType` enum" and `EventType` in metrics.py has exactly these 10 task events plus `subtask.completed`. Count appears correct at 11, but `task.deliverables_verified` is NOT in the `EventType` enum — it appears nowhere in metrics.py. | This is a phantom event. `task.deliverables_verified` was likely introduced by an applied suggestion but never reconciled with `EventType`. The parity script would catch this post-implementation, but it means Phase 1 will either fail parity (YAML has an event not in Python) or require adding the event to `EventType` first. This needs to be an explicit action item. | Phase 1, item 7 (task_events.yaml), add an action item: "Add `TASK_DELIVERABLES_VERIFIED = 'task.deliverables_verified'` to `EventType` enum before creating `task_events.yaml`, or remove this event from the registry scope" | Parity script's bidirectional check [R7-S1] catches this; but documenting it upfront avoids a Phase 1 blocking surprise |
| R11-S7 | Ops | medium | **No monitoring or alerting for the quarterly collision review cron job [R7-S3]** — The plan specifies a GitHub Actions cron job that auto-opens quarterly issues for collision review with 1-week escalation. But cron jobs in GitHub Actions silently fail if the workflow file has syntax errors, the repo goes dormant, or Actions minutes are exhausted. | If the cron job silently fails, the entire collision monitoring strategy for `gen_ai.code.*` becomes a paper exercise. The plan's risk mitigation for namespace collision depends on this automation actually running. A simple dead-man's-switch (e.g., the cron job also pings a monitoring endpoint, or the project lead manually verifies the issue was created) would close this gap. | Risk Mitigation table, as an addition to the `gen_ai.code.*` conflict row | Verify that the quarterly issue was actually created within 48 hours of the expected schedule; add a fallback manual calendar reminder |
| R11-S8 | Architecture | medium | **`Criticality` and `Priority` enums have identical members but different semantic scopes — no registry-level disambiguation planned for Phase 1** — `types.py` defines both `Priority` (critical/high/medium/low) and `Criticality` (critical/high/medium/low) with identical values. R9-S8 addresses `business.criticality` vs `task.priority` disambiguation but only in Phase 2's `business.yaml`. Phase 1 creates `task.yaml` with `task.priority` referencing `Priority` enum. If someone later queries `task.priority = "critical"` they could confuse it with business criticality. | Phase 1 `task.yaml` should include a `note:` annotation on `task.priority` proactively distinguishing it from business criticality, rather than waiting for Phase 2 to add the inverse annotation on `business.criticality`. This is especially important because Phase 1 docs will be consumed before Phase 2 ships. | Phase 1, item 2 (task.yaml), add `note:` annotation on `task.priority`: "Work-item scheduling priority. Distinct from business.criticality which measures organizational impact." | Review Phase 1 `task.yaml` PR for disambiguation note on `task.priority` |
| R11-S9 | Security | medium | **`task.url` flagged for "per-deployment guidance" but no concrete mechanism exists to enforce or surface this guidance** — The plan notes `task.url` may contain internal URLs and flags it for "per-deployment guidance in documentation." But there's no registry mechanism (e.g., a `sensitivity:` field, a `note:` annotation, or a doc-generation template marker) to surface this warning to consumers. | Without a machine-readable marker, the PII concern for `task.url` exists only in this plan document and will not appear in generated documentation (Phase 3) or be visible to downstream consumers examining the registry. The free-text field policy [R6-S10] establishes a pattern for restricting risky attributes; `task.url` needs an analogous visible marker. | Phase 1, item 2 (task.yaml), add a `note:` annotation on `task.url`: "May contain internal URLs. Deployers should evaluate exposure risk and consider redaction." | Phase 1 `task.yaml` PR includes `note:` annotation on `task.url`; Phase 3 doc generation templates render `note:` fields visibly |
| R11-S10 | Validation | low | **`BSP_*` and `BLRP_*` constants in metrics.py are OTel SDK defaults documented for reference but have no validation that they actually match the SDK version in use** — These 8 constants claim to be "SDK-standard defaults" but are hardcoded. If the OTel Python SDK changes defaults in a future release, these constants silently become lies. | This is low severity because they're documented as reference values, not used for configuration. However, the plan's emphasis on preventing drift (the entire registry effort) suggests these should at least have a comment noting the SDK version they were verified against, or an integration test that asserts they match the SDK's actual defaults. | Out of scope for registry plan — but worth a `# Verified against opentelemetry-sdk==1.x.x` comment in metrics.py as a follow-up hygiene task | Optional: integration test imports SDK BatchSpanProcessor defaults and asserts they match constants |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R9-S1: The Phase 2 enum coverage gap is real and R11-S1 above extends it further to metrics.py enums — both should be addressed together.
- R9-S3: Sprint events (`sprint.started`, `sprint.ended`) being split into a separate Phase 2 file is the right call and was correctly applied.
- R9-S5: The revert runbook addition for `PARITY_CI_DISABLED` circuit breaker closes a genuine deadlock scenario.
- R9-S8: The `business.criticality` vs `task.priority` disambiguation note is essential — R11-S8 above argues it should start in Phase 1 rather than waiting for Phase 2.
- R10-S6: Stability graduation criteria are well-defined and provide the right governance rigor for promotion decisions.

#### Review Round R12
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 18:59:04 UTC
- **Scope**: Final review round 6: the plan has been through 5 triage rounds (52 applied, 37 rejected/deferred). Look for internal inconsistencies, contradictions between applied suggestions, or any remaining gaps. Most runtime code concerns and Phase 2/3 implementation details have been explicitly rejected — do not re-propose them.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R12-S1 | Data | high | Model `ProjectSchema` constraints within the semantic convention registry. | The `ProjectSchema` class defines project-specific value sets (e.g., valid `phases` for `lm1_campaign`), which are a form of semantic convention not currently governed by the Weaver registry. This creates a drift risk between runtime behavior and documented conventions. | New CI job; new `semconv/projects/*.yaml` files to define project-specific value sets. | CI fails if `ProjectSchema` instances in Python drift from their corresponding YAML definitions. |
| R12-S2 | Validation | high | Enhance deprecation parity check to validate source attribute existence. | The current check [R4-S9] validates the `ATTRIBUTE_MAPPINGS` dict against YAML `deprecated:` fields but does not verify that the source (deprecated) attribute still exists in Python contracts. A premature removal would cause a runtime failure in the dual-emit logic that CI would miss. | `scripts/verify_contracts_parity.py` | Add a unit test where a deprecated constant is removed from a Python fixture; the parity script must fail. |
| R12-S3 | Architecture | medium | Clarify governance scope for `RecordingRuleName` and `AlertRuleName` enums. | These enums are defined in Python contracts (`metrics.py`) but have no corresponding registry YAML. This creates a parity gap where the parity script's "orphan detection" [R7-S6] will either fail or silently ignore these contracts. | `scripts/verify_contracts_parity.py` documentation and implementation. | The plan must explicitly state that these enums are out of scope for parity checking, or a new `semconv/rules/` schema must be added to the registry to model them. |
| R12-S4 | Ops | high | Implement production telemetry validation against the registry. | CI validation only prevents non-compliant code from being merged. It doesn't detect legacy or misconfigured clients emitting non-compliant telemetry in production. A process to periodically sample and `live-check` production data is needed to ensure operational reality matches the governed schema. | Phase 3, new operational runbook and automation. | A known-bad OTLP payload sampled from production is run against `weaver registry live-check` and triggers a validation failure alert. |
| R12-S5 | Risks | medium | Formalize downstream audit [R4-S5] with a mandatory "Downstream Impact Assessment" ticket. | Relying on an informal audit of "known downstream systems" is brittle. Mandating a formal, ticketed assessment for breaking changes creates a durable audit trail and forces explicit sign-off from all affected dashboard, alert, and service owners. | Deprecation Policy [R2-S10] and PR template for major version bumps. | A PR removing a deprecated attribute cannot be merged without a link to the completed assessment ticket with required sign-offs. |
| R12-S6 | Security | high | Mitigate supply chain risk by mirroring the OTel semconv dependency archive. | Fetching the dependency archive directly from GitHub on each CI run introduces a supply chain risk (e.g., compromised tag). The archive should be mirrored internally, with CI validating its checksum against a pre-approved hash before use, preventing tampering. | CI workflow (`.github/workflows/validate-semconv.yml`) and internal artifact repository. | CI fails if the checksum of the mirrored artifact does not match the pinned hash. |
| R12-S7 | Risks | critical | Make `HandoffStatus` discrepancy resolution [R5-S4] a Phase 1 blocker. | Deferring resolution of a known conflict between the source of truth (code) and documentation to Phase 2 is risky. It allows Phase 1 development to proceed on an unstable foundation, potentially leading to rework or runtime errors if teams build against incorrect documentation. | Phase 1 implementation plan. | The `HandoffStatus` enum in `types.py` is reconciled with documentation, and the decision is reflected in the registry, *before* the Phase 1 PR is merged. |
| R12-S8 | Ops | medium | Introduce granular CI skips: `[skip-weaver]` and `[skip-parity]`. | The single `[skip-semconv]` escape hatch [R5-S5] incorrectly assumes the parity script can never have false positives. A bug in the script could block all development. Granular skips allow bypassing a broken script (`[skip-parity]`) while still running schema checks, providing a safer, more auditable emergency override. | CI workflow and Revert Runbook [R9-S5]. | A PR with `[skip-parity]` successfully bypasses the parity check while still running Weaver checks, and its usage is logged for audit [R6-S3]. |
| R12-S9 | Interfaces | low | Use a machine-readable `format` field for date attributes. | Specifying date formats in a `note:` field [R7-S4] is not machine-readable. Adding a formal `format: "ISO_8601"` field, in addition to the note, allows for automated validation and tooling, aligning with emerging patterns in OTel semantic conventions. | `semconv/registry/task.yaml`, `semconv/registry/sprint.yaml`. | The new `format` field is present in the resolved registry schema artifact generated by `weaver registry resolve`. |
| R12-S10 | Risks | low | Implement a proactive "namespace reservation" process for OTel extensions. | The current collision monitoring process [R1-S2, R7-S3] is reactive. A proactive process, where developers post their intent to use a namespace (e.g., `gen_ai.code.*`) in relevant upstream OTel SIG issues, provides early community visibility and reduces the risk of future conflicts. | Namespace Governance Policy [R1-S2]. | The policy document is updated with this new procedural requirement for creating OTel-extension namespaces. |

#### Review Round R13

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 19:59:22 UTC
- **Scope**: Final review: the plan has been through 6 triage rounds (68 applied, 52 rejected). Look for genuine gaps the prior 12 rounds missed. Do NOT rehash areas marked as substantially addressed.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R13-S1 | Ops | high | Add a dependency-lock mechanism for the OTel semconv archive hash. The pinned URL `v1.34.0.zip[model]` is fetched from GitHub on every CI run but has no integrity verification. Add a `semconv/otel-dependency.lock` file containing the SHA-256 hash of the archive, verified in CI before Weaver consumes it. | Supply-chain risk: a compromised or re-tagged upstream archive could silently alter `ref:` attribute definitions. This is a second-order risk that only matters *because* the plan correctly pins a specific tag — but tags are mutable in git. The quarterly upgrade PR (R6-S1) should regenerate this lockfile. No prior suggestion addresses archive integrity; rejected items focused on different concerns (caching, flakiness, version pinning — all addressed). | Risk Mitigation table — new row for "OTel archive integrity". Also add a lockfile verification step in `.github/workflows/validate-semconv.yml` before `weaver registry check`. | CI step: `sha256sum` of downloaded archive compared against lockfile; mismatch fails the build. Quarterly upgrade PR must update the lockfile and the diff is human-reviewable. |
| R13-S2 | Validation | high | Define an explicit contract for event `body` schema validation in `verify_contracts_parity.py`. Phase 1 mandates event body schemas (R3-S2) but the parity script's scope (item 10) only covers enums, string constants, and deprecation mappings — it never validates that event body field names/types match any Python-side event payload structure. | The plan creates a validation gap: event bodies are defined in YAML but never cross-checked against runtime code. If a Python emitter adds a `previous_status` field but the YAML schema calls it `old_status`, no CI check catches it. This is a genuine gap left after the 12 rounds of enum/metric/deprecation parity work. | Phase 1 item 10 (`verify_contracts_parity.py`) — add a bullet for event body field validation, or explicitly document it as a Phase 2 scope item with a tracking issue. Phase 1 Verification section should note this as a known limitation. | Add a unit test fixture with a mismatched event body field name → script must fail. If deferred to Phase 2, the Phase 2 pre-merge checklist must include this item. |
| R13-S3 | Risks | medium | Add a risk mitigation entry for **Weaver schema language breaking changes between pinned versions**. The plan pins Weaver version and OTel semconv version independently, but a Weaver upgrade may require YAML syntax changes (e.g., `members` format, `body` schema syntax) that silently invalidate existing registry files even if the OTel dependency hasn't changed. | The current risk table covers Weaver binary availability and upstream OTel format changes, but not the interaction between Weaver tool version upgrades and existing YAML syntax. Since Weaver is pre-1.0, schema language changes are likely. The quarterly OTel dependency upgrade could coincidentally require a Weaver upgrade that breaks existing YAML. These two upgrades should be decoupled and sequenced. | Risk Mitigation table — new row. Also add a note to the quarterly upgrade cadence (R6-S1) specifying that Weaver tool upgrades and OTel dependency upgrades should happen in separate PRs to isolate breakage. | Weaver upgrade PR runs `weaver registry check` against existing YAML *before* any OTel dependency change. If it fails, the Weaver upgrade is blocked until YAML is migrated. |
| R13-S4 | Architecture | medium | Specify the expected behavior when `weaver registry resolve` encounters ContextCore attributes that *shadow* upstream OTel attribute names (not just `ref:` links, but same-named attributes defined locally). The plan covers `ref:` resolution and collision monitoring for `gen_ai.code.*`, but doesn't define what happens if a ContextCore-owned attribute accidentally uses a name that upstream OTel later defines (e.g., `task.id` or `project.id` appearing in a future OTel domain). | The namespace governance policy (R1-S2) handles intentional OTel-extension namespaces but assumes ContextCore-owned namespaces like `task.*` won't collide. This is likely true today but becomes a risk as OTel expands into project-management observability. A shadowing attribute would pass `weaver registry check` (no error — it's a local definition) but create semantic confusion in mixed-signal environments. | Namespace Governance Policy section — add a "Collision detection" paragraph: the weekly upstream `main` scan (R6-S7) should also grep for any new upstream attribute names that match ContextCore-owned attribute names, and flag them as warnings. | Weekly CI cron job includes `weaver registry resolve` of upstream-only registry, diffs attribute names against ContextCore-owned names, opens an issue on any new overlap. |
| R13-S5 | Data | medium | Mandate that `semconv/registry_manifest.yaml` includes a `schema_url` field that will be emitted as the OTLP `SchemaUrl` on all resources/scopes produced by the SDK. Without this, OTLP consumers cannot programmatically determine which schema version a telemetry payload conforms to. | OTel's schema mechanism (https://opentelemetry.io/docs/specs/otel/schemas/) relies on `SchemaUrl` to enable automatic signal transformation across schema versions. The plan versions the registry via `semconv_version` but never connects this to the OTLP wire format. This means consumers receiving signals from different ContextCore versions cannot distinguish them or apply schema transformations. This is a data-layer gap not covered by any prior suggestion. | Phase 1 item 1 (`registry_manifest.yaml`) — add a `schema_url` field following the pattern `https://contextcore.dev/schemas/<semconv_version>`. Phase 1 Verification — add a check that the SDK's emitted `SchemaUrl` matches the registry version. | `verify_contracts_parity.py` extracts `semconv_version` from manifest, confirms SDK resource setup code references the same version string. Phase 2: `weaver registry live-check` validates `SchemaUrl` on emitted OTLP. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R12-S2: The deprecation mapping validation with unit test fixtures for premature removal is a critical safety net that should be prioritized — runtime dual-emit breakage is a high-severity failure mode.
- R11-S6: Adding `TASK_DELIVERABLES_VERIFIED` to `EventType` before creating the events YAML is a prerequisite that blocks Phase 1 correctness; this should be treated as a Phase 1 blocker.
- R11-S8: The disambiguation note on `task.priority` vs `business.criticality` prevents a real semantic confusion that would compound in Phase 2 when both attributes coexist in the same trace context.
- R9-S1: Extending the parity mapping table to cover all enums in Phase 2 is essential — partial coverage creates a false sense of safety.
- R9-S8: The `business.criticality` annotation is the Phase 2 counterpart to R11-S8 and both should be applied together for consistency.

#### Review Round R14
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 20:00:15 UTC
- **Scope**: Final review: the plan has been through 6 triage rounds (68 applied, 52 rejected). Look for genuine gaps the prior 12 rounds missed. Do NOT rehash areas marked as substantially addressed.
| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R14-S1 | Architecture | high | Instrument all telemetry with a resource attribute `contextcore.semconv.version` populated from `registry_manifest.yaml` during the build process. | Makes telemetry self-describing, enabling downstream consumers to validate data against the correct schema version, detect non-compliant producers, and manage breaking changes gracefully. It shifts from periodic pre-release audits to continuous, observable governance. | Key Design Decisions, new section "Telemetry Schema Versioning". | A unit test verifies the build process injects the correct version string into the SDK's resource attributes. An OTel collector rule validates the presence of this attribute on a sample of production traces/metrics. |
| R14-S2 | Validation | high | Implement a production validation mechanism that samples a percentage of OTLP data (e.g., 1%) and runs `weaver registry live-check` against it. Conformance failures should generate a high-priority metric and alert. | CI validation only confirms that the *intended* schema matches the contracts; it cannot detect runtime bugs where specific code paths fail to instrument telemetry correctly. A production sampling validator provides a critical feedback loop to catch these real-world deviations, ensuring data quality and reliability. | Phase 3 plan, evolving the "Live-check integration" from a developer tool (`Makefile` target) into a production monitoring system. | In a staging environment, deploy a service version that intentionally emits non-compliant telemetry (e.g., omits a required attribute). The sampling validator must detect this and fire an alert within a defined SLA. |
| R14-S3 | Architecture | medium | Add a `metadata.owner` field to each attribute group's YAML file (e.g., `task.yaml`) pointing to a team or designated individual, and define a process for resolving semantic interpretation disputes. | As the number of attributes and teams grows, the risk of semantic drift increases (e.g., teams interpreting `task.lead_time` differently). Formalizing ownership clarifies who to consult for clarification and establishes a process for resolving disagreements, preventing data interpretation silos. | Key Design Decisions, new section "Semantic Governance". | A CI script verifies that all `registry/*.yaml` files contain a non-empty `metadata.owner` field. The dispute resolution process is documented in a `CONTRIBUTING.md` file within the `semconv/` directory. |
| R14-S4 | Ops | medium | Modify the CI workflow to require a mandatory justification for using `[skip-semconv]`. The workflow should parse the PR body for a specific section (e.g., `### Semconv Skip Justification`) and fail if the label is present but the section is empty or boilerplate. | The current plan logs *that* a skip occurred but not *why*. Requiring justification creates a high-quality audit trail, discourages casual use of the escape hatch, and provides valuable data for the project lead's root cause analysis when the abuse threshold is met, addressing the second-order risk of the feature's misuse. | Risk Mitigation table, row for "Weaver CI blocks unrelated PRs with false positives". | Create a test PR with the `[skip-semconv]` label but no justification; CI must fail. Create a second test PR with both; CI must pass and include the justification in its summary comment. |
| R14-S5 | Architecture | medium | For recurring attribute patterns (e.g., identifiers like `task.id`, `project.id`), define them once in a central `_base.yaml` file and use local `ref:` pointers in other files (e.g., `task.id: { ref: base.id }`). | The current plan defines similar attributes like `task.id` and `project.id` independently, violating the DRY principle and risking inconsistencies in documentation, stability, or type as the registry scales. Using a local `ref:` pattern ensures consistency and simplifies maintenance. | Key Design Decisions, extending the "Define locally vs reference from OTel" section to include internal `ref` patterns. | `weaver registry resolve` must correctly expand the local refs. A test case involves changing a `brief` text in `_base.yaml` and verifying the resolved output shows the change for all inheriting attributes. |

#### Review Round R15

- **Reviewer**: claude-4 (claude-opus-4-6)
- **Date**: 2026-02-09 20:13:12 UTC
- **Scope**: Final review: the plan has been through 6 triage rounds (68 applied, 52 rejected). Look for genuine gaps the prior 12 rounds missed. Do NOT rehash areas marked as substantially addressed.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R15-S1 | Ops | high | Add a CI step or pre-merge gate that detects when `contracts/types.py` or `contracts/metrics.py` are modified in a PR that does NOT also modify files under `semconv/`, and vice versa — emitting a warning (not blocking) that parity drift may be introduced. | The parity script catches drift *after* both sides exist, but the current design has no early signal when a developer changes only one side. A developer adding a new enum member to `TaskStatus` in Python without touching `task.yaml` will pass CI (parity script runs but the YAML is unchanged, so both sides are "in sync" for the old set) — the drift only surfaces when someone later tries to update the YAML. This is a second-order gap: the parity script validates what's committed, but doesn't flag incomplete commits. A co-change detector closes this window. | Phase 1, item 8 (`.github/workflows/validate-semconv.yml`) — add a `co-change-check` job that inspects the PR's changed-file list and posts a PR comment if only one side is modified. | Simulate a PR that adds an enum member to `types.py` without touching `semconv/registry/task.yaml`; verify the warning comment is posted. Simulate a PR that changes both; verify no warning. |
| R15-S2 | Architecture | medium | Define an explicit policy for attribute `brief` and `note` field language — specifically, whether `brief` must be ≤120 characters and whether `note` supports Markdown formatting — and enforce via a linting step in CI. | Multiple accepted suggestions (R11-S8, R11-S9, R7-S4) add `note:` annotations to specific attributes, but there is no stated convention for their format, length, or style. If different contributors write notes in inconsistent styles (some with Markdown links, some with raw URLs, some multi-paragraph), the Phase 3 doc generation (R6-S9) will produce inconsistent output. Establishing the convention now prevents rework when templates are authored. | New subsection under "Key Design Decisions" between "YAML Enum Convention" and "Requirement Level Guidelines". Also add a `weaver registry check` custom policy or a lightweight lint script in Phase 1 CI. | Review all `note:` fields in Phase 1 YAML files against the documented convention. Add a CI lint step that flags violations. |
| R15-S3 | Risks | high | Add a risk entry and mitigation for the scenario where the pinned OTel semconv archive (v1.34.0) does NOT contain the `gen_ai.*` attributes needed for `ref:` resolution in `agent.yaml`, and the day-one smoke test (R3-S4, R7-S2) fails. | The plan says to "identify which OTel semconv tag first includes them and update the pin" if the smoke test fails, but treats this as a quick fix. In reality, `gen_ai.*` attributes were added to OTel semconv relatively recently and their schema structure has changed across tags. If v1.34.0 lacks them or uses an incompatible schema shape, Phase 1 is blocked until a compatible tag is identified *and* validated against the rest of the registry. The plan has no fallback strategy (e.g., temporarily inlining the needed `gen_ai.*` definitions with a `TODO` to switch to `ref:` once upstream stabilizes). | Risk Mitigation table, new row. Also add a fallback step to the day-one smoke test procedure in Phase 1, item 1. | Execute the day-one smoke test against v1.34.0 archive before any other Phase 1 work. If it fails, exercise the fallback (inline definitions) and verify `weaver registry check` passes. |
| R15-S4 | Validation | medium | Add an explicit Phase 1 verification criterion that the `verify_contracts_parity.py` script itself has ≥90% branch coverage in its unit tests, particularly covering the `ref:` skip logic, orphan detection, and bidirectional mismatch paths. | The plan specifies that the parity script must have unit tests with known-good and known-bad fixtures (R7-S1, R7-S9), but does not set a coverage bar. Given that this script is the sole enforcement mechanism for registry–runtime parity and is explicitly never skippable via `[skip-semconv]` (R5-S5), a bug in the script itself is a silent governance failure. The revert runbook (R9-S5) even adds a `PARITY_CI_DISABLED` emergency circuit breaker, implying the script is critical infrastructure. Critical infrastructure should have measured test coverage. | Phase 1, item 10 (`scripts/verify_contracts_parity.py`) — add coverage requirement to the verification criteria. Phase 1 CI workflow should run `pytest --cov=scripts/verify_contracts_parity --cov-fail-under=90`. | Run `pytest --cov` on the parity script test suite; verify ≥90% branch coverage. Inspect coverage report to confirm `ref:` skip, orphan detection, and both directions of mismatch are exercised. |
| R15-S5 | Security | medium | Add a CI check or policy that the OTel semconv dependency archive URL in `registry_manifest.yaml` uses a pinned commit SHA (or is accompanied by a checksum file), not just a tag-based URL, to prevent tag-substitution supply chain attacks. | The plan pins to a tag (`v1.34.0`) but tags are mutable in Git — an attacker with write access to the upstream repo could move the tag to point to a malicious commit. The archive is fetched in CI and used to resolve `ref:` attributes, so a tampered archive could inject unexpected attribute definitions. Given that 4 security suggestions have been accepted (R2-S4, R6-S4, R7-S7, R11-S9), supply chain integrity of the single external dependency has not been addressed. A SHA pin or checksum verification closes this gap. | Phase 1, item 1 (`registry_manifest.yaml`) — add a comment with the expected SHA256 of the archive. Phase 1, item 8 (CI workflow) — add a step that verifies the downloaded archive's SHA256 before running Weaver. Also add to "Registry format changes upstream" risk mitigation row. | Compute SHA256 of the v1.34.0 archive, store in `.weaver-deps-checksums`. CI step downloads archive, computes hash, compares. Simulate a tampered archive (different hash) and verify CI fails. |

**Endorsements** (prior untriaged suggestions this reviewer agrees with):
- R13-S1: Operational monitoring of the quarterly cron job is a genuine gap — if the GitHub Actions cron silently fails, collision monitoring stops without anyone noticing.
- R13-S5: Explicit attribute-naming convention (snake_case, no abbreviations) prevents inconsistency across 17+ namespaces as multiple contributors add Phase 2 attributes.
- R14-S4: Runbook for the `PARITY_CI_DISABLED` circuit breaker is needed — the plan introduces the escape hatch but doesn't document the re-enablement procedure, creating risk of it staying disabled indefinitely.

#### Review Round R16
- **Reviewer**: gemini-2.5 (gemini-2.5-pro)
- **Date**: 2026-02-09 20:14:09 UTC
- **Scope**: Final review: the plan has been through 6 triage rounds (68 applied, 52 rejected). Look for genuine gaps the prior 12 rounds missed. Do NOT rehash areas marked as substantially addressed.

| ID | Area | Severity | Suggestion | Rationale | Proposed Placement | Validation Approach |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| R16-S1 | Ops | high | Introduce a managed "parity exception" mechanism for the `verify_contracts_parity.py` script. | The current strict, bidirectional parity check (R7-S1) blocks iterative development where runtime code (Python) may temporarily lead the governance schema (YAML). The `[skip-semconv]` label intentionally does not bypass this check (R5-S5), creating a workflow bottleneck. A formal exception process (e.g., an `allowlist.yml` file requiring specific PR approval) allows for auditable, temporary deviations without resorting to emergency circuit breakers, balancing governance with developer velocity. | Amend the description of `scripts/verify_contracts_parity.py` and the CI workflow (`.github/workflows/validate-semconv.yml`). | The parity script is modified to ignore mismatches listed in the allowlist. A PR modifying the allowlist triggers a CODEOWNERS rule requiring architect sign-off. |
| R16-S2 | Risks | high | Augment the deprecation policy's downstream audit (R4-S5) with a mandatory "public comment period" for breaking changes. | The current audit focuses on known consumers (dashboards, alerts). It misses "dark matter" consumers like ad-hoc analytics or data science pipelines that consume OTLP data directly. Before removing a deprecated attribute, the plan should require broadcasting the intent to a wide engineering audience and waiting a defined period (e.g., 3-4 weeks) for teams to self-identify dependencies. This mitigates the risk of breaking unknown, critical systems. | Add a new step to the "Deprecation Policy" section. | Create a standard operating procedure (SOP) document for major version bumps that includes a checklist item for initiating and completing the public comment period before the removal PR can be merged. |
| R16-S3 | Data | medium | Formalize a distinct stability and deprecation lifecycle for individual enum members, separate from their parent attribute. | The current stability policy (R10-S6) applies to attributes, but not explicitly to the members of their enums. A `stable` attribute can have a new, `development` enum member added, which can break downstream consumers unprepared for the new value (e.g., Grafana value mappings). This suggestion requires new enum members to start at `development` stability and follow their own promotion criteria. It also clarifies that removing a `stable` enum member is a breaking change requiring a major version bump. | Add a subsection under "Registry Versioning Policy" or "Enum source of truth". | The `verify_contracts_parity.py` script is updated to check for a `stability:` key on each `members:` entry in the YAML. The major version bump checklist (R6-S8) is updated to include auditing for removed/renamed enum members. |
| R16-S4 | Architecture | high | Enhance the quarterly collision monitoring process (R7-S3) to proactively check ContextCore's custom namespaces (`task.*`, `project.*`, etc.) against the OTel semantic convention `main` branch. | The current collision monitoring focuses on OTel extensions (`gen_ai.code.*`). It does not protect against the risk of a future OTel standard introducing an attribute that conflicts with our core, custom namespaces (e.g., OTel adding `task.id`). The automated quarterly job should diff our entire registry against the latest upstream OTel spec (not the pinned version) to provide early warning of future namespace collisions, allowing for planned migration instead of emergency refactoring. | Amend the "Risk Mitigation" table entry for `gen_ai.code.*` conflict, broadening its scope. | The GitHub Actions cron job script is modified to fetch the latest OTel `main` branch archive, run `weaver registry resolve` on both registries, and script a check for intersecting attribute keys. A finding automatically creates a GitHub issue. |
| R16-S5 | Ops | medium | Mandate a "partial generation" strategy for Phase 3 documentation, where generated schema tables are included into hand-written narrative documents. | The Phase 3 plan to auto-generate `docs/semantic-conventions.md` (R6-S9) risks destroying valuable, hand-written narrative, examples, and context if the entire file is overwritten. A "partial generation" approach, where Weaver generates only the schema tables as snippets that are then included into a primarily human-maintained markdown file, preserves the best of both worlds: machine-validated schema definitions embedded within human-curated documentation. | Add a clarifying bullet point under the "Documentation generation" section in Phase 3. | The Phase 3 deliverable is redefined as: (1) Weaver templates that produce markdown partials, (2) a CI check that verifies the committed partials are up-to-date, and (3) the primary documentation files are modified to use an include mechanism. |
